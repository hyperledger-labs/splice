-- This migration adds the following columns to the update_history_creates table:
-- record_time, update_id, domain_id, migration_id
-- This information is already present in the update_history_transactions table,
-- we are denormalizing it in order to allow us to write more efficient queries.

-- Step 1: create a copy of update_history_creates with the new columns
-- We use this approach because it is orders of magnitude faster than using ALTER TABLE + UPDATE.

create table update_history_creates_v2
(
    history_id              int          not null,
    row_id                  bigint generated by default as identity,
    ingested_at             timestamptz  not null default now(),
    event_id                text         not null,
    update_row_id           bigint       not null,
    contract_id             text         not null,
    created_at              bigint       not null,
    template_id_package_id  text         not null,
    template_id_module_name text         not null,
    template_id_entity_name text         not null,
    package_name            text         not null,
    create_arguments        jsonb        not null,
    signatories             text[]       not null, -- not null contraint missing in original
    observers               text[]       not null, -- not null contraint missing in original
    contract_key            jsonb,
    record_time             bigint       not null,
    update_id               text         not null,
    domain_id               text         not null,
    migration_id            int          not null,

    constraint update_history_creates_v2_pkey primary key (row_id)
);

insert into update_history_creates_v2 (
    history_id,
    row_id,
    ingested_at,
    event_id,
    update_row_id,
    contract_id,
    created_at,
    template_id_package_id,
    template_id_module_name,
    template_id_entity_name,
    package_name,
    create_arguments,
    signatories,
    observers,
    contract_key,
    record_time,
    update_id,
    domain_id,
    migration_id
) select
    c.history_id,
    c.row_id,
    c.ingested_at,
    c.event_id,
    c.update_row_id,
    c.contract_id,
    c.created_at,
    c.template_id_package_id,
    c.template_id_module_name,
    c.template_id_entity_name,
    c.package_name,
    c.create_arguments,
    c.signatories,
    c.observers,
    c.contract_key,
    u.record_time,
    u.update_id,
    u.domain_id,
    u.migration_id
from update_history_creates c
    join update_history_transactions u on c.update_row_id = u.row_id;


-- Step 2: drop the old table and rename the new one

alter table acs_snapshot_data
    drop constraint acs_snapshot_data_create_id_fkey;
drop table update_history_creates;


alter table update_history_creates_v2
    rename to update_history_creates;
alter table update_history_creates
    rename constraint update_history_creates_v2_pkey to update_history_creates_pkey;


-- Step 3: add indexes (do this before adding foreign key constraints, because the index will be used in verifying the constraint)

create unique index updt_hist_crea_unique
    on update_history_creates (update_row_id, event_id);

create index contract_create_lookup
    on update_history_creates (contract_id);

create index updt_hist_crea_hi_tidmn_tiden_pn_rid
    on update_history_creates (history_id, template_id_module_name, template_id_entity_name, package_name, row_id);

create index updt_hist_crea_hi_mi_rt
    on update_history_creates(history_id, migration_id, record_time);


-- Step 4: restore foreign key constraints and sequences

alter table update_history_creates
    add constraint update_history_creates_history_id_fkey
        foreign key (history_id) references update_history_descriptors (id);

alter table update_history_creates
    add constraint update_history_creates_update_row_id_fkey
        foreign key (update_row_id) references update_history_transactions (row_id);

-- This works because we copy the values in the autogenerated row_id column
alter table acs_snapshot_data
    add constraint acs_snapshot_data_create_id_fkey
        foreign key (create_id) references update_history_creates (row_id);

select setval(pg_get_serial_sequence('update_history_creates', 'row_id'), coalesce(max(row_id), 1))
from update_history_creates;


-- And the same for the exercise table
-- Step 1: create a copy of update_history_exercises with the new columns

create table update_history_exercises_v2 (
    history_id                  int             not null,
    row_id                      bigint generated by default as identity,
    ingested_at                 timestamptz     not null default now(),
    event_id                    text            not null,
    update_row_id               bigint          not null,
    child_event_ids             text[]          not null,
    choice                      text            not null,
    template_id_package_id      text            not null,
    template_id_module_name     text            not null,
    template_id_entity_name     text            not null,
    contract_id                 text            not null,
    consuming                   boolean         not null,
    argument                    jsonb           not null,
    result                      jsonb           not null,
    package_name                text            not null,
    interface_id_package_id     text,
    interface_id_module_name    text,
    interface_id_entity_name    text,
    acting_parties              text[]          not null,
    record_time                 bigint          not null,
    update_id                   text            not null,
    domain_id                   text            not null,
    migration_id                int             not null,

    constraint update_history_exercises_v2_pkey primary key (row_id)
);

insert into update_history_exercises_v2 (
    history_id,
    row_id,
    ingested_at,
    event_id,
    update_row_id,
    child_event_ids,
    choice,
    template_id_package_id,
    template_id_module_name,
    template_id_entity_name,
    contract_id,
    consuming,
    argument,
    result,
    package_name,
    interface_id_package_id,
    interface_id_module_name,
    interface_id_entity_name,
    acting_parties,
    record_time,
    update_id,
    domain_id,
    migration_id
)
select
    e.history_id,
    e.row_id,
    e.ingested_at,
    e.event_id,
    e.update_row_id,
    e.child_event_ids,
    e.choice,
    e.template_id_package_id,
    e.template_id_module_name,
    e.template_id_entity_name,
    e.contract_id,
    e.consuming,
    e.argument,
    e.result,
    e.package_name,
    e.interface_id_package_id,
    e.interface_id_module_name,
    e.interface_id_entity_name,
    e.acting_parties,
    u.record_time,
    u.update_id,
    u.domain_id,
    u.migration_id
from update_history_exercises e
    join update_history_transactions u on e.update_row_id = u.row_id;


-- Step 2: drop the old table and rename the new one

drop table update_history_exercises;

alter table update_history_exercises_v2
    rename to update_history_exercises;
alter table update_history_exercises
    rename constraint update_history_exercises_v2_pkey to update_history_exercises_pkey;


-- Step 3: add indexes (do this before adding foreign key constraints, because the index will be used in verifying the constraint)

create index updt_hist_exer_hi_mi_rt_co on update_history_exercises(history_id, migration_id, record_time, consuming);

create unique index updt_hist_exer_unique on update_history_exercises (update_row_id, event_id);


-- Step 4: restore foreign key constraints and sequences

alter table update_history_exercises
    add constraint update_history_exercises_history_id_fkey
        foreign key (history_id) references update_history_descriptors (id);

alter table update_history_exercises
    add constraint update_history_exercises_update_row_id_fkey
        foreign key (update_row_id) references update_history_transactions (row_id);

select setval(pg_get_serial_sequence('update_history_exercises', 'row_id'), coalesce(max(row_id), 1))
from update_history_exercises;


-- From V016__append_only_autovacumm.sql:

alter table update_history_exercises set (autovacuum_analyze_scale_factor = 0, autovacuum_analyze_threshold = 20000);
alter table update_history_creates set (autovacuum_analyze_scale_factor = 0,  autovacuum_analyze_threshold = 20000);
