-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- Create a schema for extensions.
-- The Postgres statement `create extension` installs an extension *globally*, and makes it available in the current schema only.
-- It is therefore not safe to run `create extension` with default parameters if multiple apps are using the same database,
-- even if they are configured to use different schemas.
-- To solve this, we create an explicit schema for extensions and require that all CN apps use this schema for extensions.
-- All statements in this section must be idempotent, as they modify global database state and may be executed
-- multiple times by different apps.
-- See for example https://stackoverflow.com/a/43937189

create schema if not exists extensions;

-- make sure everybody can use everything that is already present in the extensions schema
grant usage on schema extensions to public;
grant execute on all functions in schema extensions to public;

-- include future extensions
alter default privileges in schema extensions
   grant execute on functions to public;
alter default privileges in schema extensions
   grant usage on types to public;

-- install extension for the digest function
create extension if not exists "pgcrypto" schema extensions;

-- We allow many stores to ingest into the same tables to enable:
--   - fast rollbacks on app upgrades (the new app can start re-ingesting w/o deleting the data ingested by its previous version)
--   - one app maintaining multiple stores (e.g., one per end-user wallet)
--   - multiple app instances running in the same process and sharing the DB
create table store_descriptors (
    -- The DB internal identifier of the store
    id int generated by default as identity primary key,

    -- A JSON object serving as the specification of the concrete ingestion pipeline used by the store.
    -- Used to by the apps to lookup the DB internal 'id' for their specific ingestion pipeline.
    descriptor jsonb not null unique
);

create table store_last_ingested_offsets(
    store_id int not null,

    migration_id bigint not null,

    -- the last ingested offset, if any
    last_ingested_offset text,

    primary key (store_id, migration_id),
    foreign key (store_id) references store_descriptors(id)
);

-- Templates for create event tables
------------------------------------

-- A template for a table containing a store's create events extended with custom indices.
create table acs_store_template(
    -- The id of the store that this create event belongs to
    store_id int not null,

    migration_id bigint not null,

    -- A monotonically increasing number for events in a store, which is used to serve paginated queries that in
    -- turn drive streaming reads of create events in applications.
    event_number bigint generated by default as identity primary key,

    -- contract data
    contract_id text not null,
    template_id_package_id text not null,
    template_id_qualified_name text not null,
    create_arguments jsonb not null,
    created_event_blob bytea not null,
    created_at bigint not null,

    -- expiry time of expiring contracts in micros since unix epoch
    -- part of the template as we expect all stores to support expiry
    -- TODO(#3822): wire this up with the generic expiry interface on contracts
    contract_expires_at bigint,

    -- A monotonically increasing number for events in a store, which is used to serve paginated queries that in
    -- turn drive streaming reads of reassignment events in applications.
    -- Note: this column is not related to `event_number`. Each time the contract state
    -- is updated, a new `state_number` is assigned to this row.
    state_number bigint generated by default as identity,

    -- The domain this contract is assigned to, as of the latest observed domain reassignment state.
    -- If the latest observed domain reassignment event is an unassign, this is NULL.
    assigned_domain text,

    -- counter of the most recent observed domain reassignment
    -- reassignment counters are monotonically increasing
    reassignment_counter int not null,

    -- Metadata for domain reassignments
    -- Only contains data if the latest observed domain reassignment event is an unassign.
    reassignment_target_domain text,
    reassignment_source_domain text,
    reassignment_submitter text,
    reassignment_unassign_id text
);

create unique index acs_store_template_sid_mid_cid
    on acs_store_template (store_id, migration_id, contract_id);

create index acs_store_template_sid_mid_tid_en
    on acs_store_template (store_id, migration_id, template_id_qualified_name, event_number);

create index acs_store_template_sid_mid_tid_ce
    on acs_store_template (store_id, migration_id, template_id_qualified_name, contract_expires_at)
    where contract_expires_at is not null;

create index acs_store_sid_mid_sn
    on acs_store_template (store_id, migration_id, state_number);

create index acs_store_template_sid_mid_tid_sn
    on acs_store_template (store_id, migration_id, template_id_qualified_name, state_number);


create table incomplete_reassignments(
    -- The id of the store that this row belongs to
    store_id int not null,

    migration_id int not null,

    contract_id text not null,

    source_domain text not null,

    unassign_id text not null,

    -- TRUE: this row represents an incomplete assign
    -- FALSE: this row represents an incomplete unassign
    is_assignment boolean not null,

    primary key (store_id, migration_id, contract_id, unassign_id),
    foreign key (store_id) references store_descriptors(id)
);

create index incomplete_reassignments_sid_mid_uid
    on incomplete_reassignments (store_id, migration_id, unassign_id);

create index incomplete_reassignments_sid_mid_cid
    on incomplete_reassignments (store_id, migration_id, contract_id);

-- A template for a table containing a store's TxLog entries extended with custom indices.
create table txlog_store_template(
    -- The id of the store that this TxLog entry belongs to
    store_id int not null,

    -- The incremental integer id of the migration.
    migration_id int not null,

    -- A monotonically increasing number for entries in a store, which is used to serve paginated queries that in
    -- turn drive streaming reads of TxLog entries in applications.
    entry_number bigint generated by default as identity primary key,

    -- The offset of the transaction that generated this entry
    transaction_offset text not null,

    -- The record time of the transaction that generated this entry
    record_time bigint not null,

    -- The domain on which the transaction that generated this entry was processed
    domain_id text not null,

    -- A short, application-specific string that identifies the type of the entry
    entry_type text not null,

    -- The log entry, serialized as a JSON object.
    -- The format of the serialized entry is determined by the `entry_type` column.
    -- The format may evolve over time, but deserialization must always be backwards compatible, i.e.,
    -- the application must be able to read entries written by any previous application version.
    -- Note that a backwards compatible change in the format may still introduce breaking changes for clients,
    -- in particular if BFT reads from multiple independently upgraded applications are involved.
    entry_data jsonb not null
);

create index txlog_store_template_sid_et
    on txlog_store_template (store_id, entry_type);

create index txlog_store_template_si_mi_di_rc
    on txlog_store_template (store_id, migration_id, domain_id, record_time);

-- Validator/wallet store
------------------

create table validator_acs_store(
    like acs_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors(id),

    -- index columns
    ----------------

    -- party id of the end user associated with this contract
    user_party text,

    -- name of the end user associated with this contract
    user_name text,

    -- party id of the provider associated with this contract
    provider_party text,

    -- party id of the validator associated with this contract
    validator_party text,

    -- target domain for the domain traffic contract
    traffic_domain_id text,

    -- AppConfiguration.version
    app_configuration_version bigint,

    -- AppConfiguration.name
    app_configuration_name text,

    -- AppRelease.version
    app_release_version text,

    -- ApprovedReleaseConfiguration.jsonHash
    json_hash text
);

create index validator_acs_store_sid_mid_tid_up
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, user_party)
    where user_party is not null;

create index validator_acs_store_sid_mid_tid_un
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, user_name)
    where user_name is not null;

create index validator_acs_store_sid_mid_tid_pp
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, provider_party)
    where provider_party is not null;

create index validator_acs_store_sid_mid_tid_vp
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, validator_party)
    where validator_party is not null;

create index validator_acs_store_sid_mid_tid_tdi
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, traffic_domain_id)
    where traffic_domain_id is not null;

create index validator_acs_store_sid_mid_tid_acv
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, app_configuration_version)
    where app_configuration_version is not null;

create index validator_acs_store_sid_mid_tid_arv
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, app_release_version)
    where app_release_version is not null;

create index validator_acs_store_sid_mid_tid_jh
    on validator_acs_store (store_id, migration_id, template_id_qualified_name, json_hash)
    where json_hash is not null;

-- User Wallet Store
--------------------

create table user_wallet_acs_store(
    like acs_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors(id),

    -- index columns
    ----------------
    -- the round of a reward coupon contract
    reward_coupon_round  bigint,

    -- the weight in an SvRewardCoupon
    reward_coupon_weight bigint
);

create index user_wallet_acs_store_sid_mid_tid_rcr
    on user_wallet_acs_store (store_id, migration_id, template_id_qualified_name, reward_coupon_round)
    where reward_coupon_round is not null;

create table user_wallet_txlog_store(
    like txlog_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors (id),

    unique (store_id, migration_id, tx_log_id, event_id),

    -- index columns
    ----------------
    -- which txlog this entry belongs to TODO (#7153): this might be separate tables, so this column would be unnecessary
    tx_log_id text not null,

    -- used for pagination of transaction history
    event_id text,

    -- the tracking_id for transfer offer or buy traffic request tx log entries
    tracking_id text
);

create index user_wallet_txlog_store_sid_tid
    on user_wallet_txlog_store (store_id, tracking_id)
    where tracking_id is not null;

-- Scan store
------------------

create table scan_acs_store
(
    like acs_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors (id),

    -- index columns
    ----------------

    -- the round of the OpenMiningRound/ClosedMiningRound/IssuingMiningRound/SummarizingMiningRound contract
    round                       bigint,

    -- the party id of the validator
    validator                   text,

    -- amount of amulets
    amount                      numeric,

    -- the receiver of an ImportCrate contract
    import_crate_receiver       text,

    -- the provider partyid of a FeaturedAppRight contract
    featured_app_right_provider text,

    -- the name of the ans entry
    ans_entry_name              text,

    -- party-id of the directory user that owns a ans entry contract
    ans_entry_owner             text,

    -- the member id in a MemberTraffic
    member_traffic_member         text,

    -- the traffic purchased in a MemberTraffic
    total_traffic_purchased       bigint,

    -- the rounds collected in a ValidatorLicense's faucetState. Used to sort for top validators by faucets collected.
    validator_license_rounds_collected bigint,

    -- generic by sv party field for templates with one instance per svParty
    -- mostly used to keep track of DSO state
    --
    -- Note: no index as the template_id_qualified_name index should be sufficient.
    sv_party text
);

-- lookup validator traffic
create index scan_acs_store_sid_mid_tid_val
    on scan_acs_store (store_id, migration_id, template_id_qualified_name, validator, event_number)
    where validator is not null;

-- list ImportCrates
create index scan_acs_store_sid_mid_tid_icrn
    on scan_acs_store (store_id, migration_id, template_id_qualified_name, import_crate_receiver, event_number)
    where import_crate_receiver is not null;

-- lookup FeaturedAppRight
create index scan_acs_store_sid_mid_tid_farp
    on scan_acs_store (store_id, migration_id, template_id_qualified_name, featured_app_right_provider)
    where featured_app_right_provider is not null;

-- retrieve ans entries by name
create index scan_acs_store_sid_mid_den_tpo
    on scan_acs_store (store_id, migration_id, ans_entry_name text_pattern_ops)
    where ans_entry_name is not null;

-- retrieve the ans entries owned by a particular party paged by name
create index scan_acs_store_sid_mid_deo_den
    on scan_acs_store (store_id, migration_id, ans_entry_owner, ans_entry_name)
    where ans_entry_owner is not null and ans_entry_name is not null;

-- retrieve total traffic purchased per member
create index scan_acs_store_sid_mid_tid_mtm
    on scan_acs_store (store_id, migration_id, template_id_qualified_name, member_traffic_member)
    where member_traffic_member is not null;

-- top validator licenses by rounds collected
create index scan_acs_store_sid_mid_tid_vlrc
    on scan_acs_store (store_id, migration_id, template_id_qualified_name, validator_license_rounds_collected)
    where validator_license_rounds_collected is not null;

create table scan_txlog_store
(
    like txlog_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors (id),

    -- index columns
    ----------------

    -- event id used for pagination
    event_id                                                 text not null,

    -- the round of a OpenMiningRound/ClosedMiningRound/Reward/ExtraTrafficPurchase IndexRecord
    round                                                    bigint,

    -- The value of the reward coupon (in CC) in AppRewardIndexRecord/ValidatorRewardIndexRecord
    reward_amount                                            numeric,

    -- the party of a AppRewardIndexRecord/ValidatorRewardIndexRecord
    rewarded_party                                           text,

    -- change_to_initial_amount_as_of_round_zero in BalanceChangeIndexRecord
    balance_change_change_to_initial_amount_as_of_round_zero numeric,

    -- change_to_holding_fees_rate in BalanceChangeIndexRecord
    balance_change_change_to_holding_fees_rate               numeric,

    -- the validator of a ExtraTrafficPurchaseIndexRecord
    extra_traffic_validator                                  text,

    -- traffic_purchased in ExtraTrafficPurchaseIndexRecord
    extra_traffic_purchase_traffic_purchased                 bigint,

    -- cc_spent in ExtraTrafficPurchaseIndexRecord
    extra_traffic_purchase_cc_spent                          numeric,

    -- provider of RecentActivityIndexRecord
    recent_activity_provider                                 text,

    -- sender of RecentActivityIndexRecord
    recent_activity_sender                                   text,

    -- receiver of RecentActivityIndexRecord
    recent_activity_receiver                                 text,

    -- amount of RecentActivityIndexRecord
    recent_activity_amount                                   numeric,

    -- amulet_price of RecentActivityIndexRecord
    recent_activity_amulet_price                               numeric,

    -- effective_at of closed mining round
    closed_round_effective_at                                bigint
);

create index scan_txlog_store_sid_irt_r_en
    on scan_txlog_store (store_id, entry_type, round, entry_number desc)
    where round is not null;

create table round_totals
(
    -- the store id of the scan store for which the totals are calculated
    store_id int not null,

    -- the closed round
    closed_round bigint not null,

    -- the effective_at of the closed round
    closed_round_effective_at bigint not null,

    -- the total app rewards in the round
    app_rewards numeric,

    -- the total validator rewards in the round
    validator_rewards numeric,

    -- the sum of change_to_initial_amount_as_of_round_zero in the round
    change_to_initial_amount_as_of_round_zero numeric,

    -- the sum of the changes to change_to_holding_fees_rate in the round
    change_to_holding_fees_rate numeric,

    -- the cumulative app rewards from round zero up to and including the round
    cumulative_app_rewards numeric,

    -- the cumulative validator rewards from round zero up to and including the round
    cumulative_validator_rewards numeric,

    -- the cumulative change_to_initial_amount_as_of_round_zero from round zero up to and including the round
    cumulative_change_to_initial_amount_as_of_round_zero numeric,

    -- the cumulative change_to_holding_fees_rate from round zero up to and including the round
    cumulative_change_to_holding_fees_rate numeric,

    -- the total amulet balance as of end of round
    total_amulet_balance numeric,

    primary key (store_id, closed_round)
);

create table round_party_totals
(
    -- the store id of the scan store for which the totals are calculated
    store_id int not null,

    -- the closed round
    closed_round bigint not null,

    -- the party for which the totals are calculated (validators, app operators)
    party text not null,

    -- the total app rewards for the party in the round
    app_rewards numeric,

    -- the total validator rewards for the party in the round
    validator_rewards numeric,

    -- the traffic purchased for the party in the round
    traffic_purchased bigint,

    -- the traffic purchased cc spent for the party in the round
    traffic_purchased_cc_spent numeric,

    -- the traffic purchased number of purchases for the party in the round
    traffic_num_purchases bigint,

    -- the cumulative app rewards for the party from round zero up to and including the round
    cumulative_app_rewards numeric,

    -- the cumulative validator rewards for the party from round zero up to and including the round
    cumulative_validator_rewards numeric,

    -- the cumulative change_to_initial_amount_as_of_round_zero for the party from round zero up to and including the round
    cumulative_change_to_initial_amount_as_of_round_zero numeric,

    -- the cumulative change_to_holding_fees_rate for the party from round zero up to and including the round
    cumulative_change_to_holding_fees_rate numeric,

    -- the cumulative traffic purchased for the party from round zero up to and including the round
    cumulative_traffic_purchased bigint,

    -- the cumulative traffic purchase cc spent for the party from round zero up to and including the round
    cumulative_traffic_purchased_cc_spent numeric,

    -- the cumulative traffic number of purchases for the party from round zero up to and including the round
    cumulative_traffic_num_purchases numeric,

    primary key (store_id, closed_round, party)
);

-- SV store
------------------

create table sv_acs_store
(
    like acs_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors (id),

    -- index columns
    ----------------

    -- candidate_secret in ValidatorOnboarding or secret in UsedSecret
    onboarding_secret text,

    -- candidate_name in ApprovedSvIdentity
    sv_candidate_name text
);

-- lookup validator onboarding or used secret by secret
create index sv_acs_store_sid_mid_tid_vocs
    on sv_acs_store (store_id, migration_id, template_id_qualified_name, onboarding_secret)
    where onboarding_secret is not null;

-- lookup approved sv identity by candidate name
create index sv_acs_store_sid_mid_tid_asicn
    on sv_acs_store (store_id, migration_id, template_id_qualified_name, sv_candidate_name)
    where sv_candidate_name is not null;


-- DSO store
------------------

create table dso_acs_store
(
    like acs_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors (id),

    -- index columns
    ----------------

    -- In Amulet/LockedAmulet contracts, round_of_expiry = (created_at_round + (initial_amount / rate_per_round))
    -- as defined in CNNodeUtil.amuletExpiresAt
    amulet_round_of_expiry          bigint,

    -- the round in which an AppReward or ValidatorReward was rewarded
    reward_round                  bigint,

    -- the app provider in an AppRewardCoupon OR the user in a ValidatorRewardCoupon
    reward_party                  text,

    -- the amount rewarded in an AppRewardCoupon/ValidatorRewardCoupon
    reward_amount                 numeric,

    -- the weight in an SvRewardCoupon
    reward_weight                 bigint,

    -- whether an AppRewardCoupon is featured
    app_reward_is_featured        boolean,

    -- the round in an Open/Close MiningRound contract
    mining_round                  bigint,

    -- The ActionRequiringConfirmation in contracts Confirmation and VoteRequest
    -- we store as json because we don't expect to have that many contracts.
    -- Ideally we would store a hash, but that fails with a HashingError.ForbiddenContractId
    action_requiring_confirmation jsonb,

    -- the confirmer party in a Confirmation contract
    confirmer                     text,

    -- the token in an SvOnboardingRequest
    sv_onboarding_token           text,

    -- The party and name of the candidate respectively, in an SvOnboardingRequest or SvOnboardingConfirmed
    sv_candidate_party            text,
    sv_candidate_name             text,

    -- the validator party in a ValidatorLicense or MemberTraffic
    validator                     text,

    -- the traffic purchased in a MemberTraffic
    total_traffic_purchased       bigint,

    -- the SV in a AmuletPriceVote contract, or the voter in a Vote contract
    voter                         text,

    -- the trackingCid in a VoteRequest contract
    vote_request_tracking_cid     text,

    -- the requester in an ElectionRequest contract
    requester                     text,

    -- the requester in a VoteRequest
    requester_name                text,

    -- the epoch in an ElectionRequest
    election_request_epoch        bigint,

    -- the receiver in an ImportCrate
    import_crate_receiver         text,

    -- the member id in a MemberTraffic
    member_traffic_member         text,

    -- The entry name in AnsEntry and AnsEntryContext
    ans_entry_name                text,

    -- the ansEntryContextCid of a Confirmation contract:
    -- - if the action is of type ARC_AnsEntryContext
    -- - if the above's ansEntryContextAction is of either type ANSRARC_CollectInitialEntryPayment or ANSRARC_RejectEntryInitialPayment
    action_ans_entry_context_cid  text,

    -- the paymentCid of the ansEntryContextAction from Confirmation contract:
    -- - if the action is of type ARC_AnsEntryContext
    -- - if the above's ansEntryContextAction is of either type ANSRARC_CollectInitialEntryPayment or ANSRARC_RejectEntryInitialPayment
    action_ans_entry_context_payment_id  text,

    -- the ansEntryContextAction type of a Confirmation contract
    action_ans_entry_context_arc_type    text,

    -- the contract-id of a subscription's context contract
    -- used for a DB-level join of subscriptions and their context contracts
    subscription_reference_contract_id text,

    -- subscriptions: when the next payment is due
    subscription_next_payment_due_at bigint,

    -- the provider partyid of a FeaturedAppRight contract
    featured_app_right_provider   text,

    -- TODO(#10711): use the index columns below for all templates where they make sense

    -- generic by sv party field for templates with one instance per svParty
    -- templates: SvStatusReport
    --
    -- Note: no index as the template_id_qualified_name index should be sufficient.
    sv_party text,

    -- generic by-sv-name field for templates with one instance per svName
    -- templates: SvRewardState
    --
    -- Note: no index as the template_id_qualified_name index should be sufficient.
    sv_name text
);

-- ordered mining rounds
create index dso_acs_store_sid_tid_mr
    on dso_acs_store (store_id, migration_id,  template_id_qualified_name, mining_round)
    where mining_round is not null;

-- ordered trackingCid
create index dso_acs_store_sid_tid_tcid
    on dso_acs_store (store_id, migration_id,  template_id_qualified_name, vote_request_tracking_cid)
    where vote_request_tracking_cid is not null;

-- list expired amulets
create index dso_acs_store_sid_tid_croe
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, amulet_round_of_expiry)
    where amulet_round_of_expiry is not null;

-- list confirmations
create index dso_acs_store_sid_tid_ah_c
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, action_requiring_confirmation, confirmer)
    where action_requiring_confirmation is not null;

-- list, count and sum reward coupons (AppRewardCoupon, ValidatorRewardCoupon, ValidatorFaucetCoupon)
create index dso_acs_store_coupons
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, reward_round, reward_party, app_reward_is_featured)
    where reward_round is not null and reward_party is not null;

-- lookup sv onboarding by token
create index dso_acs_store_sid_tid_sot
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, sv_onboarding_token)
    where sv_onboarding_token is not null;

-- lookup sv onboarding by party and/or name
create index dso_acs_store_sid_mid_tid_scp_scn
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, sv_candidate_party, sv_candidate_name)
    where sv_candidate_party is not null;

-- lookup sv onboarding by name
create index dso_acs_store_sid_mid_tid_scn
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, sv_candidate_name)
    where sv_candidate_name is not null;

-- list by validator
create index dso_acs_store_sid_mid_tid_v_tp
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, validator, total_traffic_purchased)
    where validator is not null;

-- list vote requests
create index dso_acs_store_sid_mid_tid_ah_r
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, action_requiring_confirmation, requester)
    where action_requiring_confirmation is not null;

-- list election requests
create index dso_acs_store_sid_mid_tid_ere_r
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, election_request_epoch, requester)
    where election_request_epoch is not null and requester is not null;

-- list import crates
create index dso_acs_store_sid_mid_tid_icr
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, import_crate_receiver)
    where import_crate_receiver is not null;

create index dso_acs_store_sid_mid_tid_mtm
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, member_traffic_member)
    where member_traffic_member is not null;

create index dso_acs_store_sid_mid_tid_cen
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, ans_entry_name)
    where ans_entry_name is not null;

create index dso_acs_store_sid_mid_tid_acecc
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, action_ans_entry_context_cid)
    where action_ans_entry_context_cid is not null;

create index dso_acs_store_sid_mid_tid_sccid
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, subscription_reference_contract_id)
    where subscription_reference_contract_id is not null;

create index dso_acs_store_sid_mid_tid_snpd
    on dso_acs_store (store_id, migration_id, template_id_qualified_name, subscription_next_payment_due_at)
    where subscription_next_payment_due_at is not null;

create table dso_txlog_store
(
    like txlog_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors (id),

    -- index columns
    ----------------

    action_name                                              text,

    executed                                                 boolean,

    requester_name                                           text,

    effective_at                                             text,

    voted_at                                                 text
);

create index dso_txlog_store_sid_et_an_e
    on dso_txlog_store (store_id, entry_type, action_name, executed desc)
    where dso_txlog_store.action_name is not null and executed is not null;

-- Splitwell store
------------------

create table splitwell_acs_store(
    like acs_store_template including all,

    -- reestablish foreign key constraint as that one is not copied by the LIKE statement above
    foreign key (store_id) references store_descriptors(id),

    -- index columns
    ----------------

    -- the party of the user of a SplitwellInstall or SplitwellInstallRequest contract
    install_user                                             text,

    -- the ID of the splitwell group
    group_id                                                 text,

    -- the party of the owner of a splitwell group
    group_owner                                              text,

    -- contract ID of the payment request
    payment_request_contract_id                              text
);

-------------------------------------------------------------------------------
-- Update history tables
-------------------------------------------------------------------------------

-- The update history is a serialized update stream of the ledger.
-- The update stream is complete, i.e., it contains all updates from the beginning of
-- the network until the last ingested offset, without any gaps.

-- We allow many update histories to ingest into the same tables to enable:
--   - one app maintaining multiple update streams (e.g., one per end-user wallet)
--   - multiple app instances running in the same process and sharing the DB
create table update_history_descriptors (
    -- The DB internal identifier of the history
    id                          int generated by default as identity primary key,

    -- The party used in the filter of the update stream (CN apps always subscribe as a single party)
    -- The history will only contain updates that are visible to that party.
    party                       text not null,

    -- The participant id from the canton admin API.
    -- In case the above party is multi-hosted on different participants,
    -- each participant should have its own history.
    participant_id              text not null,

    unique (party, participant_id)
);

create table update_history_last_ingested_offsets(
    history_id              int not null,

    migration_id            bigint not null,

    -- the last ingested offset, if any
    last_ingested_offset    text,

    primary key (history_id, migration_id),
    foreign key (history_id) references update_history_descriptors(id)
);

-- Update stream: transactions
create table update_history_transactions
(
    -- The id of the history that this create event belongs to
    history_id                  int not null references update_history_descriptors (id),

    -- A generated identifier for the update.
    -- Not useful for anything other than joins with the exercises/creates tables.
    row_id                      bigint generated by default as identity primary key,

    -- The time when this row was inserted, used for debugging and monitoring
    ingested_at                 timestamptz not null default now(),

    -- Primary identifier of the update.
    -- The tuple (history_id, migration_id, update_id) should be unique, but we do not actually create a unique
    -- constraint for this, as the update_id is a large random string, which would lead to expensive index updates.
    update_id                   text not null,

    -- Information useful for ordering or partitioning updates
    record_time                 bigint not null, -- When was this update sequenced
    participant_offset          text not null,   -- TODO(#10605): local to the participant, drop this once we have the record time
    domain_id                   text not null,
    migration_id                int not null,    -- The thing that increments with each hard domain migration

    -- Update payload
    effective_at                bigint not null,
    root_event_ids              text[] not null
);

-- Update history is mainly traversed by (migration_id, domain_id, record_time)
create index updt_hist_tran_hi_mi_di_rt on update_history_transactions (history_id, migration_id, domain_id, record_time);

create table update_history_exercises
(
    -- The id of the history that this exercise event belongs to
    history_id                  int not null references update_history_descriptors (id),

    -- A generated identifier for the event.
    -- Not useful for anything other than an opaque primary key for this table.
    row_id                      bigint generated by default as identity primary key,

    -- The time when this row was inserted, used for debugging and monitoring
    ingested_at                 timestamptz not null default now(),

    -- Primary identifier of the event.
    -- The tuple (history_id, migration_id, domain_id, event_id) should be unique, but we do not actually create a unique
    -- constraint for this, as the event_id is a large random string, which would lead to expensive index updates.
    event_id                    text not null,

    -- Corresponding update
    update_row_id               bigint not null references update_history_transactions (row_id),

    -- Event payload
    child_event_ids             text[] not null,
    choice                      text not null,
    template_id_package_id      text not null,
    template_id_module_name     text not null,
    template_id_entity_name     text not null,
    contract_id                 text not null,
    consuming                   boolean not null,
    argument                    jsonb not null,
    result                      jsonb not null

    -- not storing:
    -- witnesses (the stored witnesses is the intersection of actual witnesses according to the daml model
    --            with the subscribing parties, and we're always subscribing as a single party)
);
create index updt_hist_exer_uri on update_history_exercises (update_row_id);

create table update_history_creates(
    -- The id of the history that this create event belongs to
    history_id                  int not null references update_history_descriptors (id),

    -- A generated identifier for the event.
    -- Not useful for anything other than an opaque primary key for this table.
    row_id                      bigint generated by default as identity primary key,

    -- The time when this row was inserted, used for debugging and monitoring
    ingested_at                 timestamptz not null default now(),

    -- Primary identifier of the event.
    -- The tuple (history_id, migration_id, domain_id, event_id) should be unique, but we do not actually create a unique
    -- constraint for this, as the event_id is a large random string, which would lead to expensive index updates.
    event_id                    text not null,

    -- Corresponding update
    update_row_id               bigint not null references update_history_transactions (row_id),

    -- Event payload
    contract_id                 text not null,
    created_at                  bigint not null,
    template_id_package_id      text not null,
    template_id_module_name     text not null,
    template_id_entity_name     text not null,
    package_name                text not null,
    create_arguments            jsonb not null

    -- not storing:
    -- contract key hash (CN doesn't use contract keys and they will be removed in 3.0)
    -- create event blob (we won't use the transaction history data for explicit disclosure)
    -- workflow id (CN doesn't use that)
    -- command id (only visible to submitter, and only useful for command deduplication)
    -- witnesses (the stored witnesses is the intersection of actual witnesses according to the daml model
    --            with the subscribing parties, and we're always subscribing as a single party)
);
create index updt_hist_crea_uri on update_history_creates (update_row_id);

-- Update stream: assignments
create table update_history_assignments
(
    -- The id of the history that this create event belongs to
    history_id                  int not null references update_history_descriptors (id),

    -- A generated identifier for the update.
    -- Not useful for anything other than an opaque primary key for this table.
    row_id                      bigint generated by default as identity primary key,

    -- The time when this row was inserted, used for debugging and monitoring
    ingested_at                 timestamptz not null default now(),

    -- Primary identifier of the update.
    -- The tuple (history_id, migration_id, update_id) should be unique, but we do not actually create a unique
    -- constraint for this, as the update_id is a large random string, which would lead to expensive index updates.
    update_id                   text not null,

    -- Information useful for ordering or partitioning updates
    record_time                 bigint not null, -- When was this update sequenced
    participant_offset          text not null,   -- TODO(#10605): local to the participant, drop this once we have the record time
    domain_id                   text not null,   -- The target domain
    migration_id                int not null,    -- The thing that increments with each hard domain migration

    -- Update payload
    reassignment_counter        int not null,
    source_domain               text not null,
    reassignment_id             text not null,
    submitter                   text not null,

    -- Contract payload (see comments in update_history_creates)
    contract_id                 text not null,
    event_id                    text not null,
    created_at                  bigint not null,
    template_id_package_id      text not null,
    template_id_module_name     text not null,
    template_id_entity_name     text not null,
    package_name                text not null,
    create_arguments            jsonb not null
);

-- Update history is mainly traversed by (migration_id, domain_id, record_time)
create index updt_hist_assi_hi_mi_di_rt on update_history_assignments (history_id, migration_id, domain_id, record_time);

-- Update stream: unassignments
create table update_history_unassignments
(
    -- The id of the history that this create event belongs to
    history_id                  int not null references update_history_descriptors (id),

    -- A generated identifier for the update.
    -- Not useful for anything other than an opaque primary key for this table.
    row_id                      bigint generated by default as identity primary key,

    -- The time when this row was inserted, used for debugging and monitoring
    ingested_at                 timestamptz not null default now(),

    -- Primary identifier of the update.
    -- The tuple (history_id, migration_id, update_id) should be unique, but we do not actually create a unique
    -- constraint for this, as the update_id is a large random string, which would lead to expensive index updates.
    update_id                   text not null,

    -- Information useful for ordering or partitioning updates
    record_time                 bigint not null, -- When was this update sequenced
    participant_offset          text not null,   -- TODO(#10605): local to the participant, drop this once we have the record time
    domain_id                   text not null,   -- The source domain
    migration_id                int not null,    -- The thing that increments with each hard domain migration

    -- Update payload
    reassignment_counter        int not null,
    target_domain               text not null,
    reassignment_id             text not null,
    submitter                   text not null,
    contract_id                 text not null
);

-- Update history is mainly traversed by (migration_id, domain_id, record_time)
create index updt_hist_unas_hi_mi_di_rt on update_history_unassignments (history_id, migration_id, domain_id, record_time);


-- The following indexes should not be necessary: the ingestion sink keeps track of the last ingested offset and
-- should never process the same update stream element twice.
-- The indexes are here to catch bugs, like two ingestion services ingesting data for the same party from the same participant.
create unique index updt_hist_tran_unique on update_history_transactions (history_id, migration_id, participant_offset);
create unique index updt_hist_exer_unique on update_history_exercises (update_row_id, event_id);
create unique index updt_hist_crea_unique on update_history_creates (update_row_id, event_id);
create unique index updt_hist_assi_unique on update_history_assignments (history_id, migration_id, participant_offset);
create unique index updt_hist_unas_unique on update_history_unassignments (history_id, migration_id, participant_offset);
