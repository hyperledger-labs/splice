-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestRewardAccountingV2 where


import DA.Action (void)
import DA.Assert
import DA.Foldable (forA_)
import DA.List
import DA.Set as Set
import DA.Time

import Daml.Script

import Splice.Amulet
import Splice.Amulet.RewardAccountingV2
import Splice.Amulet.CryptoHash qualified as CryptoHash
import Splice.AmuletConfig
import Splice.AmuletRules
import Splice.ExternalPartyAmuletRules
import Splice.ExternalPartyConfigState
import Splice.DsoRules
import Splice.Types

import Splice.Scripts.Util
import Splice.Scripts.DsoTestUtils

import Splice.Testing.Registries.AmuletRegistry.Parameters (defaultAmuletConfig)


-- | Tests that reward accounting works.
test_reward_accounting_v2 : Script ()
test_reward_accounting_v2 = do
    -- enable traffic based app rewards, which are the first use-case for reward accounting v2
  let amuletConfig = defaultAmuletConfig with
        rewardCalculationVersion = Some RCV_V2
  (app, _, (sv1, _, _, _)) <- initDevNetWithAmuletConfig amuletConfig

  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  charlie <- allocateParty "Charlie"
  dora <- allocateParty "Dora"

  setTime demoTime

  -- move the first round through issuance, which will also trigger the reward calculation for this round
  runNextIssuanceD app 1.0


  -- setup demo data
  let mintingAllowances1 = sortOn (.beneficiary)
        [ MintingAllowance alice 1000.0
        , MintingAllowance bob 2000.0
        ]
  let mintingAllowances2 = sortOn (.beneficiary)
        [ MintingAllowance charlie 30.0
        , MintingAllowance dora 5.1
        ]
  let b1 = BatchOfMintingAllowances mintingAllowances1
  let b2 = BatchOfMintingAllowances mintingAllowances2
  let rootBatch = BatchOfBatches [CryptoHash.hash b1, CryptoHash.hash b2]
  let rootBatchHash = CryptoHash.hash rootBatch
  let batchesWithHiding = [(b1, []), (b2, [dora]), (rootBatch, [])]

  -- get the
  [(calculateRewardsCid, _)] <- query @CalculateRewardsV2 app.dso

  -- setup reimbursement workflow state
  confirmAndExecutionAction app ARC_AmuletRules with
    amuletRulesAction = CRARC_StartProcessingRewardsV2
      AmuletRules_StartProcessingRewardsV2 with
        calculateRewardsCid
        batchHash = rootBatchHash

  [(dsoRulesCid, _)] <- query @DsoRules app.dso

  let processBatches = do
        states <- query @ProcessRewardsV2 app.dso
        forA_ states $ \(processRewardsCid, processRewards) -> do
          let Some (b, badVettingState) = find (\(b, _) -> CryptoHash.hash b == processRewards.batchHash) batchesWithHiding
          void $ submitMulti [sv1] [app.dso] $ exerciseCmd dsoRulesCid DsoRules_ProcessRewardsV2_ProcessBatch with
            sv = sv1
            processRewardsCid
            choiceArg = ProcessRewardsV2_ProcessBatch with
              batch = b
              beneficiariesWithWrongVettingState = Set.fromList badVettingState

  processBatches -- expand root hash into batch hashes
  processBatches -- expand follow-up batches into coupons

  let expectedCoupons = do
        MintingAllowance{..} <- mintingAllowances1 ++ mintingAllowances2
        pure RewardCouponV2 with
          dso = app.dso
          beneficiary
          amount
          round = Round 0
          expiresAt = addRelTime demoTime (days 2)
          hidden = beneficiary == dora

  actualCoupons0 <- query @RewardCouponV2 app.dso
  let actualCoupons = sortOn (.beneficiary) $ fmap snd actualCoupons0
  actualCoupons === expectedCoupons

  -- TODO: publish Dora's coupon

  -- mint alice's coupon in a split fashion
  -- FIXME: create and use utilities for these queries
  [(externalPartyRulesCid, _)] <- query @ExternalPartyAmuletRules app.dso
  (externalPartyConfigCid, _)::_ <- query @ExternalPartyConfigState app.dso
  [(aliceCouponCid, _)] <- query @RewardCouponV2 alice
  void $ submitMulti [alice, bob, charlie] [app.dso] $
    exerciseCmd externalPartyRulesCid ExternalPartyAmuletRules_MintWithBeneficiaries with
      beneficiary = alice
      rewardCouponCids = [aliceCouponCid]
      mintingBeneficiaries =
        [ MintingBeneficiary with
            minter = bob
            amount = 100.0
        , MintingBeneficiary with
            minter = charlie
            amount = 200.0
        ]
      expectedDso = app.dso
      externalPartyConfigStateCid = externalPartyConfigCid

  amulets <- query @Splice.Amulet.Amulet app.dso
  let actualAmounts = sort [ (a.owner, a.amount.initialAmount) | (_, a) <- amulets ]
  let expectedAmounts = sort [ (alice, 700.0), (bob, 100.0), (charlie, 200.0) ]
  actualAmounts === expectedAmounts

  pure ()

