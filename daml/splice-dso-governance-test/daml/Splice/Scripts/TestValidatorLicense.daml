-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestValidatorLicense where

import DA.Assert
import DA.Action (unless)
import DA.List
import Daml.Script
import DA.Time

import Splice.ValidatorLicense
import Splice.DsoRules
import Splice.Scripts.DsoTestUtils
import Splice.Scripts.Util
import Splice.Types
import Splice.Round


testGrantValidatorLicense : Script ()
testGrantValidatorLicense = do
  (app, dso, (_, sv2, _, _)) <- initMainNet

  -- a new validator prepares his participant
  v1 <- allocateParty "v1"

  now <- getTime

  -- sv2 grants a validator license to v1
  result <- svSubmits app sv2 $ \cid -> exerciseCmd cid $
    DsoRules_GrantValidatorLicense with
      sponsor = sv2
      validator = v1

  -- v1 received a validator license
  [(validatorLicenseCid, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  result.validatorLicense === validatorLicenseCid

  -- v1 can report activity
  passTime (hours 1)
  activityTime <- getTime

  submitMulti [v1] [dso] $ exerciseCmd validatorLicenseCid ValidatorLicense_ReportActive

  [(_, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some activityTime
    weight = None
    kind = Some NonOperatorLicense

  pure ()

-- Ensure that duplicated ValidatorLicence contracts are merged
test_MergeValidatorLicense : Script ()
test_MergeValidatorLicense = do
  (_, dso, (sv1, sv2, _, _)) <- initDevNet

  -- a new validator prepares his participant
  v1 <- allocateParty "v1"
  now <- getTime

  validatorLicense1Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None

  validatorLicense2Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None

  -- there are two validator licenses for v1
  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 2

  -- the license with the highest lastReceivedFor is kept
  [(rulesCid, _)] <- query @DsoRules dso
  DsoRules_MergeValidatorLicenseResult validatorLicenseCid3 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicense1Cid, validatorLicense2Cid] (Some sv1))
  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 1
  (head validatorLicenses)._2.faucetState === Some FaucetState with
    firstReceivedFor = Round 0
    lastReceivedFor = Round 2
    numCouponsMissed = 0

  -- we can't merge a single contract
  submitMultiMustFail [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseCid3] (Some sv1))

  -- we can't merge contracts for different validator names
  [(validatorLicenseSv2Cid, _)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == sv2)
  submitMultiMustFail [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseCid3, validatorLicenseSv2Cid] (Some sv1))

  -- Test weight merging: min weight should be used
  v2 <- allocateParty "v2"
  validatorLicenseW1 <- submit dso $ createCmd ValidatorLicense with
    validator = v2
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some OperatorLicense

  validatorLicenseW2 <- submit dso $ createCmd ValidatorLicense with
    validator = v2
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 3
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = Some 2.0
    kind = Some OperatorLicense

  validatorLicenseW3 <- submit dso $ createCmd ValidatorLicense with
    validator = v2
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = Some 1.5
    kind = Some OperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedWeightLicense <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseW1, validatorLicenseW2, validatorLicenseW3] (Some sv1))
  [(_, mergedLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v2)
  -- The merged license should have the minimum weight (0.5) and the highest lastReceivedFor (Round 3)
  mergedLicense.weight === Some 1.5
  mergedLicense.faucetState === Some FaucetState with
    firstReceivedFor = Round 0
    lastReceivedFor = Round 3
    numCouponsMissed = 0

  -- Test kind merging: Some OperatorLicense if any license has None or Some OperatorLicense
  v3 <- allocateParty "v3"

  -- Test case 1: mixing None and Some NonOperatorLicense -> should result in Some OperatorLicense
  validatorLicenseK1 <- submit dso $ createCmd ValidatorLicense with
    validator = v3
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = None  -- None should be treated as OperatorLicense

  validatorLicenseK2 <- submit dso $ createCmd ValidatorLicense with
    validator = v3
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedKind1 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseK1, validatorLicenseK2] (Some sv1))
  [(_, mergedLicense1)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v3)
  -- Should be OperatorLicense because one license had None
  mergedLicense1.kind === Some OperatorLicense

  -- Test case 2: mixing Some OperatorLicense and Some NonOperatorLicense -> should result in Some OperatorLicense
  v4 <- allocateParty "v4"
  validatorLicenseK3 <- submit dso $ createCmd ValidatorLicense with
    validator = v4
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some OperatorLicense

  validatorLicenseK4 <- submit dso $ createCmd ValidatorLicense with
    validator = v4
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedKind2 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseK3, validatorLicenseK4] (Some sv1))
  [(_, mergedLicense2)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v4)
  -- Should be OperatorLicense to prevent downgrading
  mergedLicense2.kind === Some OperatorLicense

  -- Test case 3: all licenses are Some NonOperatorLicense -> should result in Some NonOperatorLicense
  v5 <- allocateParty "v5"
  validatorLicenseK5 <- submit dso $ createCmd ValidatorLicense with
    validator = v5
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  validatorLicenseK6 <- submit dso $ createCmd ValidatorLicense with
    validator = v5
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedKind3 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseK5, validatorLicenseK6] (Some sv1))
  [(_, mergedLicense3)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v5)
  -- Should be NonOperatorLicense since all licenses are NonOperatorLicense
  mergedLicense3.kind === Some NonOperatorLicense

  pure()

-- Test that runNextIssuanceD properly handles ValidatorLicense weights
-- in the optTotalValidatorLivenessActivityRecords calculation
-- Bob has been given a large weight to trigger the use of `cappedRewardsToIssue` (in computeIssuanceTranche)
-- which would result in alice getting lower rewards than the default value of about 2.85
test_ValidatorLivenessWeightInRunNextIssuanceD : Script ()
test_ValidatorLivenessWeightInRunNextIssuanceD = do
    let bobWeight = 15000.0
        aliceExpectedMin = 2.5
        aliceExpectedMax = 2.55
        bobExpectedMin = aliceExpectedMin * bobWeight
        bobExpectedMax = aliceExpectedMax * bobWeight

    (app, dso, (_, _, _, _)) <- initDevNet

    -- Setup alice and bob
    aliceValidator <- setupValidator' app "v_alice"
    alice <- setupUser app "alice" aliceValidator.primaryParty
    bobValidator <- setupValidator' app "v_bob"
    bob <- setupUser app "bob" bobValidator.primaryParty

    [(aliceLicenseCid, aliceLicense)] <- query @ValidatorLicense aliceValidator.primaryParty
    [(bobLicenseCid, bobLicense)] <- query @ValidatorLicense bobValidator.primaryParty

    -- Update bob license to have specified weight
    submit app.dso $ archiveCmd bobLicenseCid
    bobLicenseCid <- submitMulti [bobValidator.primaryParty, app.dso] [] $ createCmd bobLicense with
      weight = Some bobWeight

    aliceBalanceBefore <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceBefore <- getNormalizedBalance bobValidator.primaryParty

    -- Get the current open round
    rounds <- getOpenRoundsSorted app
    let (round0Cid, round0) = head rounds

    -- Both record liveness activity
    passTime (hours 1)
    aliceResult <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd aliceLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid
    let aliceLicenseCid = aliceResult.licenseCid

    bobResult <- submitMulti [bobValidator.primaryParty] [app.dso] $ exerciseCmd bobLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid
    let bobLicenseCid = bobResult.licenseCid

    -- Verify the activity records were created with correct weights
    aliceRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == aliceValidator.primaryParty && r.round == round0.round)
    bobRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == bobValidator.primaryParty && r.round == round0.round)

    length aliceRecords === 1
    length bobRecords === 1

    let [(_, aliceRecord)] = aliceRecords
    let [(_, bobRecord)] = bobRecords

    aliceRecord.weight === None
    bobRecord.weight === Some bobWeight

    runNextIssuanceD app 1.0
    runNextIssuanceD app 1.0

    runAmuletDepositBots app

    aliceBalanceAfter <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceAfter <- getNormalizedBalance bobValidator.primaryParty

    let aliceReward = aliceBalanceAfter - aliceBalanceBefore
    let bobReward = bobBalanceAfter - bobBalanceBefore

    unless (aliceReward >= aliceExpectedMin && aliceReward <= aliceExpectedMax) $
      abort ("Alice should receive reward lower than the default 2.85. Expected within: [" <> show aliceExpectedMin <> ", " <> show aliceExpectedMax <> "], Got: " <> show aliceReward)

    unless (bobReward >= bobExpectedMin && bobReward <= bobExpectedMax) $
      abort ("Bob should receive ~15000 times rewards. Expected within: [" <> show bobExpectedMin <> ", " <> show bobExpectedMax <> "], Got: " <> show bobReward)

    return ()
