-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestValidatorLicense where

import DA.Assert
import DA.Action (unless)
import DA.List (head)
import Daml.Script
import DA.Time

import Splice.ValidatorLicense
import Splice.DsoRules
import Splice.DSO.VoteExecution
import Splice.Scripts.DsoTestUtils
import Splice.Scripts.Util
import Splice.Types


testGrantValidatorLicense : Script ()
testGrantValidatorLicense = do
  (app, dso, (_, sv2, _, _)) <- initMainNet

  -- a new validator prepares his participant
  v1 <- allocateParty "v1"

  now <- getTime

  -- sv2 grants a validator license to v1
  result <- svSubmits app sv2 $ \cid -> exerciseCmd cid $
    DsoRules_GrantValidatorLicense with
      sponsor = sv2
      validator = v1

  -- v1 received a validator license
  [(validatorLicenseCid, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  result.validatorLicense === validatorLicenseCid

  -- v1 can report activity
  passTime (hours 1)
  activityTime <- getTime

  submitMulti [v1] [dso] $ exerciseCmd validatorLicenseCid ValidatorLicense_ReportActive

  [(_, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some activityTime
    weight = None
    kind = Some NonOperatorLicense

  pure ()

testMergeValidatorLicense : Script ()
testMergeValidatorLicense = do
  (_, dso, (sv1, sv2, _, _)) <- initDevNet

  v1 <- allocateParty "v1"
  now <- getTime

  validatorLicense1Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None


  validatorLicense2Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None

  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 2

  -- the license with the highest lastReceivedFor is kept
  [(rulesCid, _)] <- query @DsoRules dso
  DsoRules_MergeValidatorLicenseResult _ <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicense1Cid, validatorLicense2Cid] (Some sv1))
  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 1
  (head validatorLicenses)._2.faucetState === Some FaucetState with
    firstReceivedFor = Round 0
    lastReceivedFor = Round 2
    numCouponsMissed = 0

  pure()

-- Test that runNextIssuanceD properly handles ValidatorLicense weights
-- in the optTotalValidatorLivenessActivityRecords calculation
-- Bob has been given a large weight to trigger the use of `cappedRewardsToIssue` (in computeIssuanceTranche)
-- which would result in alice getting lower rewards than the default value of about 2.85
test_ValidatorLivenessWeightInRunNextIssuanceD : Script ()
test_ValidatorLivenessWeightInRunNextIssuanceD = do
    let bobWeight = 15000.0
        aliceExpectedMin = 2.5
        aliceExpectedMax = 2.55
        bobExpectedMin = aliceExpectedMin * bobWeight
        bobExpectedMax = aliceExpectedMax * bobWeight

    (app, _, (_, _, _, _)) <- initDevNet

    -- Setup alice and bob
    aliceValidator <- setupValidator' app "v_alice"
    _ <- setupUser app "alice" aliceValidator.primaryParty
    bobValidator <- setupValidator' app "v_bob"
    _ <- setupUser app "bob" bobValidator.primaryParty

    [(aliceLicenseCid, _)] <- query @ValidatorLicense aliceValidator.primaryParty
    [(bobLicenseCidInitial, bobLicense)] <- query @ValidatorLicense bobValidator.primaryParty

    -- Update bob license to have specified weight
    submit app.dso $ archiveCmd bobLicenseCidInitial
    bobLicenseCid <- submitMulti [bobValidator.primaryParty, app.dso] [] $ createCmd bobLicense with
      weight = Some bobWeight

    aliceBalanceBefore <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceBefore <- getNormalizedBalance bobValidator.primaryParty

    -- Get the current open round
    rounds <- getOpenRoundsSorted app
    let (round0Cid, round0) = head rounds

    -- Both record liveness activity
    passTime (hours 1)
    _ <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd aliceLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid

    _ <- submitMulti [bobValidator.primaryParty] [app.dso] $ exerciseCmd bobLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid

    -- Verify the activity records were created with correct weights
    aliceRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == aliceValidator.primaryParty && r.round == round0.round)
    bobRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == bobValidator.primaryParty && r.round == round0.round)

    length aliceRecords === 1
    length bobRecords === 1

    let [(_, aliceRecord)] = aliceRecords
    let [(_, bobRecord)] = bobRecords

    aliceRecord.weight === None
    bobRecord.weight === Some bobWeight

    runNextIssuanceD app 1.0
    runNextIssuanceD app 1.0

    runAmuletDepositBots app

    aliceBalanceAfter <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceAfter <- getNormalizedBalance bobValidator.primaryParty

    let aliceReward = aliceBalanceAfter - aliceBalanceBefore
    let bobReward = bobBalanceAfter - bobBalanceBefore

    unless (aliceReward >= aliceExpectedMin && aliceReward <= aliceExpectedMax) $
      abort ("Alice should receive reward lower than the default 2.85. Expected within: [" <> show aliceExpectedMin <> ", " <> show aliceExpectedMax <> "], Got: " <> show aliceReward)

    unless (bobReward >= bobExpectedMin && bobReward <= bobExpectedMax) $
      abort ("Bob should receive ~15000 times rewards. Expected within: [" <> show bobExpectedMin <> ", " <> show bobExpectedMax <> "], Got: " <> show bobReward)

    return ()

-- Test multiple validator license weight changes can be done via single vote
testValidatorLicenseWeightChangeBatch : Script ()
testValidatorLicenseWeightChangeBatch = do
  (app, _, (sv1, sv2, sv3, sv4)) <- initDevNet

  validator1 <- setupValidator app "validator1"
  validator2 <- setupValidator app "validator2"
  validator3 <- setupValidator app "validator3"

  -- Verify all validators have default weight (None)
  [(_, license1)] <- query @ValidatorLicense validator1
  [(_, license2)] <- query @ValidatorLicense validator2
  [(_, license3)] <- query @ValidatorLicense validator3
  license1.weight === None
  license2.weight === None
  license3.weight === None

  -- Change weights for all three validators in a single vote
  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] (ARC_DsoRules (SRARC_ModifyValidatorLicenses
    (ValidatorLicensesModification with
      changes = [VLC_ChangeWeight with validator = validator1; weight = 5.0
               , VLC_ChangeWeight with validator = validator2; weight = 10.0
               , VLC_ChangeWeight with validator = validator3; weight = 0.0])))

  executeAllVoteExecutionInstructions app

  -- Verify all weights are updated correctly
  [(_, license1)] <- query @ValidatorLicense validator1
  [(_, license2)] <- query @ValidatorLicense validator2
  [(_, license3)] <- query @ValidatorLicense validator3
  license1.weight === Some 5.0
  license2.weight === Some 10.0
  license3.weight === Some 0.0

  pure ()

-- Test multiple validator license withdrawals can be done via single vote
testValidatorLicenseWithdrawBatch : Script ()
testValidatorLicenseWithdrawBatch = do
  (app, _, (sv1, sv2, sv3, sv4)) <- initDevNet

  validator1 <- setupValidator app "validator1"
  validator2 <- setupValidator app "validator2"
  validator3 <- setupValidator app "validator3"

  -- Verify all validator licenses exist
  [_] <- query @ValidatorLicense validator1
  [_] <- query @ValidatorLicense validator2
  [_] <- query @ValidatorLicense validator3

  -- Withdraw all three validator licenses in a single vote
  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] (ARC_DsoRules (SRARC_ModifyValidatorLicenses
    (ValidatorLicensesModification with
      changes = [VLC_Withdraw with validator = validator1
               , VLC_Withdraw with validator = validator2
               , VLC_Withdraw with validator = validator3])))

  executeAllVoteExecutionInstructions app

  -- Verify all validator licenses are withdrawn
  [] <- query @ValidatorLicense validator1
  [] <- query @ValidatorLicense validator2
  [] <- query @ValidatorLicense validator3

  pure ()

-- Test that VoteExecutionInstructions can be expired only after they expire
testVoteExecutionInstructionExpire : Script ()
testVoteExecutionInstructionExpire = do
  (app, _, (sv1, sv2, sv3, sv4)) <- initDevNet

  validator1 <- setupValidator app "validator1"
  validator2 <- setupValidator app "validator2"

  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] (ARC_DsoRules (SRARC_ModifyValidatorLicenses
    (ValidatorLicensesModification with
      changes = [VLC_ChangeWeight with validator = validator1; weight = 5.0
               , VLC_ChangeWeight with validator = validator2; weight = 10.0])))

  [(dsoRulesCid, _)] <- query @DsoRules app.dso
  instructions <- query @VoteExecutionInstruction app.dso
  length instructions === 2
  let [(instruction1Cid, _), (instruction2Cid, _)] = instructions

  -- Cannot expire before timeout (default: 1 day)
  submitMultiMustFail [sv1] [app.dso] $
    exerciseCmd dsoRulesCid DsoRules_ExpireVoteInstruction with
      instructionCid = instruction1Cid; sv = sv1

  submitMultiMustFail [sv1] [app.dso] $
    exerciseCmd dsoRulesCid DsoRules_ExpireVoteInstruction with
      instructionCid = instruction2Cid; sv = sv1

  passTime (days 1)

  -- Can expire after timeout
  submitMulti [sv1] [app.dso] $
    exerciseCmd dsoRulesCid DsoRules_ExpireVoteInstruction with
      instructionCid = instruction1Cid; sv = sv1

  submitMulti [sv2] [app.dso] $
    exerciseCmd dsoRulesCid DsoRules_ExpireVoteInstruction with
      instructionCid = instruction2Cid; sv = sv2

  -- Verify all instructions are now expired
  [] <- query @VoteExecutionInstruction app.dso

  pure ()
