-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestValidatorLicense where

import DA.Assert
import DA.Action (unless)
import DA.List (head)
import Daml.Script
import DA.Time

import Splice.ValidatorLicense
import Splice.DsoRules
import Splice.Scripts.DsoTestUtils
import Splice.Scripts.Util
import Splice.Types


testGrantValidatorLicense : Script ()
testGrantValidatorLicense = do
  (app, dso, (_, sv2, _, _)) <- initMainNet

  -- a new validator prepares his participant
  v1 <- allocateParty "v1"

  now <- getTime

  -- sv2 grants a validator license to v1
  result <- svSubmits app sv2 $ \cid -> exerciseCmd cid $
    DsoRules_GrantValidatorLicense with
      sponsor = sv2
      validator = v1

  -- v1 received a validator license
  [(validatorLicenseCid, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  result.validatorLicense === validatorLicenseCid

  -- v1 can report activity
  passTime (hours 1)
  activityTime <- getTime

  submitMulti [v1] [dso] $ exerciseCmd validatorLicenseCid ValidatorLicense_ReportActive

  [(_, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some activityTime
    weight = None
    kind = Some NonOperatorLicense

  pure ()

testMergeValidatorLicense : Script ()
testMergeValidatorLicense = do
  (_, dso, (sv1, sv2, _, _)) <- initDevNet

  v1 <- allocateParty "v1"
  now <- getTime

  validatorLicense1Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None


  validatorLicense2Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None

  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 2

  -- the license with the highest lastReceivedFor is kept
  [(rulesCid, _)] <- query @DsoRules dso
  DsoRules_MergeValidatorLicenseResult _ <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicense1Cid, validatorLicense2Cid] (Some sv1))
  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 1
  (head validatorLicenses)._2.faucetState === Some FaucetState with
    firstReceivedFor = Round 0
    lastReceivedFor = Round 2
    numCouponsMissed = 0

  pure()

-- Test that runNextIssuanceD properly handles ValidatorLicense weights
-- in the optTotalValidatorLivenessActivityRecords calculation
-- Bob has been given a large weight to trigger the use of `cappedRewardsToIssue` (in computeIssuanceTranche)
-- which would result in alice getting lower rewards than the default value of about 2.85
test_ValidatorLivenessWeightInRunNextIssuanceD : Script ()
test_ValidatorLivenessWeightInRunNextIssuanceD = do
    let bobWeight = 15000.0
        aliceExpectedMin = 2.5
        aliceExpectedMax = 2.55
        bobExpectedMin = aliceExpectedMin * bobWeight
        bobExpectedMax = aliceExpectedMax * bobWeight

    (app, _, (_, _, _, _)) <- initDevNet

    -- Setup alice and bob
    aliceValidator <- setupValidator' app "v_alice"
    _ <- setupUser app "alice" aliceValidator.primaryParty
    bobValidator <- setupValidator' app "v_bob"
    _ <- setupUser app "bob" bobValidator.primaryParty

    [(aliceLicenseCid, _)] <- query @ValidatorLicense aliceValidator.primaryParty
    [(bobLicenseCidInitial, bobLicense)] <- query @ValidatorLicense bobValidator.primaryParty

    -- Update bob license to have specified weight
    submit app.dso $ archiveCmd bobLicenseCidInitial
    bobLicenseCid <- submitMulti [bobValidator.primaryParty, app.dso] [] $ createCmd bobLicense with
      weight = Some bobWeight

    aliceBalanceBefore <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceBefore <- getNormalizedBalance bobValidator.primaryParty

    -- Get the current open round
    rounds <- getOpenRoundsSorted app
    let (round0Cid, round0) = head rounds

    -- Both record liveness activity
    passTime (hours 1)
    _ <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd aliceLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid

    _ <- submitMulti [bobValidator.primaryParty] [app.dso] $ exerciseCmd bobLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid

    -- Verify the activity records were created with correct weights
    aliceRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == aliceValidator.primaryParty && r.round == round0.round)
    bobRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == bobValidator.primaryParty && r.round == round0.round)

    length aliceRecords === 1
    length bobRecords === 1

    let [(_, aliceRecord)] = aliceRecords
    let [(_, bobRecord)] = bobRecords

    aliceRecord.weight === None
    bobRecord.weight === Some bobWeight

    runNextIssuanceD app 1.0
    runNextIssuanceD app 1.0

    runAmuletDepositBots app

    aliceBalanceAfter <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceAfter <- getNormalizedBalance bobValidator.primaryParty

    let aliceReward = aliceBalanceAfter - aliceBalanceBefore
    let bobReward = bobBalanceAfter - bobBalanceBefore

    unless (aliceReward >= aliceExpectedMin && aliceReward <= aliceExpectedMax) $
      abort ("Alice should receive reward lower than the default 2.85. Expected within: [" <> show aliceExpectedMin <> ", " <> show aliceExpectedMax <> "], Got: " <> show aliceReward)

    unless (bobReward >= bobExpectedMin && bobReward <= bobExpectedMax) $
      abort ("Bob should receive ~15000 times rewards. Expected within: [" <> show bobExpectedMin <> ", " <> show bobExpectedMax <> "], Got: " <> show bobReward)

    return ()

-- Test multiple validator license weight changes can be done via single vote
testValidatorLicenseWeightChangeBatch : Script ()
testValidatorLicenseWeightChangeBatch = do
  (app, dso, (sv1, sv2, sv3, sv4)) <- initDevNet

  validator1 <- setupValidator app "validator1"
  validator2 <- setupValidator app "validator2"
  validator3 <- setupValidator app "validator3"

  [(dsoRulesCid, _)] <- query @DsoRules dso

  -- Verify all validators have default weight (None)
  [(_, license1)] <- query @ValidatorLicense validator1
  [(_, license2)] <- query @ValidatorLicense validator2
  [(_, license3)] <- query @ValidatorLicense validator3
  license1.weight === None
  license2.weight === None
  license3.weight === None

  -- Change weights for all three validators in a single vote
  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] (ARC_DsoRules (SRARC_ValidatorLicense_ChangeWeight
    (DsoRules_ValidatorLicense_ChangeWeight with
      updates = [ValidatorWeightUpdate validator1 5.0
               , ValidatorWeightUpdate validator2 10.0
               , ValidatorWeightUpdate validator3 0.0])))

  -- Verify three instruction contracts were created
  instructions <- query @ValidatorLicense_Instruction dso
  length instructions === 3

  -- Execute all three instructions
  [(license1Cid, _)] <- query @ValidatorLicense validator1
  [(license2Cid, _)] <- query @ValidatorLicense validator2
  [(license3Cid, _)] <- query @ValidatorLicense validator3

  [(instruction1Cid, instruction1)] <- queryFilter @ValidatorLicense_Instruction dso (\i -> i.validator == validator1)
  [(instruction2Cid, instruction2)] <- queryFilter @ValidatorLicense_Instruction dso (\i -> i.validator == validator2)
  [(instruction3Cid, instruction3)] <- queryFilter @ValidatorLicense_Instruction dso (\i -> i.validator == validator3)

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_Execute_ValidatorLicense_Instruction with
    sv = sv1
    validatorLicenseCid = license1Cid
    instructionCid = instruction1Cid

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_Execute_ValidatorLicense_Instruction with
    sv = sv1
    validatorLicenseCid = license2Cid
    instructionCid = instruction2Cid

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_Execute_ValidatorLicense_Instruction with
    sv = sv1
    validatorLicenseCid = license3Cid
    instructionCid = instruction3Cid

  -- Verify all weights are updated correctly
  [(_, license1)] <- query @ValidatorLicense validator1
  [(_, license2)] <- query @ValidatorLicense validator2
  [(_, license3)] <- query @ValidatorLicense validator3
  license1.weight === Some 5.0
  license2.weight === Some 10.0
  license3.weight === Some 0.0

  pure ()

-- Test multiple validator license withdrawals can be done via single vote
testValidatorLicenseWithdrawBatch : Script ()
testValidatorLicenseWithdrawBatch = do
  (app, dso, (sv1, sv2, sv3, sv4)) <- initDevNet

  validator1 <- setupValidator app "validator1"
  validator2 <- setupValidator app "validator2"
  validator3 <- setupValidator app "validator3"

  [(dsoRulesCid, _)] <- query @DsoRules dso

  -- Verify all validator licenses exist
  [(license1Cid, _)] <- query @ValidatorLicense validator1
  [(license2Cid, _)] <- query @ValidatorLicense validator2
  [(license3Cid, _)] <- query @ValidatorLicense validator3

  -- Withdraw all three validator licenses in a single vote
  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] (ARC_DsoRules (SRARC_ValidatorLicense_Withdraw
    (DsoRules_ValidatorLicense_Withdraw with validators = [validator1, validator2, validator3])))

  -- Verify three instruction contracts were created
  instructions <- query @ValidatorLicense_Instruction dso
  length instructions === 3

  -- Execute all three instructions
  [(instruction1Cid, instruction1)] <- queryFilter @ValidatorLicense_Instruction dso (\i -> i.validator == validator1)
  [(instruction2Cid, instruction2)] <- queryFilter @ValidatorLicense_Instruction dso (\i -> i.validator == validator2)
  [(instruction3Cid, instruction3)] <- queryFilter @ValidatorLicense_Instruction dso (\i -> i.validator == validator3)

  [(license1Cid, _)] <- query @ValidatorLicense validator1
  [(license2Cid, _)] <- query @ValidatorLicense validator2
  [(license3Cid, _)] <- query @ValidatorLicense validator3

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_Execute_ValidatorLicense_Instruction with
    sv = sv1
    validatorLicenseCid = license1Cid
    instructionCid = instruction1Cid

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_Execute_ValidatorLicense_Instruction with
    sv = sv1
    validatorLicenseCid = license2Cid
    instructionCid = instruction2Cid

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_Execute_ValidatorLicense_Instruction with
    sv = sv1
    validatorLicenseCid = license3Cid
    instructionCid = instruction3Cid

  -- Verify all validator licenses are withdrawn
  [] <- query @ValidatorLicense validator1
  [] <- query @ValidatorLicense validator2
  [] <- query @ValidatorLicense validator3

  pure ()
