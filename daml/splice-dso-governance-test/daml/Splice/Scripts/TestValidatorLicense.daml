-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestValidatorLicense where

import DA.Assert
import DA.List
import Daml.Script
import DA.Time

import Splice.ValidatorLicense
import Splice.DsoRules
import Splice.Scripts.DsoTestUtils
import Splice.Types


testGrantValidatorLicense : Script ()
testGrantValidatorLicense = do
  (app, dso, (_, sv2, _, _)) <- initMainNet

  -- a new validator prepares his participant
  v1 <- allocateParty "v1"

  now <- getTime

  -- sv2 grants a validator license to v1
  result <- svSubmits app sv2 $ \cid -> exerciseCmd cid $
    DsoRules_GrantValidatorLicense with
      sponsor = sv2
      validator = v1

  -- v1 received a validator license
  [(validatorLicenseCid, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  result.validatorLicense === validatorLicenseCid

  -- v1 can report activity
  passTime (hours 1)
  activityTime <- getTime

  submitMulti [v1] [dso] $ exerciseCmd validatorLicenseCid ValidatorLicense_ReportActive

  [(_, validatorLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  validatorLicense === ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = None
    metadata = None
    lastActiveAt = Some activityTime
    weight = None
    kind = Some NonOperatorLicense

  pure ()

-- Ensure that duplicated ValidatorLicence contracts are merged
test_MergeValidatorLicense : Script ()
test_MergeValidatorLicense = do
  (_, dso, (sv1, sv2, _, _)) <- initDevNet

  -- a new validator prepares his participant
  v1 <- allocateParty "v1"
  now <- getTime

  validatorLicense1Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None

  validatorLicense2Cid <- submit dso $ createCmd ValidatorLicense with
    validator = v1
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = Some ValidatorLicenseMetadata with
      version = "0.1.0"
      contactPoint = "v1@example.com"
      lastUpdatedAt = now
    lastActiveAt = Some now
    weight = None
    kind = None

  -- there are two validator licenses for v1
  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 2

  -- the license with the highest lastReceivedFor is kept
  [(rulesCid, _)] <- query @DsoRules dso
  DsoRules_MergeValidatorLicenseResult validatorLicenseCid3 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicense1Cid, validatorLicense2Cid] (Some sv1))
  validatorLicenses <- queryFilter @ValidatorLicense dso (\license -> license.validator == v1)
  length validatorLicenses === 1
  (head validatorLicenses)._2.faucetState === Some FaucetState with
    firstReceivedFor = Round 0
    lastReceivedFor = Round 2
    numCouponsMissed = 0

  -- we can't merge a single contract
  submitMultiMustFail [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseCid3] (Some sv1))

  -- we can't merge contracts for different validator names
  [(validatorLicenseSv2Cid, _)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == sv2)
  submitMultiMustFail [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseCid3, validatorLicenseSv2Cid] (Some sv1))

  -- Test weight merging: min weight should be used
  v2 <- allocateParty "v2"
  validatorLicenseW1 <- submit dso $ createCmd ValidatorLicense with
    validator = v2
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some OperatorLicense

  validatorLicenseW2 <- submit dso $ createCmd ValidatorLicense with
    validator = v2
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 3
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = Some 2.0
    kind = Some OperatorLicense

  validatorLicenseW3 <- submit dso $ createCmd ValidatorLicense with
    validator = v2
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = Some 1.5
    kind = Some OperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedWeightLicense <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseW1, validatorLicenseW2, validatorLicenseW3] (Some sv1))
  [(_, mergedLicense)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v2)
  -- The merged license should have the minimum weight (0.5) and the highest lastReceivedFor (Round 3)
  mergedLicense.weight === Some 1.5
  mergedLicense.faucetState === Some FaucetState with
    firstReceivedFor = Round 0
    lastReceivedFor = Round 3
    numCouponsMissed = 0

  -- Test kind merging: Some OperatorLicense if any license has None or Some OperatorLicense
  v3 <- allocateParty "v3"

  -- Test case 1: mixing None and Some NonOperatorLicense -> should result in Some OperatorLicense
  validatorLicenseK1 <- submit dso $ createCmd ValidatorLicense with
    validator = v3
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = None  -- None should be treated as OperatorLicense

  validatorLicenseK2 <- submit dso $ createCmd ValidatorLicense with
    validator = v3
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedKind1 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseK1, validatorLicenseK2] (Some sv1))
  [(_, mergedLicense1)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v3)
  -- Should be OperatorLicense because one license had None
  mergedLicense1.kind === Some OperatorLicense

  -- Test case 2: mixing Some OperatorLicense and Some NonOperatorLicense -> should result in Some OperatorLicense
  v4 <- allocateParty "v4"
  validatorLicenseK3 <- submit dso $ createCmd ValidatorLicense with
    validator = v4
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some OperatorLicense

  validatorLicenseK4 <- submit dso $ createCmd ValidatorLicense with
    validator = v4
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedKind2 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseK3, validatorLicenseK4] (Some sv1))
  [(_, mergedLicense2)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v4)
  -- Should be OperatorLicense to prevent downgrading
  mergedLicense2.kind === Some OperatorLicense

  -- Test case 3: all licenses are Some NonOperatorLicense -> should result in Some NonOperatorLicense
  v5 <- allocateParty "v5"
  validatorLicenseK5 <- submit dso $ createCmd ValidatorLicense with
    validator = v5
    sponsor = sv1
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 1
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  validatorLicenseK6 <- submit dso $ createCmd ValidatorLicense with
    validator = v5
    sponsor = sv2
    dso
    faucetState = Some FaucetState with
      firstReceivedFor = Round 0
      lastReceivedFor = Round 2
      numCouponsMissed = 0
    metadata = None
    lastActiveAt = Some now
    weight = None
    kind = Some NonOperatorLicense

  DsoRules_MergeValidatorLicenseResult mergedKind3 <- submitMulti [sv1] [dso] $ exerciseCmd rulesCid (DsoRules_MergeValidatorLicense [validatorLicenseK5, validatorLicenseK6] (Some sv1))
  [(_, mergedLicense3)] <- queryFilter @ValidatorLicense dso (\license -> license.validator == v5)
  -- Should be NonOperatorLicense since all licenses are NonOperatorLicense
  mergedLicense3.kind === Some NonOperatorLicense

  pure()
