-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestResponseReimbursement where

import DA.Assert
import DA.List
import Daml.Script
import DA.Time

import Splice.DsoRules
import Splice.DSO.ResponseReimbursement -- FIXME: add Traffic to name
import Splice.DSO.CryptoHash
import Splice.DecentralizedSynchronizer

import Splice.Scripts.Util
import Splice.Scripts.DsoTestUtils


-- | Tests that reimbursement works.
test_confirmation_response_traffic_reimbursement : Script ()
test_confirmation_response_traffic_reimbursement = do
  (app, dso, (sv1, _, _, _)) <- initMainNet

  setTime demoTime

  [(dsoRulesCid, dsoRules)] <- query @DsoRules dso

  -- setup demo data
  let responseTrafficDataRaw = sortOn fst
        [ ("PAR::1", 1000)
        , ("PAR::2", 2000)
        , ("PAR::3", 3000)
        , ("PAR::4", 4000)
        ]
  let responseTrafficData = ResponseTrafficData with
        responseTrafficTotals = map (uncurry ResponseTrafficTotal) responseTrafficDataRaw
  let responseTrafficDataHash = hash responseTrafficData
  let reimbursementConfirmation = ReimbursementConfirmation with
        synchronizerId = dsoRules.config.decentralizedSynchronizer.activeSynchronizerId
        migrationId = 0
        responseTrafficDataHash

  -- setup reimbursement workflow state
  confirmAndExecutionAction app ARC_DsoRules with
    dsoAction = SRARC_StartResponseTrafficReimbursement
      DsoRules_StartResponseTrafficReimbursement

  -- add a new interval
  now <- getTime
  let testIntervalEnd = now `addRelTime` hours 1
  [(workflowStateCid, _)] <- query @ReimbursementWorkflowState dso
  confirmAndExecutionAction app ARC_DsoRules with
    dsoAction = SRARC_AddResponseTrafficReimbursementInterval
      DsoRules_AddResponseTrafficReimbursementInterval with
        nextIntervalEnd = testIntervalEnd
        workflowStateCid

  -- confirm data
  [(intervalStateCid, _)] <- query @ReimbursementIntervalState dso
  confirmAndExecutionAction app ARC_DsoRules with
    dsoAction = SRARC_ConfirmResponseTrafficReimbursement
      DsoRules_ConfirmResponseTrafficReimbursement with
        intervalStateCid
        reimbursementConfirmation

  -- check that there are no member traffic contracts yet
  [] <- query @MemberTraffic dso

  -- reimburse responses
  [(intervalStateCid, _)] <- query @ReimbursementIntervalState dso
  submitMulti [sv1] [app.dso] $ exerciseCmd dsoRulesCid DsoRules_ReimburseResponseTraffic with
    intervalStateCid
    responseTrafficData
    sv = sv1

  -- check that the expected member traffic contracts were created
  actualMemberTrafficContracts <- query @MemberTraffic dso
  let expectedMemberTrafficContracts = do
        (memberId, totalTraffic) <- responseTrafficDataRaw
        pure MemberTraffic with
          dso = dso
          memberId
          synchronizerId = reimbursementConfirmation.synchronizerId
          migrationId = reimbursementConfirmation.migrationId
          totalReimbursed = Some totalTraffic
          totalPurchased = 0
          amuletSpent = 0.0
          usdSpent = 0.0
          numPurchases = 0
  sortOn (.memberId) (map snd actualMemberTrafficContracts) ===
    expectedMemberTrafficContracts

  -- record the completion
  [(intervalStateCid, _)] <- query @ReimbursementIntervalState dso
  [(workflowStateCid, _)] <- query @ReimbursementWorkflowState dso
  submitMulti [sv1] [app.dso] $ exerciseCmd dsoRulesCid DsoRules_RecordCompletedResponseTrafficReimbursement with
    intervalStateCid
    workflowStateCid
    sv = sv1

  [] <- query @ReimbursementIntervalState dso
  [(_, workflowState)] <- query @ReimbursementWorkflowState dso
  (workflowState.earliestIntervalStart, workflowState.nextIntervalStart) ===
    (testIntervalEnd, testIntervalEnd)


  pure ()
