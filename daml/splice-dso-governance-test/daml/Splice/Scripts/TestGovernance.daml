-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestGovernance where

import DA.Assert
import DA.Foldable (forA_)
import DA.List
import qualified DA.Map as Map
import qualified DA.Set as Set
import Daml.Script
import DA.Time

import Splice.Amulet
import Splice.AmuletRules
import Splice.Round
import Splice.Schedule
import Splice.DSO.DecentralizedSynchronizer
import Splice.Fees
import Splice.Scripts.Parameters
import Splice.Issuance()


import Splice.DsoRules
import Splice.DSO.AmuletPrice
import Splice.AmuletConfig
import Splice.CometBft
import Splice.DecentralizedSynchronizer

import Splice.Scripts.DsoTestUtils


-- Vote Requests
----------------

-- | Tests vote request machinery on featured app right granting and revoking without effectivity.
testVoteRequestAcceptanceWithoutEffectivity : Script ()
testVoteRequestAcceptanceWithoutEffectivity = do
  (app, dso, (sv1, sv2, sv3, sv4)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  -- allocate an app provider, and check that there is no app right
  provider <- allocateParty "provider"
  [] <- query @FeaturedAppRight provider

  -- sv1 initiates the granting of the featured app right for the provider with no effective time
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 7) -- give everybody 7 days to vote
  let requestCid1 = result.voteRequest

  -- sv2 rejects initially
  requestCid <- castVote app sv2 requestCid1 False

  -- there are two votes, which is not enough to consider the vote definitive and grant the app right
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  -- a day passes and sv2 updates their vote
  passTime (days 1)
  requestCid <- castVote app sv2 requestCid True

  -- the VoteRequest trackingCid is set to the initial requestCid
  Some voteRequest <- queryContractId dso requestCid
  voteRequest.trackingCid === Some requestCid1

  -- there are still only two votes, which is not enough to consider the vote definitive and grant the app right
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  -- sv3 accepts too
  requestCid <- castVote app sv3 requestCid True

  -- now the majority svs have voted, therefore the request can be closed
  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  [(rightCid, right)] <- query @FeaturedAppRight provider
  right === FeaturedAppRight with dso; provider

  -- the request has been archived
  [] <- query @VoteRequest dso

  -- we can remove the granted right using a vote request, provided enough parties answer in time
  -- This uses early closure of the vote request, which is only possible if a super-majority of svs have voted
  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] $
    ARC_DsoRules with
      dsoAction = SRARC_RevokeFeaturedAppRight DsoRules_RevokeFeaturedAppRight with
        rightCid

  -- the right is now revoked
  [] <- query @FeaturedAppRight provider
  pure ()

-- | Tests vote request machinery on featured app right granting and revoking with effectivity.
testVoteRequestAcceptanceWithEffectivity : Script ()
testVoteRequestAcceptanceWithEffectivity = do
  (app, dso, (sv1, sv2, sv3, sv4)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  -- allocate an app provider, and check that there is no app right
  provider <- allocateParty "provider"
  [] <- query @FeaturedAppRight provider

  now <- getTime
  let effectiveTime = addRelTime now (days 8)

  -- sv1 initiates the granting of the featured app right for the provider
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = Some (effectiveTime) -- the right will be granted in 8 days
    voteRequestTimeout = Some (days 7) -- give everybody 7 days to vote with the possibility to change their vote
  let requestCid1 = result.voteRequest

  -- sv2 accepts
  requestCid <- castVote app sv2 requestCid1 True

  -- there are two votes, which is not enough to consider the vote definitive and grant the app right
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  -- the voteRequest trackingCid is set to the initial requestCid
  Some voteRequest <- queryContractId dso requestCid
  voteRequest.trackingCid === Some requestCid1

  -- sv3 accepts too
  requestCid <- castVote app sv3 requestCid True

  -- there are now three votes in favor of the change, but there is an effective date
  -- so it cannot be closed yet
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  -- sv4 rejects
  requestCid <- castVote app sv4 requestCid False

  -- the expiration date has passed
  passTime (days 7)

  -- even if everybody voted the request is not definitive yet, as the targetEffectiveAt time has not passed
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  -- sv4 can change its vote past the expiration date
  requestCid <- castVote app sv4 requestCid True

  -- and the delegate acts after targetEffectiveAt via its SV app
  passTime (days 1 + seconds 1)

  -- now the request becomes effective and the right is granted
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  now <- getTime
  result.completedAt === now
  result.abstainingSvs === []
  result.outcome === VRO_Accepted with effectiveAt = effectiveTime

  [(rightCid, right)] <- query @FeaturedAppRight provider
  right === FeaturedAppRight with dso; provider

  -- the request has been archived
  [] <- query @VoteRequest dso

  -- we can remove the granted right using a vote request, provided enough parties answer in time
  -- This uses early closure of the vote request, which is only possible if a super-majority of svs have voted
  initiateAndAcceptVote app [sv1, sv2, sv3, sv4] $
    ARC_DsoRules with
      dsoAction = SRARC_RevokeFeaturedAppRight DsoRules_RevokeFeaturedAppRight with
        rightCid

  -- the right is now revoked
  [] <- query @FeaturedAppRight provider
  pure ()

testVoteRequestRejectionWithoutEffectivity : Script ()
testVoteRequestRejectionWithoutEffectivity = do
  (_app, dso, (sv1, sv2, _sv3, sv4)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  -- allocate an app provider, and check that there is no app right
  provider <- allocateParty "provider"
  [] <- query @FeaturedAppRight provider

  -- sv1 initiates the granting of the featured app right for the provider
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 7) -- give everybody 7 days to vote
  let requestCid = result.voteRequest

  -- majority rejects the request
  requestCid <- castVote _app sv2 requestCid False
  requestCid <- castVote _app sv4 requestCid False
  requestCid <- castVote _app sv1 requestCid False -- sv1 changes their opinion

  -- the request is directly rejected
  now <- getTime
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv3"]
  result.outcome === VRO_Rejected

  pure ()

testVoteRequestRejectionWithEffectivityBeforeExpiration : Script ()
testVoteRequestRejectionWithEffectivityBeforeExpiration = do
  (_app, dso, (sv1, sv2, _sv3, sv4)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  now <- getTime
  let effectiveTime = addRelTime now (days 8)

  -- allocate an app provider, and check that there is no app right
  provider <- allocateParty "provider"
  [] <- query @FeaturedAppRight provider

  -- sv1 initiates the granting of the featured app right for the provider
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = Some (effectiveTime)
    voteRequestTimeout = Some (days 3) -- give everybody 3 days to vote
  let requestCid = result.voteRequest

  -- majority rejects the request
  requestCid <- castVote _app sv2 requestCid False
  requestCid <- castVote _app sv4 requestCid False
  requestCid <- castVote _app sv1 requestCid False -- sv1 changes their opinion

  -- even if an effective time is set, the majority rejected before the expiration date, so the request is rejected
  now <- getTime
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv3"]
  result.outcome === VRO_Rejected

  pure ()

testVoteRequestRejectionWithEffectivityAfterExpiration : Script ()
testVoteRequestRejectionWithEffectivityAfterExpiration = do
  (_app, dso, (sv1, sv2, _sv3, sv4)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  now <- getTime
  let effectiveTime = addRelTime now (days 8)

  -- allocate an app provider, and check that there is no app right
  provider <- allocateParty "provider"
  [] <- query @FeaturedAppRight provider

  -- voteRequests with an effective time set before the expiration date must fail
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = Some (addRelTime now (days 1))
    voteRequestTimeout = Some (days 2)

  -- sv1 initiates the granting of the featured app right for the provider
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = Some (effectiveTime)
    voteRequestTimeout = Some (days 3) -- give everybody 3 days to vote
  let requestCid = result.voteRequest

  -- a majority accepts the request before the expiration data
  requestCid <- castVote _app sv2 requestCid True
  requestCid <- castVote _app sv4 requestCid True

  -- early closing is not possible when an effective time is set
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  -- the expiration date has passed
  passTime (days 3)

  -- SVs can still reject the request after the expiration date
  requestCid <- castVote _app sv2 requestCid False
  requestCid <- castVote _app sv4 requestCid False
  requestCid <- castVote _app sv1 requestCid False

  -- SVs can change their vote as long as the vote request is active
  result <- submitMulti[sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid
    amuletRulesCid = None

  now <- getTime

  -- the request gets closed early as long as the majority rejected
  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv3"]
  result.outcome === VRO_Rejected

  pure ()

testRacingSvRemoval : Script ()
testRacingSvRemoval = do
  (app, dso, (sv1, sv2, sv3, sv4)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  -- sv1 is not happy with sv2, and issues two removal requests at the same time!
  result1 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv2
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 7) -- give everybody 7 days to vote

  result2 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv2
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 7) -- give everybody 7 days to vote

  -- sv2 counters and wants to remove sv1
  result3 <- submitMulti [sv2] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv2
    action = ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv1
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 7) -- give everybody 7 days to vote

  -- sv1 is not really happy with sv2, and issues a third removal request with an effective date set in 8 days.
  now <- getTime
  let effectiveTime = addRelTime now (days 8)

  result4 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv2
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = Some (effectiveTime)
    voteRequestTimeout = Some (days 2) -- give everybody 2 days to vote

  let (req1, req2, req3, req4) = (result1.voteRequest, result2.voteRequest, result3.voteRequest, result4.voteRequest)

  -- sv3 and sv4 are not happy with either of them, and accept both removal requests
  -- sv1 and sv2 accept both requests as well, so we can better test races
  [req1, req2, req3] <- forA [req1, req2, req3] $ \requestCid -> do
    result1 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CastVote with
      requestCid
      vote = Vote with
        sv = sv1
        accept = True
        reason = Reason with url = ""; body = "OK, let them go"
    result2 <- submitMulti [sv2] [dso] $ exerciseCmd dsoRulesCid DsoRules_CastVote with
      requestCid = result1.voteRequest
      vote = Vote with
        sv = sv2
        accept = True
        reason = Reason with url = ""; body = "OK, let them go"
    result3 <- submitMulti [sv3] [dso] $ exerciseCmd dsoRulesCid DsoRules_CastVote with
      requestCid = result2.voteRequest
      vote = Vote with
        sv = sv3
        accept = True
        reason = Reason with url = ""; body = "OK, let them go"
    result4 <- submitMulti [sv4] [dso] $ exerciseCmd dsoRulesCid DsoRules_CastVote with
      requestCid = result3.voteRequest
      vote = Vote with
        sv = sv4
        accept = True
        reason = Reason with url = ""; body = "OK, let them go"
    pure result4.voteRequest

  -- sv1 attempts to immediatly accept the request to remove sv2
  now <- getTime
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req1
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === []
  result.outcome === VRO_Accepted with effectiveAt = now

  -- and it eagerly accepts its other vote request as well
  [(dsoRulesCid, _)] <- query @DsoRules dso
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req2
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === ["sv2"]
  result.abstainingSvs === []
  result.outcome === VRO_AcceptedButActionFailed with description = "Not a sv"

  -- sv3 refuses and sv4 accepts request 4 with effectivity 8 days before the expiration.
  req4 <- castVote app sv3 req4 False
  req4 <- castVote app sv4 req4 True

  passTime (days 3)

  -- past the expiration date sv1 can reject the request as sv2 was already evicted, and the request is rejected.
  req4 <- castVote app sv1 req4 False

  [(dsoRulesCid, _)] <- query @DsoRules dso
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req4
    amuletRulesCid = None

  now <- getTime
  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === []
  result.outcome === VRO_Rejected

  -- and forgets to turn off automation, which now submits the closing of the vote request to remove SV1
  [(dsoRulesCid, _)] <- query @DsoRules dso
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req3
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === ["sv2"]
  result.abstainingSvs === []
  result.outcome === VRO_Accepted with effectiveAt = now

  -- There are only two svs left, and sv3 is the new DSO delegate
  [(_, dsoRules)] <- query @DsoRules dso
  Map.keys dsoRules.svs === [sv3, sv4]
  dsoRules.dsoDelegate === sv3

  -- The story continues: sv3 tries to remove sv4
  [(dsoRulesCid, _)] <- query @DsoRules dso
  result4 <- submitMulti [sv3] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv3
    action = ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv4
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (seconds 1) -- attempt to not give sv4 enough time to vote
  let req4 = result4.voteRequest

  -- early closing is not possible, as the outcome of the vote is not determined, and we thus leave
  -- time for some of the SV's to change their vote
  submitMultiMustFail [sv3] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req4
    amuletRulesCid = None

  -- after enough time has passed the closing works
  passTime (seconds 1)
  result <- submitMulti [sv3] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req4
    amuletRulesCid = None

  -- however sv4 is still here, as at least `numSvs / 2 + 1` svs need to accept the offboarding
  result.outcome === VRO_Expired

  -- Let's see if sv3 and sv4 can work together to also remove sv4
  result5 <- submitMulti [sv3] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv3
    action = ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv4
    reason = Reason with url = ""; body = "they want to leave!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 1)

  castResult <- submitMulti [sv4] [dso] $ exerciseCmd dsoRulesCid DsoRules_CastVote with
    requestCid = result5.voteRequest
    vote = Vote with
      sv = sv4
      accept = True
      reason = Reason with url = ""; body = "yes, let me go please!"
  let req5 = castResult.voteRequest

  -- and actually early closing is possible, as everybody has voted and the outcome is definite
  now <- getTime
  result <- submitMulti [sv3] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req5
    amuletRulesCid = None

  result.outcome === VRO_Accepted with effectiveAt = now

  -- check the SV's are gone
  [(_, dsoRules)] <- query @DsoRules dso
  Map.keys dsoRules.svs === [sv3]

  pure ()


-- | Test DsoRules configuration changes.
testDsoRulesConfigChange : Script ()
testDsoRulesConfigChange = do
  (app, dso, (sv1, sv2, sv3, _)) <- initMainNet

  now <- getTime
  [(_, dsoRules)] <- query @DsoRules dso

  -- first config that changes half of the parameters
  let newConfig1 = dsoRules.config with
        numUnclaimedRewardsThreshold = 5 + 1
        numMemberTrafficContractsThreshold = 5 + 1
        actionConfirmationTimeout = minutes (5 + 1)
        svOnboardingRequestTimeout = hours (1 + 1)
        svOnboardingConfirmedTimeout = hours (1 + 1)
        voteRequestTimeout = days (7 + 1)
        dsoDelegateInactiveTimeout = seconds (70 + 1)
        maxTextLength = 1024 + 1
        nextScheduledSynchronizerUpgrade = Some (SynchronizerUpgradeSchedule with
                                                    time = addRelTime now (days 4)
                                                    migrationId = 1)


  let initialSynchronizerConfig2 = SynchronizerConfig with
        state = DS_Operational
        cometBftGenesisJson = "<genesis-json2>"
        acsCommitmentReconciliationInterval = Some 1802
  let initialDsoDecentralizedSynchronizerConfig2 =  DsoDecentralizedSynchronizerConfig with
        synchronizers = Map.fromList [("synchronizer-id2", initialSynchronizerConfig2)]
        lastSynchronizerId = "synchronizer-id2"
        activeSynchronizerId = "synchronizer-2"

  let synchronizerNodeConfigLimits2 = SynchronizerNodeConfigLimits with
        cometBft = CometBftConfigLimits with
                      maxNumCometBftNodes = 2 + 1
                      maxNumGovernanceKeys = 2 + 1
                      maxNumSequencingKeys = 2 + 1
                      maxNodeIdLength = 50 + 1
                      maxPubKeyLength = 256 + 1

  -- second config that changes the other half of the parameters
  let newConfig2 = dsoRules.config with
        synchronizerNodeConfigLimits = synchronizerNodeConfigLimits2
        decentralizedSynchronizer = initialDsoDecentralizedSynchronizerConfig2

  now <- getTime

  -- creation of two concurrent independent vote requests
  [(dsoRulesCid, _)] <- query @DsoRules dso
  result1 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_SetConfig DsoRules_SetConfig with
        newConfig = newConfig1
        baseConfig = Some dsoRules.config
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 2)

  result2 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_SetConfig DsoRules_SetConfig with
        newConfig = newConfig2
        baseConfig = Some dsoRules.config
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 2)

  let (req1, req2) = (result1.voteRequest, result2.voteRequest)

  req1 <- castVote app sv2 req1 True
  req1 <- castVote app sv3 req1 True

  [(dsoRulesCid, _)] <- query @DsoRules dso
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req1
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv4"]
  result.outcome === VRO_Accepted with effectiveAt = now

  -- the first request has been accepted and must reflect newConfig1
  [(dsoRulesCid, dsoRules)] <- query @DsoRules dso
  dsoRules.config === newConfig1

  req2 <- castVote app sv2 req2 True
  req2 <- castVote app sv3 req2 True

  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req2
    amuletRulesCid = None

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv4"]
  result.outcome === VRO_Accepted with effectiveAt = now

  -- the second request has been accepted and must reflect newConfig1 with the changes introduced by newConfig2
  [(_, dsoRules)] <- query @DsoRules dso
  dsoRules.config === newConfig1 with
                      synchronizerNodeConfigLimits = newConfig2.synchronizerNodeConfigLimits
                      decentralizedSynchronizer = newConfig2.decentralizedSynchronizer

-- | Test tickDuration changes.
testAmuletRulesTickDurationChange : Script ()
testAmuletRulesTickDurationChange = do
  (app, dso, (sv1, sv2, sv3, _)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  [(_, amuletRules)] <- query @AmuletRules dso

  -- config with new tickDuration
  let initialConfig = amuletRules.configSchedule.initialValue
  let newConfig = amuletRules.configSchedule.initialValue with tickDuration = seconds 20

  [(amuletRulesCid, amuletRules)] <- query @AmuletRules dso
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_AmuletRules with
      amuletRulesAction = CRARC_SetConfig AmuletRules_SetConfig with
        newConfig = newConfig
        baseConfig = amuletRules.configSchedule.initialValue
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 2)

  now <- getTime
  -- vote on change
  let request = result.voteRequest
  request <- castVote app sv2 request True
  request <- castVote app sv3 request True

  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = request
    amuletRulesCid = Some amuletRulesCid

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv4"]
  result.outcome === VRO_Accepted with effectiveAt = now

  [(_, round1), (_, round2), (_, round3)] <- sortOn (._2.round) <$> query @OpenMiningRound dso
  round1.tickDuration === initialConfig.tickDuration
  round2.tickDuration === initialConfig.tickDuration
  round3.tickDuration === initialConfig.tickDuration

  runNextIssuanceD app 1.2

  -- check that tickDuraction has changed
  [(_, round1), (_, round2), (_, round3)] <- sortOn (._2.round) <$> query @OpenMiningRound dso
  round1.tickDuration === initialConfig.tickDuration
  round2.tickDuration === initialConfig.tickDuration
  round3.tickDuration === newConfig.tickDuration

-- | Test AmuletRules configuration changes.
testAmuletRulesConfigChange : Script ()
testAmuletRulesConfigChange = do
  (app, dso, (sv1, sv2, sv3, _)) <- initMainNet

  [(dsoRulesCid, _)] <- query @DsoRules dso

  [(_, amuletRules)] <- query @AmuletRules dso

  let defaultTransferConfig2 = TransferConfig with
        createFee = FixedFee 0.04
        holdingFee = RatePerRound 0.00004
        lockHolderFee = FixedFee 0.007
        transferFee = SteppedRate with
          initialRate = 0.06
          steps = [(100.1, 0.002), (1000.1, 0.0002), (1000000.1, 0.00002)]
        extraFeaturedAppRewardAmount = 2.0
        maxNumInputs = 101
        maxNumOutputs = 101
        maxNumLockHolders = 11

  let defaultBaseRateTrafficLimits2 = BaseRateTrafficLimits with
        burstAmount = 10 * 20 * 1000 + 1
        burstWindow = minutes (10 + 1)

  let defaultSynchronizerFeesConfig2 = SynchronizerFeesConfig with
        baseRateTrafficLimits = defaultBaseRateTrafficLimits2
        minTopupAmount = 1_000_001
        extraTrafficPrice = 2.0
        readVsWriteScalingFactor = 42

  let defaultAmuletDecentralizedSynchronizerConfig2 = AmuletDecentralizedSynchronizerConfig with
        requiredSynchronizers = Set.fromList ["decentralized-synchronizer-id-2"]
        activeSynchronizer = "decentralized-synchronizer-id-2"
        fees = defaultSynchronizerFeesConfig2

  let issuanceConfig_0p5_1p5_2 = issuanceConfig_10plus with
        amuletToIssuePerYear = 40e9
        validatorRewardPercentage = 0.05
        appRewardPercentage = 0.15

  let defaultIssuanceCurve2 = Schedule with
        initialValue = issuanceConfig_0p5_1p5_2
        futureValues =
          [
          ]

  -- first config that changes half of the parameters
  let newConfig1 = amuletRules.configSchedule.initialValue with
        transferConfig = defaultTransferConfig2
        issuanceCurve = defaultIssuanceCurve2
        tickDuration = seconds 200

  -- second config that changes the other half of the parameters
  let newConfig2 = amuletRules.configSchedule.initialValue with
        decentralizedSynchronizer = defaultAmuletDecentralizedSynchronizerConfig2

  now <- getTime

  -- creation of two concurrent independent vote requests
  [(amuletRulesCid, amuletRules)] <- query @AmuletRules dso
  result1 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_AmuletRules with
      amuletRulesAction = CRARC_SetConfig AmuletRules_SetConfig with
        newConfig = newConfig1
        baseConfig = amuletRules.configSchedule.initialValue
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 2)

  result2 <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_AmuletRules with
      amuletRulesAction = CRARC_SetConfig AmuletRules_SetConfig with
        newConfig = newConfig2
        baseConfig = amuletRules.configSchedule.initialValue
    reason = Reason with url = ""; body = "they are not good for us!"
    targetEffectiveAt = None
    voteRequestTimeout = Some (days 2)

  let (req1, req2) = (result1.voteRequest, result2.voteRequest)

  req1 <- castVote app sv2 req1 True
  req1 <- castVote app sv3 req1 True

  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req1
    amuletRulesCid = Some amuletRulesCid

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv4"]
  result.outcome === VRO_Accepted with effectiveAt = now

  -- the first request has been accepted and must reflect newConfig1
  [(amuletRulesCid, amuletRules)] <- query @AmuletRules dso
  amuletRules.configSchedule.initialValue === newConfig1

  req2 <- castVote app sv2 req2 True
  req2 <- castVote app sv3 req2 True

  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = req2
    amuletRulesCid = Some amuletRulesCid

  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv4"]
  result.outcome === VRO_Accepted with effectiveAt = now

  -- the second request has been accepted and must reflect newConfig1 with the changes introduced by newConfig2
  [(_, amuletRules)] <- query @AmuletRules dso
  amuletRules.configSchedule.initialValue === newConfig1 with
    decentralizedSynchronizer = newConfig2.decentralizedSynchronizer

-- | Test SV removal and GC of AmuletPriceVotes
testOffboardSvAndAmuletPriceVotes : Script ()
testOffboardSvAndAmuletPriceVotes = do
  (app, dso, (sv1, sv2, sv3, sv4)) <- initMainNet

  -- check that the DSO delegate is currently sv1
  [(_, dsoRules)] <- query @DsoRules dso
  dsoRules.dsoDelegate === sv1

  -- run the voting process to change the config and remove the current DSO delegate 'sv1'
  initiateAndAcceptVote app [sv2, sv3, sv4] $
    ARC_DsoRules with
      dsoAction = SRARC_OffboardSv DsoRules_OffboardSv with
        sv = sv1

  -- the voting process is only definitive after the timeout, so right now sv1 is still present
  [(_, dsoRules)] <- query @DsoRules dso
  Map.keys (dsoRules.svs) === [sv1, sv2, sv3, sv4]

  -- pass the default voting timeout
  passTime (dsoRules.config.voteRequestTimeout)
  executeAllDefinitiveVotes app

  -- check that the sv was removed and the DSO delegate changed to sv2
  [(dsoRulesCid, dsoRules)] <- query @DsoRules dso
  Map.keys (dsoRules.svs) === [sv2, sv3, sv4]
  Map.keys (dsoRules.offboardedSvs) === [sv1]
  dsoRules.dsoDelegate === sv2

  -- duplicate the AmuletPriceVote for sv2 to test duplicate removal
  amuletPriceVotes <- query @AmuletPriceVote dso
  let [(sv2VoteCid1, sv2Vote)] = filter (\(_, vote) -> vote.sv == sv2) amuletPriceVotes
  sv2VoteCid2 <- submit dso $ createCmd sv2Vote

  -- there should now be five votes
  amuletPriceVotes <- query @AmuletPriceVote dso
  length amuletPriceVotes === 5

  -- garbage collect the AmuletPriceVote of sv1
  let [(sv1VoteCid, _)] = filter (\(_, vote) -> vote.sv == sv1) amuletPriceVotes
  submitMulti [sv2] [dso] $ exerciseCmd dsoRulesCid DsoRules_GarbageCollectAmuletPriceVotes with
    nonSvVoteCids = [sv1VoteCid]
    duplicateVoteCids = [[sv2VoteCid1, sv2VoteCid2]]

  -- there should now be only three votes
  amuletPriceVotes <- query @AmuletPriceVote dso
  length amuletPriceVotes === 3

  -- one cannot archive a vote by listing it as a duplicate of its own
  let [(sv3VoteCid, _)] = filter (\(_, vote) -> vote.sv == sv3) amuletPriceVotes
  submitMultiMustFail [sv2] [dso] $ exerciseCmd dsoRulesCid DsoRules_GarbageCollectAmuletPriceVotes with
    nonSvVoteCids = []
    duplicateVoteCids = [[sv3VoteCid, sv3VoteCid]]

-- | vote request contract is archived if it has expired
testVoteRequestExpireWithoutEffectivity : Script ()
testVoteRequestExpireWithoutEffectivity = do
  (_, dso, (sv1, _, _, _)) <- initMainNet
  provider <- allocateParty "provider"

  [(dsoRulesCid, _)] <- query @DsoRules dso
  requestResult <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = None
    voteRequestTimeout = None

  -- attempt to close the vote request before its voting period
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = requestResult.voteRequest
    amuletRulesCid = None

  passTime(days 7)
  now <- getTime

  -- close the vote request once the voting period is over
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = requestResult.voteRequest
    amuletRulesCid = None

  -- only sv1 voted to accept as they created the request
  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv2", "sv3", "sv4"]
  result.outcome === VRO_Expired

  return ()


testVoteRequestExpireWithEffectivity : Script ()
testVoteRequestExpireWithEffectivity = do
  (_, dso, (sv1, _, _, _)) <- initMainNet
  provider <- allocateParty "provider"

  now <- getTime
  let effectiveTime = addRelTime now (days 8)

  [(dsoRulesCid, _)] <- query @DsoRules dso
  requestResult <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_RequestVote with
    requester = sv1
    action = ARC_DsoRules with
      dsoAction = SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight with
        provider
    reason = Reason with url = ""; body = "they are great!"
    targetEffectiveAt = Some (effectiveTime)
    voteRequestTimeout = None

  -- attempt to close the vote request before its voting period
  submitMultiMustFail [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = requestResult.voteRequest
    amuletRulesCid = None

  passTime(days 7)
  now <- getTime

  -- close the vote request once the voting period is over
  result <- submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_CloseVoteRequest with
    requestCid = requestResult.voteRequest
    amuletRulesCid = None

  -- only sv1 voted to accept as they created the request
  result.completedAt === now
  result.offboardedVoters === []
  result.abstainingSvs === ["sv2", "sv3", "sv4"]
  result.outcome === VRO_Expired

  return ()



-- Amulet Prices
--------------


unitTestMedian : Script ()
unitTestMedian = do
  median [1.0] === 1.0
  median [2.0, 1.0] === 1.5
  median [3.0, 1.0, 2.0] === 2.0
  median [1.0, 2.0, 3.0, 4.0] === 2.5
  median [1.0, 200.0, 3.0, 4.0, 1000.0] === 4.0


testAmuletPriceVoting : Script ()
testAmuletPriceVoting = do

  (app, dso, (sv1, sv2, sv3, sv4)) <- initMainNet

  -- run a normal issuance so time advances and the amulet price is set to 1.2 for everybody
  runNextIssuanceD app 1.2

  -- have all SV's adjust their prices
  [(dsoRulesCid, _)] <- query @DsoRules dso
  forA_ (zip [1, 2, 3, 4] [sv1, sv2, sv3, sv4]) $ \(amuletPriceInt, sv) -> do
    [(voteCid, _)] <- queryFilter @AmuletPriceVote dso (\vote -> vote.sv == sv)
    submitMulti [sv] [dso] $ exerciseCmd dsoRulesCid DsoRules_UpdateAmuletPriceVote with
      sv
      amuletPrice = intToDecimal amuletPriceInt
      voteCid

  [(voteCid, _)] <- queryFilter @AmuletPriceVote dso (\vote -> vote.sv == sv1)

  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_UpdateAmuletPriceVote with
    sv = sv1
    amuletPrice = 5.0
    voteCid

  [(amuletRulesCid, amuletRules)] <- query @AmuletRules dso
  now <- getTime
  let amuletConfig = Splice.Schedule.getValueAsOf now amuletRules.configSchedule
  passTime (amuletConfig.tickDuration)

  -- pass enough time to advance the open mining round and lock in the price
  [(roundToArchiveCid, _), (middleRoundCid, _), (latestRoundCid, _)] <- sortOn (._2.round) <$> query @OpenMiningRound dso
  amuletPriceVotes <- query @AmuletPriceVote dso
  submitMulti [sv1] [dso] $ exerciseCmd dsoRulesCid DsoRules_AdvanceOpenMiningRounds with
    amuletRulesCid
    roundToArchiveCid
    middleRoundCid
    latestRoundCid
    amuletPriceVoteCids = map fst amuletPriceVotes

  -- check that the most recent round has the median a amulet price of the votes
  (_, latestRound) <- (last . sortOn (._2.round)) <$> query @OpenMiningRound dso
  latestRound.amuletPrice === 3.5

  pure ()
