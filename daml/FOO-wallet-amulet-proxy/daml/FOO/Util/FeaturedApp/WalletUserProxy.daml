-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Utility template for proxying token standard choices so that featured app markers
-- are created for a wallet app provider by their users when they are using
-- token standard workflows.
--
-- You can either use this template directly, or copy the code
-- under a **different package name** and a **different module name**.
--
-- Note: use the `DelegateProxy` if you are building an app that uses multiple parties
-- for its own operations.
--
module FOO.Util.FeaturedApp.WalletUserProxy where


import DA.Foldable (forA_)

import Splice.Wallet.TransferPreapproval

import Splice.Api.Token.TransferInstructionV1
import Splice.Api.Token.AllocationV1
import Splice.Api.Token.AllocationInstructionV1
import Splice.Api.FeaturedAppRightV1


-- | Generic argument to the proxy choices.
data ProxyArg arg = ProxyArg with
    user : Party -- ^ The wallet user that is using the wallet to exercise a choice.
    choiceArg : arg -- ^ The argument to the choice that the user is exercising.
    featuredAppRightCid : ContractId FeaturedAppRight -- ^ The featured app right contract of the provider.
  deriving (Show, Eq)

-- | Generic result of the proxy choices.
data ProxyResult r = ProxyResult with
    markerResult : FeaturedAppRight_CreateActivityMarkerResult
    choiceResult : r

-- | A proxy to attribute the activity of a wallet user to the wallet app provider.
--
-- The intended usage is for the wallet app provider to
-- 1. create a `WalletUserProxy` contract with the `provider` set to the app provider's party
-- 2. setup their wallet frontend such that users call the proxy's choices instead of the original token standard choices.
--
-- Note that the weights are specified on the proxy contract, so that they are under the providers
-- control. If they were specified on the choices, then the user could in principle change them,
-- and grant themselves a higher reward than intended.
template WalletUserProxy with
    provider : Party -- ^ The app provider whose featured app right should be triggered
    providerWeight : Decimal -- ^ Reward weight for the provider
    userWeight : Decimal -- ^ Reward weight for the user, set to 0.0 if the user should not receive a reward
    extraBeneficiaries : [AppRewardBeneficiary] -- ^ Extra beneficiaries to add
    optAllowList : Optional [Party] -- ^ An optional allow list of parties that can use the proxy
  where
    ensure validProxy this
    signatory provider

    nonconsuming choice WalletUserProxy_TransferFactory_Transfer
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferFactory
        proxyArg : ProxyArg TransferFactory_Transfer
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \_ -> do
          pure proxyArg.choiceArg.transfer.sender

    nonconsuming choice WalletUserProxy_TransferInstruction_Accept
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferInstruction
        proxyArg : ProxyArg TransferInstruction_Accept
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice WalletUserProxy_TransferInstruction_Reject
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferInstruction
        proxyArg : ProxyArg TransferInstruction_Reject
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice WalletUserProxy_TransferInstruction_Withdraw
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferInstruction
        proxyArg : ProxyArg TransferInstruction_Withdraw
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice WalletUserProxy_AllocationFactory_Allocate
      : ProxyResult AllocationInstructionResult
      with
        cid : ContractId AllocationFactory
        proxyArg : ProxyArg AllocationFactory_Allocate
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \_ -> do
          pure proxyArg.choiceArg.allocation.transferLeg.sender

    nonconsuming choice WalletUserProxy_Allocation_Withdraw
      : ProxyResult Allocation_WithdrawResult
      with
        cid : ContractId Allocation
        proxyArg : ProxyArg Allocation_Withdraw
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          allocation <- fetch cid
          pure (view allocation).allocation.transferLeg.sender

    nonconsuming choice WalletUserProxy_Create_TransferPreapprovalProposal
      : ProxyResult (ContractId TransferPreapprovalProposal)
      with
        proxyArg : ProxyArg TransferPreapprovalProposal
      controller proxyArg.user
      do
        require "provider matches" (proxyArg.choiceArg.provider == provider)
        exerciseProxyCreate this proxyArg (.receiver)


-- Utilities
-------------

-- | Shared code to execute the proxied create.
exerciseProxyCreate
  : forall t. (Template t, HasCreate t) => WalletUserProxy -> ProxyArg t -> (t -> Party) -> Update (ProxyResult (ContractId t))
exerciseProxyCreate proxy proxyArg getExpectedUser = do
  let ProxyArg{..} = proxyArg
  appRight <- fetch featuredAppRightCid
  -- validate the user and provider
  require "User matches expected user" (getExpectedUser proxyArg.choiceArg == user)
  forA_ proxy.optAllowList $ \allowList ->
    require "User is in the allow list" (user `elem` allowList)
  require "App right matches expected provider" ((view appRight).provider == proxy.provider)
  -- create marker
  markerResult <- exercise featuredAppRightCid FeaturedAppRight_CreateActivityMarker with
    beneficiaries = proxyBeneficiaries proxy user
  -- exercise proxied create
  cid <- create proxyArg.choiceArg
  pure ProxyResult with markerResult; choiceResult = cid

-- | Shared code to execute the proxied choice.
exerciseProxyChoice
  : forall t ch r. HasExercise t ch r =>
  WalletUserProxy -> ContractId t -> ProxyArg ch -> (ContractId t -> Update Party) -> Update (ProxyResult r)
exerciseProxyChoice proxy cid proxyArg getExpectedUser = do
  let ProxyArg{..} = proxyArg
  appRight <- fetch featuredAppRightCid
  expectedUser <- getExpectedUser cid
  -- validate the user and provider
  require "User matches expected user" (expectedUser == user)
  forA_ proxy.optAllowList $ \allowList ->
    require "User is in the allow list" (user `elem` allowList)
  require "App right matches expected provider" ((view appRight).provider == proxy.provider)
  -- create marker
  markerResult <- exercise featuredAppRightCid FeaturedAppRight_CreateActivityMarker with
    beneficiaries = proxyBeneficiaries proxy user
  -- exercise proxied choice
  choiceResult <- exercise cid choiceArg
  pure ProxyResult with markerResult; choiceResult

-- | Get the list of beneficiaries for the featured app marker.
proxyBeneficiaries : WalletUserProxy -> Party -> [AppRewardBeneficiary]
proxyBeneficiaries WalletUserProxy{..} user =
  filter (\b -> b.weight > 0.0) [AppRewardBeneficiary provider providerWeight, AppRewardBeneficiary user userWeight]
    ++ extraBeneficiaries

validProxy : WalletUserProxy -> Bool
validProxy WalletUserProxy{..} =
    validWeight userWeight &&
    validWeight providerWeight  &&
    all (\b -> validWeight b.weight) extraBeneficiaries
  where
    validWeight : Decimal -> Bool
    validWeight w = 0.0 <= w && w <= 1.0

-- | Check whether a required condition is true. If it's not, abort the
-- transaction with a message saying that the requirement was not met.
require : CanAssert m => Text -> Bool -> m ()
require msg invariant =
  assertMsg ("The requirement '" <> msg <> "' was not met.") invariant
