-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Utility template for proxying token standard choices so that featured app markers
-- are created for a wallet app provider by their users when they are using
-- token standard workflows.
--
-- You can either use this template directly, or copy the code
-- under a **different package name** and a **different module name**.
--
-- Note: use the `DelegateProxy` if you are building an app that uses multiple parties
-- for its own operations.
--
module Splice.Util.FeaturedApp.WalletUserProxy where


import DA.Foldable (forA_)
import DA.Map qualified as M
import DA.Optional (fromOptional)

import Splice.Api.Token.HoldingV1
import Splice.Api.Token.TransferInstructionV1
import Splice.Api.Token.AllocationV1
import Splice.Api.Token.AllocationInstructionV1
import Splice.Api.FeaturedAppRightV1


-- | Generic argument to the proxy choices.
data ProxyArg arg = ProxyArg with
    user : Party -- ^ The wallet user that is using the wallet to exercise a choice.
    choiceArg : arg -- ^ The argument to the choice that the user is exercising.
    featuredAppRightCid : ContractId FeaturedAppRight -- ^ The featured app right contract of the provider.
  deriving (Show, Eq)

-- | Generic result of the proxy choices.
data ProxyResult r = ProxyResult with
    markerResult : FeaturedAppRight_CreateActivityMarkerResult
    choiceResult : r

-- | A call to the token standard factory to initiate a token standard transfer.
-- Specialized because it is used in the batch transfer choice below.
data TransferFactoryCall = TransferFactoryCall with
    factoryCid : ContractId TransferFactory
    choiceArg : TransferFactory_Transfer
  deriving (Eq, Show)

-- | A proxy to attribute the activity of a wallet user to the wallet app provider.
--
-- The intended usage is for the wallet app provider to
-- 1. create a `WalletUserProxy` contract with the `provider` set to the app provider's party
-- 2. setup their wallet frontend such that users call the proxy's choices instead of the original token standard choices.
--
-- Note that the weights are specified on the proxy contract, so that they are under the providers
-- control. If they were specified on the choices, then the user could in principle change them,
-- and grant themselves a higher reward than intended.
--
-- Note also that the batch transfer support can be used without having a featured app right.
template WalletUserProxy with
    provider : Party -- ^ The app provider whose featured app right should be triggered
    providerWeight : Decimal -- ^ Reward weight for the provider
    userWeight : Decimal -- ^ Reward weight for the user, set to 0.0 if the user should not receive a reward
    extraBeneficiaries : [AppRewardBeneficiary] -- ^ Extra beneficiaries to add
    optAllowList : Optional [Party] -- ^ An optional allow list of parties that can use the proxy
  where
    ensure validProxy this
    signatory provider

    -- Explictly disclosed contracts typically offer anybody the ability to fetch them
    -- and validate their contract arguments.
    nonconsuming choice WalletUserProxy_PublicFetch : WalletUserProxy
      with
        actor : Party
      controller actor
      do pure this

    nonconsuming choice WalletUserProxy_TransferFactory_Transfer
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferFactory
        proxyArg : ProxyArg TransferFactory_Transfer
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \_ -> do
          pure proxyArg.choiceArg.transfer.sender

    nonconsuming choice WalletUserProxy_TransferInstruction_Accept
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferInstruction
        proxyArg : ProxyArg TransferInstruction_Accept
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice WalletUserProxy_TransferInstruction_Reject
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferInstruction
        proxyArg : ProxyArg TransferInstruction_Reject
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice WalletUserProxy_TransferInstruction_Withdraw
      : ProxyResult TransferInstructionResult
      with
        cid : ContractId TransferInstruction
        proxyArg : ProxyArg TransferInstruction_Withdraw
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice WalletUserProxy_AllocationFactory_Allocate
      : ProxyResult AllocationInstructionResult
      with
        cid : ContractId AllocationFactory
        proxyArg : ProxyArg AllocationFactory_Allocate
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \_ -> do
          pure proxyArg.choiceArg.allocation.transferLeg.sender

    nonconsuming choice WalletUserProxy_Allocation_Withdraw
      : ProxyResult Allocation_WithdrawResult
      with
        cid : ContractId Allocation
        proxyArg : ProxyArg Allocation_Withdraw
      controller proxyArg.user
      do
        exerciseProxyChoice this cid proxyArg $ \cid -> do
          allocation <- fetch cid
          pure (view allocation).allocation.transferLeg.sender

    -- A choice for a sender to execute many token standard transfers in a single transaction.
    nonconsuming choice WalletUserProxy_BatchTransfer : WalletUserProxy_BatchTransferResult
      with
        transferCalls : [TransferFactoryCall]
          -- ^ Transfers to execute via their respective transfer factories.
          -- Input holdings are properly threaded through for all instrument-ids.
          -- The sender change is always added back as an additional input to follow-up transfers
          -- for the same instrument-ids.
          --
          -- Note that we accept fully specified calls to factories for maximum flexibility.
          -- Some token admins may actually use different factories for different recipients,
          -- e.g., to implement preapprovals.
        optFeaturedAppRightCid : Optional (ContractId FeaturedAppRight)
          -- ^ The featured app right contract of the provider to use on every transfer.
          -- Optional so the batched choice can be used without a featured app right.
      controller getFirstSender transferCalls
      do runBatch this arg



-- Batch transfer implementation
--------------------------------

type InstrumentHoldingMap = M.Map InstrumentId [ContractId Holding]

data WalletUserProxy_BatchTransferResult = WalletUserProxy_BatchTransferResult with
    transferResults : [TransferInstructionResult]
    senderChangeMap : InstrumentHoldingMap
  deriving (Eq, Show)

-- | Determine the sender of the transfer in the first call.
getFirstSender : [TransferFactoryCall] -> Party
getFirstSender [] = error "Cannot determine sender from empty list of TransferFactoryCalls"
getFirstSender (call :: _) = call.choiceArg.transfer.sender

-- | Validate the batch call and run it
runBatch : WalletUserProxy -> WalletUserProxy_BatchTransfer -> Update WalletUserProxy_BatchTransferResult
runBatch proxy WalletUserProxy_BatchTransfer{..} = do
  let sender = getFirstSender transferCalls
  forA_ optFeaturedAppRightCid $ validateAppRight proxy
  checkAllowList proxy.optAllowList sender
  executeTransferCalls proxy sender optFeaturedAppRightCid transferCalls M.empty []

-- | Run the individual transfer calls in the batch with proper threading of input holdings.
executeTransferCalls
  : WalletUserProxy -> Party -> Optional (ContractId FeaturedAppRight) -> [TransferFactoryCall]
  -> InstrumentHoldingMap -> [TransferInstructionResult]
  -> Update WalletUserProxy_BatchTransferResult
executeTransferCalls _proxy _sender _optFeaturedAppRightCid [] holdingMap results =
  pure WalletUserProxy_BatchTransferResult with
    transferResults = reverse results
    senderChangeMap = holdingMap

executeTransferCalls proxy sender optFeaturedAppRightCid ((TransferFactoryCall with factoryCid; choiceArg) :: calls) holdingMap results = do
  -- check and execute the one transfer with adjusted input holdings
  let tf = choiceArg.transfer
  require ("Transfer sender " <> show tf.sender <> " matches expected sender " <> show sender) (tf.sender == sender)
  let actualInputHoldingCids = tf.inputHoldingCids ++ fromOptional [] (M.lookup tf.instrumentId holdingMap)
  let actualChoice = choiceArg with
        transfer = tf with inputHoldingCids = actualInputHoldingCids
  result <- exercise factoryCid actualChoice

  -- create the featured app marker for the provider and sender
  forA_ optFeaturedAppRightCid $ createAppMarker proxy sender

  -- run the rest of the transfer factory calls
  let newHoldingMap = M.insert tf.instrumentId result.senderChangeCids holdingMap
  executeTransferCalls proxy sender optFeaturedAppRightCid calls newHoldingMap (result :: results)



-- Generic proxy choice execution
---------------------------------

-- | Shared code to execute the proxied choice.
exerciseProxyChoice
  : forall t ch r. HasExercise t ch r =>
  WalletUserProxy -> ContractId t -> ProxyArg ch -> (ContractId t -> Update Party) -> Update (ProxyResult r)
exerciseProxyChoice proxy cid proxyArg getExpectedUser = do
  let ProxyArg{..} = proxyArg
  -- validate app right and user
  validateAppRight proxy featuredAppRightCid
  expectedUser <- getExpectedUser cid
  require "User matches expected user" (expectedUser == user)
  checkAllowList proxy.optAllowList user
  markerResult <- createAppMarker proxy user featuredAppRightCid
  -- exercise proxied choice
  choiceResult <- exercise cid choiceArg
  pure ProxyResult with markerResult; choiceResult

validateAppRight : WalletUserProxy -> ContractId FeaturedAppRight -> Update ()
validateAppRight proxy featuredAppRightCid = do
  appRight <- fetch featuredAppRightCid
  require "App right matches expected provider" ((view appRight).provider == proxy.provider)

checkAllowList : Optional [Party] -> Party -> Update ()
checkAllowList None _ = pure ()
checkAllowList (Some allowList) user = require "User is in the allow list" (user `elem` allowList)

createAppMarker
  : WalletUserProxy -> Party -> ContractId FeaturedAppRight -> Update FeaturedAppRight_CreateActivityMarkerResult
createAppMarker proxy user featuredAppRightCid = do
  exercise featuredAppRightCid FeaturedAppRight_CreateActivityMarker with
    beneficiaries = proxyBeneficiaries proxy user

-- | Get the list of beneficiaries for the featured app marker.
proxyBeneficiaries : WalletUserProxy -> Party -> [AppRewardBeneficiary]
proxyBeneficiaries WalletUserProxy{..} user =
  filter (\b -> b.weight > 0.0) [AppRewardBeneficiary provider providerWeight, AppRewardBeneficiary user userWeight]
    ++ extraBeneficiaries

validProxy : WalletUserProxy -> Bool
validProxy WalletUserProxy{..} =
    validWeight userWeight &&
    validWeight providerWeight  &&
    all (\b -> validWeight b.weight) extraBeneficiaries
  where
    validWeight : Decimal -> Bool
    validWeight w = 0.0 <= w && w <= 1.0

-- | Check whether a required condition is true. If it's not, abort the
-- transaction with a message saying that the requirement was not met.
require : CanAssert m => Text -> Bool -> m ()
require msg invariant =
  assertMsg ("The requirement '" <> msg <> "' was not met.") invariant
