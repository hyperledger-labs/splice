-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestLockAndAmuletExpiry where

import DA.Assert

import Daml.Script

import Splice.Amulet
import Splice.Amulet.TokenApiUtils
import Splice.AmuletConfig (AmuletConfig(..))
import qualified Splice.AmuletConfig as Unit
import Splice.AmuletRules
import Splice.Fees
import Splice.Expiry
import Splice.Round
import Splice.Types
import Splice.Testing.Registries.AmuletRegistry.Parameters
import Splice.Testing.Registries.AmuletRegistry (advanceToNextRoundChange)
import Splice.Scripts.Util

import DA.Foldable (forA_)
import DA.Time

scaleAmuletConfig : Decimal -> AmuletConfig Unit.USD -> AmuletConfig Amulet
scaleAmuletConfig amuletPrice config = AmuletConfig with
  transferConfig = scaleFees (1.0 / amuletPrice) config.transferConfig
  decentralizedSynchronizer = config.decentralizedSynchronizer
  issuanceCurve = config.issuanceCurve
  tickDuration = config.tickDuration
  packageConfig = config.packageConfig
  transferPreapprovalFee = fmap (/ amuletPrice) config.transferPreapprovalFee
  featuredAppActivityMarkerAmount = fmap (/ amuletPrice) config.featuredAppActivityMarkerAmount
  optDevelopmentFundManager = config.optDevelopmentFundManager
  externalPartyConfigStateTickDuration = config.externalPartyConfigStateTickDuration

test : Script ()
test = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToNextRoundChange app.dso -- advance time so we're out of the initial mining round
  let amuletPrice = 2.5
      config = scaleAmuletConfig amuletPrice defaultAmuletConfig

  -- This amulet is estimated to expire at round 5.
  -- we exploit that there are exactly three open rounds active at any point in time.
  -- we wait for 2 more rounds to ensure that a amulet can be expired as soon as
  -- it can definitely not be used as an input to transfer anymore.
  -- This amulet can still be used until round 7 (5 + 2) which is created at T00:15:00 and opens at T00:17:30
  let amountExpiresAtRound5 = ExpiringAmount with initialAmount = config.transferConfig.holdingFee.rate * 3.5; createdAt = Round 1; ratePerRound = config.transferConfig.holdingFee
  let bounded = amountExpiresAt amountExpiresAtRound5
  bounded === Singleton (Round 5)
  pure ()

testExpireLockedAmulet : Script ()
testExpireLockedAmulet = do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToNextRoundChange app.dso -- advance time so we're out of the initial mining round
  passTime (minutes 10) -- pass enough time so that round 2 expires in 10 minutes

  -- We don't enforce that locks expire before the underlying amulet does so locking an amulet with with initialAmount 0.000005 and created at round 2 but with a
  -- lock for 10 minutes should succeed even if round 2 ends in 10 minutes.
  cid0 <- getLockedAmulet app alice bob.primaryParty defaultTransferConfig.holdingFee.rate (minutes 10)
  -- Lock the amulet with initialAmount 0.000005 and created at round 2
  -- As the amulet amount is equal to one round's holding fee, it will be expired at round 3
  cid <- getLockedAmulet app alice bob.primaryParty defaultTransferConfig.holdingFee.rate (seconds 90 - convertMicrosecondsToRelTime 1)
  Some(lockedAmulet) <- queryContractId @LockedAmulet alice.primaryParty cid

  _ <- advanceRound app (Round 3)

  -- Current round is 4
  _ <- advanceRound app (Round 4)

  -- Lock is not yet expired
  -- DSO party fails to expire the amulet
  (externalPartyConfigState0Cid, externalPartyConfigState1Cid) <- getExternalPartyConfigStates app
  testChoiceFailed [app.dso] [app.dso] $
    exerciseCmd cid (LockedAmulet_ExpireAmuletV2 with
      externalPartyConfigState0Cid
      externalPartyConfigState1Cid)


  -- Current round is 5
  _ <- advanceRound app (Round 5)

  normalizedBalanceBeforeExpiry <- getNormalizedBalance app.dso

  -- Amulet is expired
  -- 2 rounds before current round => 5 - 2 = 3 which is equal to round 3 when the amulet expires
  -- DSO party expires the amulet
  (externalPartyConfigState0Cid, externalPartyConfigState1Cid) <- getExternalPartyConfigStates app
  result <- checkTxMetadata' app TxKind_ExpireDust alice.primaryParty $
    testChoice [app.dso] [app.dso] $
      exerciseCmd cid $ LockedAmulet_ExpireAmuletV2 with
        externalPartyConfigState0Cid
        externalPartyConfigState1Cid
  let expireSummary = result.expireSum

  normalizedBalanceAfterExpiry <- getNormalizedBalance app.dso
  expireSummary.changeToInitialAmountAsOfRoundZero === normalizedBalanceAfterExpiry - normalizedBalanceBeforeExpiry
  expireSummary.changeToHoldingFeesRate === - (lockedAmulet.amulet.amount.ratePerRound.rate)

  lockedAmulets <- query @LockedAmulet bob.primaryParty
  map fst lockedAmulets === [cid0]

  pure ()

testExpireAmulet : Script ()
testExpireAmulet = do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

  -- alice own a amulet with initial amount of 1.0
  [(_, onlyAmulet)] <- query @Amulet alice.primaryParty
  onlyAmulet.amount.initialAmount === 1.0

  cid <- tap app alice 0.0000200001
  -- Lock the amulet with initialAmount 0.0000200001 and created at round 1
  -- As the holding fee is 0.00002 so the amulet will be expired at round 3
  Some(amulet) <- queryContractId @Amulet alice.primaryParty cid

  amulet.amount.initialAmount === 0.0000200001
  amulet.amount.createdAt === Round 1

  -- current latest active round is 3
  _ <- advanceRound app (Round 3)

  -- 2 rounds before latest active round = 3 - 2 = 1 which is before round 3 when the amulet expires
  -- DSO party fails to expire the amulet
  (externalPartyConfigState0Cid, externalPartyConfigState1Cid) <- getExternalPartyConfigStates app
  testChoiceFailed [app.dso] [app.dso] $
    exerciseCmd cid Amulet_ExpireV2 with
      externalPartyConfigState0Cid
      externalPartyConfigState1Cid

  -- current latest active round is 4
  _ <- advanceRound app (Round 4)

  -- 2 rounds before current latest active round => 4 - 2 = 2 which is before round 3 when the amulet expires
  -- DSO party fails to expire the amulet
  (externalPartyConfigState0Cid, externalPartyConfigState1Cid) <- getExternalPartyConfigStates app
  testChoiceFailed [app.dso] [app.dso] $
    exerciseCmd cid Amulet_ExpireV2 with
      externalPartyConfigState0Cid
      externalPartyConfigState1Cid

  _ <- advanceRound app (Round 5)

  normalizedBalanceBeforeExpiry <- getNormalizedBalance app.dso

  -- 2 rounds before current latest active round => 5 - 2 = 3 which is equal to round 3 when the amulet expires
  -- DSO party expires the amulet
  (externalPartyConfigState0Cid, externalPartyConfigState1Cid) <- getExternalPartyConfigStates app
  result <- checkTxMetadata' app TxKind_ExpireDust alice.primaryParty $
    testChoice [app.dso] [app.dso] $
    exerciseCmd cid $ Amulet_ExpireV2 with
      externalPartyConfigState0Cid
      externalPartyConfigState1Cid
  let expireSummary = result.expireSum

  normalizedBalanceAfterExpiry <- getNormalizedBalance app.dso
  expireSummary.changeToInitialAmountAsOfRoundZero === normalizedBalanceAfterExpiry - normalizedBalanceBeforeExpiry
  expireSummary.changeToHoldingFeesRate === - (amulet.amount.ratePerRound.rate)

  -- current active current mining round is 3, 4 and 5
  allActiveOpenMiningRoundCids <- query @OpenMiningRound app.dso
  forA_ allActiveOpenMiningRoundCids $ \(_, openRound) -> do
    assert $ openRound.round.number >= 3 && openRound.round.number <= 5

  -- alice now only owns a amulet with initial amount of 1.0
  [(_, onlyAmulet)] <- query @Amulet alice.primaryParty
  onlyAmulet.amount.initialAmount === 1.0

  pure ()

advanceRound : AmuletApp -> Round -> Script (ContractId OpenMiningRound)
advanceRound app expectedRound  = do
  runNextIssuance app
  (latestActiveRoundCid, _) <- getLatestActiveOpenRound app
  Some(currentRound) <- queryContractId @OpenMiningRound app.dso latestActiveRoundCid
  currentRound.round === expectedRound
  syncExternalPartyConfigStatesWithRounds app
  pure latestActiveRoundCid

syncExternalPartyConfigStatesWithRounds : AmuletApp -> Script ()
syncExternalPartyConfigStatesWithRounds app = do
  passTime (hours 24)
  updateExternalPartyConfigState app
  passTime (hours 24)
  updateExternalPartyConfigState app

addRelRoundN : Int -> Time -> RelTime -> Time
addRelRoundN n t relTime
  | n <= 0 = t
  | otherwise = addRelRoundN (n-1) (addRelTime t relTime) relTime

testChoice : [Party] -> [Party] -> Commands a -> Script a
testChoice actAs readAs buildCommand = do
  submitMulti actAs readAs buildCommand

testChoiceFailed : [Party] -> [Party] -> Commands a -> Script ()
testChoiceFailed actAs readAs buildCommand = do
  submitMultiMustFail actAs readAs buildCommand
  pure ()

getLockedAmuletCmd : AmuletApp -> AmuletUser -> Party -> Decimal -> RelTime -> Script (Commands TransferResult)
getLockedAmuletCmd app owner lockHolder amount lockDuration = do
  now <- getTime
  amulet <- tap app owner (amount + 1.0)
  let transfer = Transfer with
        sender = owner.primaryParty
        provider = owner.primaryParty
        inputs = map InputAmulet [amulet]
        outputs =
          [ TransferOutput with
              receiver = owner.primaryParty
              amount = amount
              lock = Some TimeLock with
                holders = [lockHolder]
                expiresAt = now `addRelTime` lockDuration
                optContext = None
              receiverFeeRatio = 0.0
          ]
        beneficiaries = None -- test code, don't set beneficiaries
  (openRound, _) <- getLatestOpenRound app
  featuredAppRight <- getFeaturedAppRight app owner.primaryParty

  (rules, _) <- fetchAmuletRulesByKey app.dso
  return $ exerciseCmd rules
    AmuletRules_Transfer with
      transfer, context = amuletTransferContext openRound featuredAppRight
      expectedDso = Some app.dso

getLockedAmulet : AmuletApp -> AmuletUser -> Party -> Decimal -> RelTime -> Script (ContractId LockedAmulet)
getLockedAmulet app owner lockHolder amount lockDuration = do
  cmd <- getLockedAmuletCmd app owner lockHolder amount lockDuration
  result <- submitMulti [owner.primaryParty, lockHolder] [app.dso] cmd
  let [TransferResultLockedAmulet lockedAmulet] = result.createdAmulets
  pure lockedAmulet

getLockedAmuletMustFail : AmuletApp -> AmuletUser -> Party -> Decimal -> RelTime -> Script ()
getLockedAmuletMustFail app owner lockHolder amount lockDuration =  do
  cmd <- getLockedAmuletCmd app owner lockHolder amount lockDuration
  submitMultiMustFail [owner.primaryParty, lockHolder] [app.dso] cmd
