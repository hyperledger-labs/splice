-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestValidatorFaucet where

import DA.Assert
import DA.List (head)
import DA.Optional (fromOptional)
import DA.Time

import Daml.Script

import Splice.Amulet
import Splice.Issuance
import Splice.Scripts.Util
import Splice.ValidatorLicense
import Splice.Util

test_ValidatorFaucet: Script ()
test_ValidatorFaucet = do
    DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

    [(faucetCid, _)] <- query @ValidatorLicense aliceValidator.primaryParty

    let checkActivityRecordsExist round = do
          coupons <- queryFilter @ValidatorLivenessActivityRecord app.dso (\co -> co.round == round)
          map (._2) coupons === [ValidatorLivenessActivityRecord with
                dso = app.dso
                validator = aliceValidator.primaryParty
                round
                weight = None]

    let checkActivityRecordsDoNotExist round = do
          [] <- queryFilter @ValidatorLivenessActivityRecord app.dso (\co -> co.round == round)
          pure ()

    let checkAliceValidatorBalanceAbove amount = do
          [(_, amulet)] <- query @Amulet aliceValidator.primaryParty
          require ("alice's validator has >= " <> show amount <> " amulet") (amulet.amount.initialAmount >= amount)

    [round0, round1, _round2] <- getActiveOpenRoundsSorted app

    -- round0 can be received
    passTime (hours 1)
    now <- getTime
    result <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0._1
    let faucetCid = result.licenseCid
    Some faucet <- queryContractId @ValidatorLicense aliceValidator.primaryParty faucetCid
    faucet.lastActiveAt === Some now
    checkActivityRecordsExist (round0._2.round)

    -- but not twice
    submitMultiMustFail [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0._1

    -- round1 can be received
    result <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round1._1
    let faucetCid = result.licenseCid
    checkActivityRecordsExist (round1._2.round)

    -- let's collect the rewards for Round 0: requires two issuing round advances
    -- (create the issuing round and advance time for it to become open)
    runNextIssuance app
    runNextIssuance app

    runAmuletDepositBots app

    -- checking that the rewards are gone; we're not checking balances as that logic is tested in
    -- the rewards issuance tests
    checkActivityRecordsDoNotExist round0._2.round
    checkAliceValidatorBalanceAbove 3.0 -- initial 1 Amulet plus 2.85 Amulet from the faucet

    -- also collect the round 1
    runNextIssuance app
    runAmuletDepositBots app
    checkActivityRecordsDoNotExist round1._2.round

    checkAliceValidatorBalanceAbove 6.0 -- an additional 2.85 Amulet from the faucet

    -- testing skipping
    -------------------

    -- get the new active rounds
    [round2, round3, _] <- getActiveOpenRoundsSorted app

    -- skip one day
    passTime (days 1)

    -- round3 can be received despite round 2 not yet being recieved, i.e., we can skip rounds
    result <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round3._1
    let faucetCid = result.licenseCid

    checkActivityRecordsDoNotExist round2._2.round
    checkActivityRecordsExist (round3._2.round)

    -- check that the coupons for round 2 and 3 are marked as not collected
    [(_, license)] <- query @ValidatorLicense aliceValidator.primaryParty
    let Some faucetState = license.faucetState
    faucetState.numCouponsMissed === 2

    -- round2 can no longer be received
    submitMultiMustFail [alice.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round2._1

    return ()

-- Helper function to test validator faucet with different weights
testValidatorFaucetWithWeight_Helper : Decimal -> Optional Decimal -> Decimal -> Script ()
testValidatorFaucetWithWeight_Helper bobWeight bobExpectedMin bobExpectedMax = do
    DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

    [(aliceLicenseCid, aliceLicense)] <- query @ValidatorLicense aliceValidator.primaryParty
    [(bobLicenseCid, bobLicense)] <- query @ValidatorLicense bobValidator.primaryParty

    -- Update bob's license to have the specified weight
    submit app.dso $ archiveCmd bobLicenseCid
    now <- getTime
    bobLicenseCid <- submitMulti [bobValidator.primaryParty, app.dso] [] $ createCmd bobLicense with
      weight = Some bobWeight
      lastActiveAt = Some now

    aliceBalanceBefore <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceBefore <- getNormalizedBalance bobValidator.primaryParty

    -- Get the current open round
    rounds <- getOpenRoundsSorted app
    let (round0Cid, round0) = head rounds

    -- Both alice and bob record liveness activity
    passTime (hours 1)
    aliceResult <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd aliceLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid
    let aliceLicenseCid = aliceResult.licenseCid

    bobResult <- submitMulti [bobValidator.primaryParty] [app.dso] $ exerciseCmd bobLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid
    let bobLicenseCid = bobResult.licenseCid

    -- Verify the activity records were created with correct weights
    aliceRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == aliceValidator.primaryParty && r.round == round0.round)
    bobRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == bobValidator.primaryParty && r.round == round0.round)

    length aliceRecords === 1
    length bobRecords === 1

    let [(_, aliceRecord)] = aliceRecords
    let [(_, bobRecord)] = bobRecords

    aliceRecord.weight === None
    bobRecord.weight === Some bobWeight

    runNextIssuance app
    runNextIssuance app

    runAmuletDepositBots app

    aliceBalanceAfter <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceAfter <- getNormalizedBalance bobValidator.primaryParty

    let aliceReward = aliceBalanceAfter - aliceBalanceBefore
    let bobReward = bobBalanceAfter - bobBalanceBefore

    let aliceExpectedMin = 2.8
    let aliceExpectedMax = 3.0

    require "Alice should receive default rewards" (aliceReward >= aliceExpectedMin && aliceReward <= aliceExpectedMax)

    case bobExpectedMin of
      Some minVal -> require "Bob should receive expected reward based on weight" (bobReward >= minVal && bobReward <= bobExpectedMax)
      None -> require "Bob should not receive rewards" (bobReward <= bobExpectedMax)

    return ()

-- With weight 3.0, Bob should receive 3x Alice's rewards
test_ValidatorFaucetWithWeight3: Script ()
test_ValidatorFaucetWithWeight3 = do
    let bobWeight = 3.0
        bobExpectedMin = Some 8.4
        bobExpectedMax = 9.0
    testValidatorFaucetWithWeight_Helper bobWeight bobExpectedMin bobExpectedMax

-- With weight 0.0, Bob should receive no rewards
test_ValidatorFaucetWithWeight0: Script ()
test_ValidatorFaucetWithWeight0 = do
    -- bob actually loses balance when doing minting with 0 weight. So just confirm bobExpectedMax
    let bobWeight = 0.0
        bobExpectedMin = None
        bobExpectedMax = 0.0
    testValidatorFaucetWithWeight_Helper bobWeight bobExpectedMin bobExpectedMax
