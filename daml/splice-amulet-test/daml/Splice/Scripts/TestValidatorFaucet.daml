-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestValidatorFaucet where

import DA.Action (void)
import DA.Assert
import DA.List (head)
import DA.Time

import Daml.Script

import Splice.Amulet
import Splice.Scripts.Util
import Splice.ValidatorLicense
import Splice.Util

test_ValidatorFaucet: Script ()
test_ValidatorFaucet = do
    DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

    [(faucetCid, _)] <- query @ValidatorLicense aliceValidator.primaryParty

    let checkActivityRecordsExist round = do
          coupons <- queryFilter @ValidatorLivenessActivityRecord app.dso (\co -> co.round == round)
          map (._2) coupons === [ValidatorLivenessActivityRecord with
                dso = app.dso
                validator = aliceValidator.primaryParty
                round
                weight = None]

    let checkActivityRecordsDoNotExist round = do
          [] <- queryFilter @ValidatorLivenessActivityRecord app.dso (\co -> co.round == round)
          pure ()

    let checkAliceValidatorBalanceAbove amount = do
          [(_, amulet)] <- query @Amulet aliceValidator.primaryParty
          require ("alice's validator has >= " <> show amount <> " amulet") (amulet.amount.initialAmount >= amount)

    [round0, round1, _round2] <- getActiveOpenRoundsSorted app

    -- round0 can be received
    passTime (hours 1)
    now <- getTime
    result <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0._1
    let faucetCid = result.licenseCid
    Some faucet <- queryContractId @ValidatorLicense aliceValidator.primaryParty faucetCid
    faucet.lastActiveAt === Some now
    checkActivityRecordsExist (round0._2.round)

    -- but not twice
    submitMultiMustFail [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0._1

    -- round1 can be received
    result <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round1._1
    let faucetCid = result.licenseCid
    checkActivityRecordsExist (round1._2.round)

    -- let's collect the rewards for Round 0: requires two issuing round advances
    -- (create the issuing round and advance time for it to become open)
    runNextIssuance app
    runNextIssuance app

    runAmuletDepositBots app

    -- checking that the rewards are gone; we're not checking balances as that logic is tested in
    -- the rewards issuance tests
    checkActivityRecordsDoNotExist round0._2.round
    checkAliceValidatorBalanceAbove 3.0 -- initial 1 Amulet plus 2.85 Amulet from the faucet

    -- also collect the round 1
    runNextIssuance app
    runAmuletDepositBots app
    checkActivityRecordsDoNotExist round1._2.round

    checkAliceValidatorBalanceAbove 6.0 -- an additional 2.85 Amulet from the faucet

    -- testing skipping
    -------------------

    -- get the new active rounds
    [round2, round3, _] <- getActiveOpenRoundsSorted app

    -- skip one day
    passTime (days 1)

    -- round3 can be received despite round 2 not yet being recieved, i.e., we can skip rounds
    result <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round3._1
    let faucetCid = result.licenseCid

    checkActivityRecordsDoNotExist round2._2.round
    checkActivityRecordsExist (round3._2.round)

    -- check that the coupons for round 2 and 3 are marked as not collected
    [(_, license)] <- query @ValidatorLicense aliceValidator.primaryParty
    let Some faucetState = license.faucetState
    faucetState.numCouponsMissed === 2

    -- round2 can no longer be received
    submitMultiMustFail [alice.primaryParty] [app.dso] $ exerciseCmd faucetCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round2._1

    return ()

data ValidatorWeightTestParams = ValidatorWeightTestParams with
    bobWeight : Decimal
    aliceExpectedMin : Decimal
    aliceExpectedMax : Decimal
    bobExpectedMin : Decimal
    bobExpectedMax : Decimal
  deriving (Show, Eq)

-- With weight 3.0, Bob should receive 3x Alice's rewards
test_ValidatorFaucetWithWeight3: Script ()
test_ValidatorFaucetWithWeight3 = do
    let bobWeight = 3.0
        aliceExpectedMin = 2.85
        aliceExpectedMax = 3.0
    testValidatorFaucetWithWeight_Helper ValidatorWeightTestParams with
        bobWeight = bobWeight
        aliceExpectedMin = aliceExpectedMin
        aliceExpectedMax = aliceExpectedMax
        bobExpectedMin = aliceExpectedMin * bobWeight
        bobExpectedMax = aliceExpectedMax * bobWeight

-- With weight 0.0, Bob should receive no rewards
-- Note: it is not possible to create activity records for weight 0.0
-- This test simply confirms the workings of reward calculation logic
test_ValidatorFaucetWithWeight0: Script ()
test_ValidatorFaucetWithWeight0 = do
    let bobWeight = 0.0
        aliceExpectedMin = 2.85
        aliceExpectedMax = 3.0
    testValidatorFaucetWithWeight_Helper ValidatorWeightTestParams with
        bobWeight = bobWeight
        aliceExpectedMin = aliceExpectedMin
        aliceExpectedMax = aliceExpectedMax
        bobExpectedMin = aliceExpectedMin * bobWeight
        bobExpectedMax = aliceExpectedMax * bobWeight

-- Test that runNextIssuance properly handles ValidatorLicense weights
-- in the optTotalValidatorLivenessActivityRecords calculation
-- Bob has been given a large weight to trigger the use of `cappedRewardsToIssue` (in computeIssuanceTranche)
-- which would result in alice getting lower rewards than the default value of about 2.85
test_ValidatorLivenessWeightInRunNextIssuance : Script ()
test_ValidatorLivenessWeightInRunNextIssuance = do
    let bobWeight = 15000.0
        aliceExpectedMin = 2.5
        aliceExpectedMax = 2.55
    testValidatorFaucetWithWeight_Helper ValidatorWeightTestParams with
        bobWeight = bobWeight
        aliceExpectedMin = aliceExpectedMin
        aliceExpectedMax = aliceExpectedMax
        bobExpectedMin = aliceExpectedMin * bobWeight
        bobExpectedMax = aliceExpectedMax * bobWeight

-- Helper function to test validator faucet with different weights
-- Uses no-fee config to avoid balance changes due to fees
testValidatorFaucetWithWeight_Helper : ValidatorWeightTestParams -> Script ()
testValidatorFaucetWithWeight_Helper params = do
    DefaultAppWithUsers{..} <- setupDefaultAppWithUsersNoFees

    [(aliceLicenseCid, _)] <- query @ValidatorLicense aliceValidator.primaryParty
    [(bobLicenseCid, bobLicense)] <- query @ValidatorLicense bobValidator.primaryParty

    -- Update bob's license to have the specified weight
    submit app.dso $ archiveCmd bobLicenseCid
    bobLicenseCid <- submitMulti [bobValidator.primaryParty, app.dso] [] $ createCmd bobLicense with
      weight = Some params.bobWeight

    aliceBalanceBefore <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceBefore <- getNormalizedBalance bobValidator.primaryParty

    -- Get the current open round
    rounds <- getOpenRoundsSorted app
    let (round0Cid, round0) = head rounds

    -- Both alice and bob record liveness activity
    passTime (hours 1)
    _ <- submitMulti [aliceValidator.primaryParty] [app.dso] $ exerciseCmd aliceLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
      openRoundCid = round0Cid

    -- For weight 0, create the activity record directly since the choice has a non-zero requirement
    if params.bobWeight == 0.0
      then
        void $ submit app.dso $ createCmd ValidatorLivenessActivityRecord with
          dso = app.dso
          validator = bobValidator.primaryParty
          round = round0.round
          weight = Some params.bobWeight
      else
        void $ submitMulti [bobValidator.primaryParty] [app.dso] $ exerciseCmd bobLicenseCid ValidatorLicense_RecordValidatorLivenessActivity with
          openRoundCid = round0Cid

    -- Verify the activity records were created with correct weights
    aliceRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == aliceValidator.primaryParty && r.round == round0.round)
    bobRecords <- queryFilter @ValidatorLivenessActivityRecord app.dso
      (\r -> r.validator == bobValidator.primaryParty && r.round == round0.round)

    length aliceRecords === 1
    length bobRecords === 1

    let [(_, aliceRecord)] = aliceRecords
    let [(_, bobRecord)] = bobRecords

    aliceRecord.weight === None
    bobRecord.weight === Some params.bobWeight

    runNextIssuance app
    runNextIssuance app

    runAmuletDepositBots app

    aliceBalanceAfter <- getNormalizedBalance aliceValidator.primaryParty
    bobBalanceAfter <- getNormalizedBalance bobValidator.primaryParty

    let aliceReward = aliceBalanceAfter - aliceBalanceBefore
    let bobReward = bobBalanceAfter - bobBalanceBefore

    require "Alice should receive expected rewards" (aliceReward >= params.aliceExpectedMin && aliceReward <= params.aliceExpectedMax)
    require "Bob should receive expected reward based on weight" (bobReward >= params.bobExpectedMin && bobReward <= params.bobExpectedMax)

    return ()
