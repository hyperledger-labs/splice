-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Unit tests for the fees module
module Splice.Scripts.UnitTests.Fees where

import DA.Action (unless)
import DA.Assert ((===))
import DA.Foldable (forA_)
import DA.Time

import Daml.Script

import Splice.Fees

test_toRatePerDay : Script ()
test_toRatePerDay = do
    expectedRatePerDay === ratePerRoundToRatePerDay ratePerRound tickDuration
  where
    expectedRatePerDay = RatePerDay with rate = ratePerRound.rate * 24.0 * 6.0

    ratePerRound : RatePerRound
    ratePerRound = RatePerRound with rate = 0.02

    tickDuration : RelTime
    tickDuration = minutes 10

test_chargeRatePerDay : Script ()
test_chargeRatePerDay = do
    expectedCharge === chargeRatePerDay ratePerDay (days 101)
  where
    expectedCharge = 101.0 * 0.03
    ratePerDay = RatePerDay with rate = 0.03

test_validSteppedRate : Script ()
test_validSteppedRate = do
    test True 0.1 [(100.0, 0.001), (1000.0, 0.0001), (100000.0, 0.00001)]
    test True 0.1 [(100.0, 0.0)]
    test True 0.1 [(100.0, 0.0), (1000.0, 0.0), (100000.0, 0.0)]
    test True 0.0 [(100.0, 0.0), (1000.0, 0.0), (100000.0, 0.0)]
    test True 0.1 []
    test True 0.0 []
    test False 0.1 [(100.0, 0.001), (100.0, 0.0001)]
    test False 0.1 [(100.0, 0.001), (90.0, 0.0001)]
    test False (-0.1) []
    test False 0.1 [(100.0, -0.001)]
  where
    test isValid initialRate steps = do
        let steppedRate = SteppedRate with initialRate, steps
        unless (isValid == validSteppedRate steppedRate) $
            error $ "SteppedRate validity check failed for " <> show (isValid, steppedRate)

test : Script ()
test = script do
  let example = SteppedRate 0.01 [(100.0, 0.001), (1000.0, 0.0001), (1000000.0, 0.00001)]
  -- Negative values & zero are handled gracefully
  chargeSteppedRate example (-1.0) === 0.0
  chargeSteppedRate example 0.0 === 0.0
  -- Values in first step & end of first step get the corresponding rate
  chargeSteppedRate example 50.0 === 0.01 * 50.0
  chargeSteppedRate example 100.0 === 0.01 * 100.0
  -- Values in second step get rate for first step & second step
  chargeSteppedRate example 900.0 === 0.01 * 100.0 + 0.001 * 800.0
  chargeSteppedRate example 1100.0 === 0.01 * 100.0 + 0.001 * 900.0 + 0.0001 * 100.0
  -- Values in third step get rates from all steps

  chargeSteppedRate example 1500.0 === 0.01 * 100.0 + 0.001 * 900.0 + 500.0 * 0.0001
  chargeSteppedRate example 1001100.0 === 0.01 * 100.0 + 0.001 * 900.0 + 0.0001 * 998900.0 + 0.00001 * 1200.0
  -- Values after the last step stick with the last rate for everything after
  -- the last step.
  chargeSteppedRate example (100.0 + 1000.0 + 1000000.0 + 1.0)
    === 0.01 * 100.0 + 0.001 * 900.0 + 0.0001 * 998900.0 + 0.00001 * 1201.0
  chargeSteppedRate example (100.0 + 1000.0 + 1000000.0 + 1000000.0)
    === 0.01 * 100.0 + 0.001 * 900.0 + 0.0001 * 998900.0 + 0.00001 * 1001200.0

testScaledSteppedRate : Script ()
testScaledSteppedRate = script do
  let unscaledRate = SteppedRate 0.01 [(100.0, 0.001), (1000.0, 0.0001), (1000000.0, 0.00001)]
  checkAllForScale unscaledRate 0.5
  checkAllForScale unscaledRate 1.0
  checkAllForScale unscaledRate 2.0

checkAllForScale : SteppedRate -> Decimal -> Script ()
checkAllForScale unscaledRate scale = do
  let scaledRate = scaleSteppedRate scale unscaledRate
  forA_ (map (._1) unscaledRate.steps) $ \(step) -> do
    checkScaledSteppedRate unscaledRate scale scaledRate step
    checkScaledSteppedRate unscaledRate scale scaledRate (step + 0.1)
    checkScaledSteppedRate unscaledRate scale scaledRate (step / 2.0)

checkScaledSteppedRate : SteppedRate -> Decimal -> SteppedRate -> Decimal -> Script ()
checkScaledSteppedRate unscaledRate scale scaledRate value = do
  chargeSteppedRate scaledRate value === (chargeSteppedRate unscaledRate (value / scale)) * scale
