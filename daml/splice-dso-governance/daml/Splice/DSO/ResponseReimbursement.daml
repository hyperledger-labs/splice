-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | All the response reimbursement workflows code that does not depend on `DsoRules`.
module Splice.DSO.ResponseReimbursement where

import DA.Action
import DA.Assert
import DA.Foldable (forA_)
import DA.Optional
import DA.Text qualified as T
import DA.Time

import Splice.DecentralizedSynchronizer
import Splice.Util
import Splice.DSO.CryptoHash
import Splice.Types




-- TODO: consider using a fixed one nibble sharding prefix as that gives a 16x
-- tx size reduction while being cheap to implement due to not being
-- configurable.


-- TODO: add contract that makes it easy to test the hashing of the responseTrafficDataHash


-- State of the overall reimbursement workflow.
-----------------------------------------------

data ReimbursementInterval = ReimbursementInterval with
    startExclusive : Time
    endInclusive : Time
  deriving (Eq, Show)

-- | The top-level state of the reimbursement workflow. We expect there to be exactly one
-- such contract per DSO.
template ReimbursementWorkflowState
  with
    dso: Party
    earliestIntervalStart: Time
      -- ^ The start time of the earliest interval that is still being processed.
    nextIntervalStart: Time
  where
    signatory dso

    -- Only called from DsoRules. We keep it as its own choice to simplify reasoning about the logic.
    choice ReimbursementWorkflowState_AddReimbursementInterval
      : ReimbursementWorkflowState_AddReimbursementIntervalResult
      with
        minIntervalDuration : RelTime
        nextIntervalEnd : Time
      controller dso
      do
        -- ensure minimal duration
        let intervalDuration = nextIntervalEnd `subTime` nextIntervalStart
        require "Minimal interval duration" (intervalDuration >= minIntervalDuration)
        -- ensure that intervals are added at most `minIntervalDuration` ahead of time
        let backdatedStart = nextIntervalStart `addRelTime` (negate minIntervalDuration)
        assertDeadlineExceeded "nextIntervalStart - minIntervalDuration" backdatedStart
        intervalStateCid <- create ReimbursementIntervalState with
          dso = dso
          interval = ReimbursementInterval with
            startExclusive = nextIntervalStart
            endInclusive = nextIntervalEnd
          reimbursementConfirmation = None
        workflowStateCid <- create this with
          nextIntervalStart = nextIntervalEnd
        pure ReimbursementWorkflowState_AddReimbursementIntervalResult with
          intervalStateCid
          workflowStateCid


data ReimbursementWorkflowState_AddReimbursementIntervalResult = ReimbursementWorkflowState_AddReimbursementIntervalResult with
    intervalStateCid : ContractId ReimbursementIntervalState
    workflowStateCid : ContractId ReimbursementWorkflowState
  deriving (Eq, Show)



-- State of reimbursing responses for a given interval.
-------------------------------------------------------

data ReimbursementConfirmation = ReimbursementConfirmation with
    synchronizerId : Text -- ^ Synchronizer on which the responses should be reimbursed. Always set to the global synchronizer-id.
    migrationId : Int -- ^ Migration id on which the responses should be reimbursed. Always set to the latest migration id.
    responseTrafficDataHash : Hash
  deriving (Eq, Show)

data ResponseTrafficData = ResponseTrafficData with
    responseTrafficTotals : [ResponseTrafficTotal]
  deriving (Eq, Show)

data ResponseTrafficTotal = ResponseTrafficTotal with
    memberId : Text
    totalTraffic : Int
  deriving (Eq, Show)


template ReimbursementIntervalState
  with
    dso: Party
    interval: ReimbursementInterval
    reimbursementConfirmation : Optional ReimbursementConfirmation
  where
    signatory dso

    choice ReimbursementIntervalState_ConfirmReimbursement
      : ReimbursementIntervalState_ConfirmReimbursementResult
      with
        reimbursementConfirmation : ReimbursementConfirmation
      controller dso
      do
        require "Not yet confirmed" (isNone this.reimbursementConfirmation)
        intervalStateCid <- create this with reimbursementConfirmation = Some reimbursementConfirmation
        pure ReimbursementIntervalState_ConfirmReimbursementResult with
          intervalStateCid

    choice ReimbursementIntervalState_ReimburseResponses
      : ReimbursementIntervalState_ReimburseResponsesResult
      with
        responseTrafficData : ResponseTrafficData
      controller dso
      do
        case reimbursementConfirmation of
          None -> abort "Response traffic reimbursement hash not yet been confirmed"
          Some confirmation -> do
            let actualHash = hash responseTrafficData
            let expectedHash = confirmation.responseTrafficDataHash
            unless (actualHash == expectedHash) $
                abort $ T.unwords ["Response traffic data hash", actualHash.value, "does not match expected hash", expectedHash.value]
            forA_ responseTrafficData.responseTrafficTotals \(ResponseTrafficTotal with memberId, totalTraffic) ->
              create MemberTraffic with
                dso = dso
                memberId
                synchronizerId = confirmation.synchronizerId
                migrationId = confirmation.migrationId
                totalReimbursed = Some totalTraffic
                -- Set these fields to reflect that this reimbursement is not a traffic purchase.
                -- Thereby the aggregation in AmuletRules_MergeMemberTrafficContracts works correctly.
                totalPurchased = 0
                amuletSpent = 0.0
                usdSpent = 0.0
                numPurchases = 0

            -- Note: we intentionally do not return the created MemberTraffic contract IDs here
            -- to avoid bloating the transaction size on the Ledger API.
            pure ReimbursementIntervalState_ReimburseResponsesResult with
              dummy = ()

data ReimbursementIntervalState_ConfirmReimbursementResult = ReimbursementIntervalState_ConfirmReimbursementResult with
    intervalStateCid : ContractId ReimbursementIntervalState
  deriving (Eq, Show)

data ReimbursementIntervalState_ReimburseResponsesResult = ReimbursementIntervalState_ReimburseResponsesResult with
    dummy : ()
  deriving (Eq, Show)


{-
confirmResponseTrafficReimbursement : Party -> ReimbursementConfirmation -> ContractId ReimbursementIntervalState -> Update (ContractId ReimbursementIntervalState)
confirmResponseTrafficReimbursement dso reimbursementConfirmation intervalStateCid = do
  require "Not yet confirmed" (isNone this.reimbursementConfirmation)
  intervalStateCid <- create this with reimbursementConfirmation = Some reimbursementConfirmation
  pure ReimbursementIntervalState_ConfirmReimbursementResult with
    intervalStateCid
-}


-- Checked fetch
----------------

instance HasCheckedFetch ReimbursementWorkflowState ForDso where
  contractGroupId ReimbursementWorkflowState {..} = ForDso with dso

instance HasCheckedFetch ReimbursementIntervalState ForDso where
  contractGroupId ReimbursementIntervalState {..} = ForDso with dso


-- Hashing instances
--------------------

instance Hashable ResponseTrafficData where
  hash (ResponseTrafficData with responseTrafficTotals) =
    hashRecord [hash responseTrafficTotals]

instance Hashable ResponseTrafficTotal where
  hash (ResponseTrafficTotal with memberId, totalTraffic) =
    hashRecord [hash memberId, hash totalTraffic]
