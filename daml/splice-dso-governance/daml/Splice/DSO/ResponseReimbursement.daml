-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | All the response reimbursement workflows code that does not depend on `DsoRules`.
module Splice.DSO.ResponseReimbursement where

import DA.Action
import DA.Foldable (forA_)
import DA.Optional
import DA.Text qualified as T

import Splice.DecentralizedSynchronizer
import Splice.Util
import Splice.DSO.CryptoHash




-- TODO: consider using a fixed one nibble sharding prefix as that gives a 16x
-- tx size reduction while being cheap to implement due to not being
-- configurable.





-- State of the overall reimbursement workflow.
-----------------------------------------------

data ReimbursementInterval = ReimbursementInterval with
    startExclusive : Time
    endInclusive : Time
  deriving (Eq, Show)

-- | The top-level state of the reimbursement workflow. We expect there to be exactly one
-- such contract per DSO.
template ReimbursementWorkflowState
  with
    dso: Party
    nextIntervalStart: Time
  where
    signatory dso

    choice ReimbursementWorkflowState_AddReimbursementInterval
      : ReimbursementWorkflowState_AddReimbursementIntervalResult
      with
        nextIntervalEnd : Time
      controller dso
      do
        require "Positive interval" (this.nextIntervalStart < nextIntervalEnd)
        -- Note: additional constraints to ensure that the intervals are large
        -- enough, and do not advance too quickly are enforced as part of the
        -- DsoRules.
        intervalStateCid <- create ReimbursementIntervalState with
          dso = dso
          interval = ReimbursementInterval with
            startExclusive = this.nextIntervalStart
            endInclusive = nextIntervalEnd
          reimbursementConfirmation = None
        workflowStateCid <- create this with
          nextIntervalStart = nextIntervalEnd
        pure ReimbursementWorkflowState_AddReimbursementIntervalResult with
          intervalStateCid
          workflowStateCid


data ReimbursementWorkflowState_AddReimbursementIntervalResult = ReimbursementWorkflowState_AddReimbursementIntervalResult with
    intervalStateCid : ContractId ReimbursementIntervalState
    workflowStateCid : ContractId ReimbursementWorkflowState
  deriving (Eq, Show)


-- State of reimbursing responses for a given interval.
-------------------------------------------------------

data ReimbursementConfirmation = ReimbursementConfirmation with
    synchronizerId : Text -- ^ Synchronizer on which the responses should be reimbursed. Always set to the global synchronizer-id.
    migrationId : Int -- ^ Migration id on which the responses should be reimbursed. Always set to the latest migration id.
    responseTrafficDataHash : Hash
  deriving (Eq, Show)

data ResponseTrafficData = ResponseTrafficData with
    responseTrafficTotals : [ResponseTrafficTotal]
  deriving (Eq, Show)

data ResponseTrafficTotal = ResponseTrafficTotal with
    memberId : Text
    totalTraffic : Int
  deriving (Eq, Show)


template ReimbursementIntervalState
  with
    dso: Party
    interval: ReimbursementInterval
    reimbursementConfirmation : Optional ReimbursementConfirmation
  where
    signatory dso

    choice ReimbursementIntervalState_ConfirmReimbursement
      : ReimbursementIntervalState_ConfirmReimbursementResult
      with
        reimbursementConfirmation : ReimbursementConfirmation
      controller dso
      do
        require "Not yet confirmed" (isNone this.reimbursementConfirmation)
        intervalStateCid <- create this with reimbursementConfirmation = Some reimbursementConfirmation
        pure ReimbursementIntervalState_ConfirmReimbursementResult with
          intervalStateCid

    choice ReimbursementIntervalState_ReimburseResponses
      : ReimbursementIntervalState_ReimburseResponsesResult
      with
        responseTrafficData : ResponseTrafficData
      controller dso
      do
        case reimbursementConfirmation of
          None -> abort "Response traffic reimbursement hash not yet been confirmed"
          Some confirmation -> do
            let actualHash = hash responseTrafficData
            let expectedHash = confirmation.responseTrafficDataHash
            unless (actualHash == expectedHash) $
                abort $ T.unwords ["Response traffic data hash", actualHash.value, "does not match expected hash", expectedHash.value]
            forA_ responseTrafficData.responseTrafficTotals \(ResponseTrafficTotal with memberId, totalTraffic) ->
              create MemberTraffic with
                dso = dso
                memberId
                synchronizerId = confirmation.synchronizerId
                migrationId = confirmation.migrationId
                totalReimbursed = Some totalTraffic
                -- Set these fields to reflect that this reimbursement is not a traffic purchase.
                -- Thereby the aggregation in AmuletRules_MergeMemberTrafficContracts works correctly.
                totalPurchased = 0
                amuletSpent = 0.0
                usdSpent = 0.0
                numPurchases = 0

            -- Note: we intentionally do not return the created MemberTraffic contract IDs here
            -- to avoid bloating the transaction size on the Ledger API.
            pure ReimbursementIntervalState_ReimburseResponsesResult with
              dummy = ()

data ReimbursementIntervalState_ConfirmReimbursementResult = ReimbursementIntervalState_ConfirmReimbursementResult with
    intervalStateCid : ContractId ReimbursementIntervalState
  deriving (Eq, Show)

data ReimbursementIntervalState_ReimburseResponsesResult = ReimbursementIntervalState_ReimburseResponsesResult with
    dummy : ()
  deriving (Eq, Show)




-- Hashing instances
--------------------

instance Hashable ResponseTrafficData where
  hash (ResponseTrafficData with responseTrafficTotals) =
    hashRecord [hash responseTrafficTotals]

instance Hashable ResponseTrafficTotal where
  hash (ResponseTrafficTotal with memberId, totalTraffic) =
    hashRecord [hash memberId, hash totalTraffic]
