-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | All the response reimbursement workflows code that does not depend on `DsoRules`.
module Splice.DSO.ResponseReimbursement where

import DA.Action
import DA.Foldable (forA_)
import DA.Optional
import DA.Text qualified as T

import Splice.DecentralizedSynchronizer
import Splice.Util
import Splice.DSO.CryptoHash




-- TODO: consider using a fixed one nibble sharding prefix as that gives a 16x
-- tx size reduction while being cheap to implement due to not being
-- configurable.


-- TODO: add contract that makes it easy to test the hashing of the responseTrafficDataHash


-- State of the overall reimbursement workflow.
-----------------------------------------------

data ReimbursementInterval = ReimbursementInterval with
    startExclusive : Time
    endInclusive : Time
  deriving (Eq, Show)

-- | The top-level state of the reimbursement workflow. We expect there to be exactly one
-- such contract per DSO.
template ReimbursementWorkflowState
  with
    dso: Party
    earliestIntervalStart: Time
      -- ^ The start time of the earliest interval that is still being processed.
    nextIntervalStart: Time
  where
    signatory dso


data ReimbursementWorkflowState_AddReimbursementIntervalResult = ReimbursementWorkflowState_AddReimbursementIntervalResult with
    intervalStateCid : ContractId ReimbursementIntervalState
    workflowStateCid : ContractId ReimbursementWorkflowState
  deriving (Eq, Show)


addReimbursementInterval : Party -> RelTime -> ContractId ReimbursementWorkflowState -> Time -> Update (ContractId ReimbursementIntervalState, ContractId ReimbursementWorkflowState)
addReimbursementInterval dso minIntervalDuration workflowStateCid nextIntervalEnd = do
  workflowState <- fetchAndArchive (ForDso dso) workflowStateCid
  -- ensure minimal duration
  let intervalDuration = nextIntervalEnd `subTime` workflowState.nextIntervalStart
  require "Minimal interval duration" (intervalDuration >= minIntervalDuration)
  -- ensure that intervals are added at most `minIntervalDuration` ahead of time
  let backdatedStart = workflowState.nextIntervalStart `addRelTime` (negate minIntervalDuration)
  assertDeadlineExceeded "nextIntervalStart - minIntervalDuration" backdatedStart

  intervalStateCid <- create ReimbursementIntervalState with
    dso = dso
    interval = ReimbursementInterval with
      startExclusive = workflowState.nextIntervalStart
      endInclusive = nextIntervalEnd
    reimbursementConfirmation = None
  workflowStateCid <- create workflowState with
    nextIntervalStart = nextIntervalEnd
  pure (intervalStateCid, workflowStateCid)



-- State of reimbursing responses for a given interval.
-------------------------------------------------------

data ReimbursementConfirmation = ReimbursementConfirmation with
    synchronizerId : Text -- ^ Synchronizer on which the responses should be reimbursed. Always set to the global synchronizer-id.
    migrationId : Int -- ^ Migration id on which the responses should be reimbursed. Always set to the latest migration id.
    responseTrafficDataHash : Hash
  deriving (Eq, Show)

data ResponseTrafficData = ResponseTrafficData with
    responseTrafficTotals : [ResponseTrafficTotal]
  deriving (Eq, Show)

data ResponseTrafficTotal = ResponseTrafficTotal with
    memberId : Text
    totalTraffic : Int
  deriving (Eq, Show)


template ReimbursementIntervalState
  with
    dso: Party
    interval: ReimbursementInterval
    reimbursementConfirmation : Optional ReimbursementConfirmation
  where
    signatory dso

    choice ReimbursementIntervalState_ConfirmReimbursement
      : ReimbursementIntervalState_ConfirmReimbursementResult
      with
        reimbursementConfirmation : ReimbursementConfirmation
      controller dso
      do
        require "Not yet confirmed" (isNone this.reimbursementConfirmation)
        intervalStateCid <- create this with reimbursementConfirmation = Some reimbursementConfirmation
        pure ReimbursementIntervalState_ConfirmReimbursementResult with
          intervalStateCid

    choice ReimbursementIntervalState_ReimburseResponses
      : ReimbursementIntervalState_ReimburseResponsesResult
      with
        responseTrafficData : ResponseTrafficData
      controller dso
      do
        case reimbursementConfirmation of
          None -> abort "Response traffic reimbursement hash not yet been confirmed"
          Some confirmation -> do
            let actualHash = hash responseTrafficData
            let expectedHash = confirmation.responseTrafficDataHash
            unless (actualHash == expectedHash) $
                abort $ T.unwords ["Response traffic data hash", actualHash.value, "does not match expected hash", expectedHash.value]
            forA_ responseTrafficData.responseTrafficTotals \(ResponseTrafficTotal with memberId, totalTraffic) ->
              create MemberTraffic with
                dso = dso
                memberId
                synchronizerId = confirmation.synchronizerId
                migrationId = confirmation.migrationId
                totalReimbursed = Some totalTraffic
                -- Set these fields to reflect that this reimbursement is not a traffic purchase.
                -- Thereby the aggregation in AmuletRules_MergeMemberTrafficContracts works correctly.
                totalPurchased = 0
                amuletSpent = 0.0
                usdSpent = 0.0
                numPurchases = 0

            -- Note: we intentionally do not return the created MemberTraffic contract IDs here
            -- to avoid bloating the transaction size on the Ledger API.
            pure ReimbursementIntervalState_ReimburseResponsesResult with
              dummy = ()

data ReimbursementIntervalState_ConfirmReimbursementResult = ReimbursementIntervalState_ConfirmReimbursementResult with
    intervalStateCid : ContractId ReimbursementIntervalState
  deriving (Eq, Show)

data ReimbursementIntervalState_ReimburseResponsesResult = ReimbursementIntervalState_ReimburseResponsesResult with
    dummy : ()
  deriving (Eq, Show)


confirmResponseTrafficReimbursement : Party -> ReimbursementConfirmation -> ContractId ReimbursementIntervalState -> Update (ContractId ReimbursementIntervalState)
confirmResponseTrafficReimbursement dso reimbursementConfirmation intervalStateCid = do
  require "Not yet confirmed" (isNone this.reimbursementConfirmation)
  intervalStateCid <- create this with reimbursementConfirmation = Some reimbursementConfirmation
  pure ReimbursementIntervalState_ConfirmReimbursementResult with
    intervalStateCid


-- Hashing instances
--------------------

instance Hashable ResponseTrafficData where
  hash (ResponseTrafficData with responseTrafficTotals) =
    hashRecord [hash responseTrafficTotals]

instance Hashable ResponseTrafficTotal where
  hash (ResponseTrafficTotal with memberId, totalTraffic) =
    hashRecord [hash memberId, hash totalTraffic]
