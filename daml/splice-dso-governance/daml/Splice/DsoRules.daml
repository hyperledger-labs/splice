-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE MultiWayIf #-}
module Splice.DsoRules where

import Prelude hiding (all)
import DA.Action (void, unless)
import DA.Assert
import DA.Either (partitionEithers)
import DA.Exception
import DA.Foldable (forA_, all)
import DA.List as List hiding (all)
import DA.Optional (isNone, fromSome, fromOptional, isSome)
import qualified DA.Map as Map
import qualified DA.Set as Set
import qualified DA.Text as T
import DA.Time

import Splice.Amulet
import Splice.AmuletRules
import Splice.ExternalPartyAmuletRules

import Splice.Round
import Splice.Types
import Splice.ValidatorLicense
import Splice.Wallet.Subscriptions
import Splice.DecentralizedSynchronizer (MemberTraffic)

import qualified Splice.CometBft as CometBft
import Splice.Ans
import Splice.SvOnboarding
import Splice.DSO.AmuletPrice
import Splice.DSO.DecentralizedSynchronizer
import Splice.DSO.SvState
import Splice.Schedule
import Splice.Util
import Splice.CometBft()


-- Types
---------

-- | Actions that require confirmation from SV nodes before they can be executed.
--
-- There are two processes for executing such actions:
-- 1. Any SV can request a vote to execute such an action upon which the other SV's
--    can respond with their votes for whether they accept the execution or not.
--    This process requires votes from 2/3 of all SVs* for the action to be considered definitive
--    and it can be used for all actions that require confirmation.
-- 2. Some of the actions that require confirmations should be executed automatically
--    once the ledger and the wall-clocks of the SV nodes are in a particular state.
--    These actions are confirmed by each SV node automatically once the action's precondition is met.
--    Once 2/3 of all SV's confirmations* are visible to the DSO delegate it executes them.
--
-- * Simplified for clarity; see `requiredNumVotes` for exact formula.
--
-- Process 2 is an optimization of Process 1 for the case where no disagreement to the
-- action is expected.
--
-- We expect honest SV nodes to only create confirmations for actions
-- whose preconditions are met. We also rely on the execution of these actions to be
-- idempotent, as more than the required number of confirmations can be created.
--
-- Note also that having these two processes also aids in distinguishing between manually initiated
-- ad-hoc votes and the regular confirmations that need to happen during standard DSO.
data ActionRequiringConfirmation
  = ARC_DsoRules with
      dsoAction : DsoRules_ActionRequiringConfirmation
  | ARC_AmuletRules with
      amuletRulesAction : AmuletRules_ActionRequiringConfirmation
  | ARC_AnsEntryContext with
      ansEntryContextCid : ContractId AnsEntryContext
      ansEntryContextAction : AnsEntryContext_ActionRequiringConfirmation
  | ExtActionRequiringConformation with
      dummyUnitField : ()
        -- ^ Extension constructor (and field) to work around the current lack of upgrading for variants in Daml 3.0
        -- This on takes care of providing extensibility for the specific variants below.
  deriving (Eq, Show)

data AmuletRules_ActionRequiringConfirmation
  = CRARC_MiningRound_StartIssuing AmuletRules_MiningRound_StartIssuing
    -- ^ Automated action to start an issuing round once the summary of the reward coupons have been computed.
  | CRARC_MiningRound_Archive AmuletRules_MiningRound_Archive
    -- ^ Automated action to archive a closed mining round once no expired reward coupons are left.
  | CRARC_AddFutureAmuletConfigSchedule AmuletRules_AddFutureAmuletConfigSchedule
    -- ^ **Deprecated, use CRARC_SetConfig instead**: Voted action to add a config schedule to the `AmuletRules`.
  | CRARC_RemoveFutureAmuletConfigSchedule AmuletRules_RemoveFutureAmuletConfigSchedule
    -- ^ **Deprecated, use CRARC_SetConfig instead**: Voted action to remove a config schedule from the `AmuletRules`.
  | CRARC_UpdateFutureAmuletConfigSchedule AmuletRules_UpdateFutureAmuletConfigSchedule
    -- ^ **Deprecated, use CRARC_SetConfig instead**: Voted action to update a config schedule in the `AmuletRules`.
  | CRARC_SetConfig AmuletRules_SetConfig
    -- ^ Voted action to change the `AmuletConfig`. Not idempotent.
  deriving (Eq, Show)

data DsoRules_ActionRequiringConfirmation
  = SRARC_AddSv DsoRules_AddSv
    -- ^ Voted action to directly add an SV
  | SRARC_OffboardSv DsoRules_OffboardSv
    -- ^ Voted action to remove an SV
  | SRARC_ConfirmSvOnboarding DsoRules_ConfirmSvOnboarding
    -- ^ Automated action to confirm that a party can become an SV.
  | SRARC_GrantFeaturedAppRight DsoRules_GrantFeaturedAppRight
    -- ^ Voted action to grant a featured app right. Not idempotent.
  | SRARC_RevokeFeaturedAppRight DsoRules_RevokeFeaturedAppRight
    -- ^ Revoke a specific featured app right.
  | SRARC_SetConfig DsoRules_SetConfig
    -- ^ Voted action to change the `DsoRulesConfig`. Not idempotent.
  | SRARC_UpdateSvRewardWeight DsoRules_UpdateSvRewardWeight
    -- ^ Voted action to update the reward weight of an SV.
  | SRARC_CreateExternalPartyAmuletRules DsoRules_CreateExternalPartyAmuletRules
    -- ^ Create ExternalPartyAmuletRules contract if it has not been created as part of network bootstrapping.
  | SRARC_CreateTransferCommandCounter DsoRules_CreateTransferCommandCounter
    -- ^ Create TransferCommandCounter contract for the given sender if it does not already exist
  | SRARC_CreateUnallocatedUnclaimedActivityRecord DsoRules_CreateUnallocatedUnclaimedActivityRecord
    -- ^ Voted action to create an UnallocatedUnclaimedActivityRecord contract.
  deriving (Eq, Show)

data AnsEntryContext_ActionRequiringConfirmation
  = ANSRARC_CollectInitialEntryPayment AnsEntryContext_CollectInitialEntryPayment
    -- ^ Automated action to collect initial payment of an ans entry.
  | ANSRARC_RejectEntryInitialPayment AnsEntryContext_RejectEntryInitialPayment
    -- ^ Automated action to reject initial payment of an ans entry.
  deriving (Eq, Show)

-- | Information about SVs relevant to DSO governance.
data SvInfo = SvInfo with
    name : Text -- ^ Human-readable name; must be unique.
    joinedAsOfRound : Round -- ^ Round in which the SV joined
    svRewardWeight : Int -- ^ Weight of the SV in the SV reward distribution.
    participantId : Text -- ^ Participant ID of the SV, stored here as PartyToParticipant mappings are tracked via state on the DsoRules + SvOnboardingConfirmed contracts.
  deriving (Eq, Show)

-- | Information about offboarded svs
data OffboardedSvInfo = OffboardedSvInfo with
    name : Text -- ^ Human-readable name; must be unique.
    participantId : Text -- ^ Participant ID of the offboarded SV.
  deriving (Eq, Show)

data DsoSummary = DsoSummary with
    dsoDelegate : Party
      -- ^ __Deprecated__ in favor of delegateless automation.
    numSvs : Int
    requiredNumVotes : Int
      -- ^ The number of votes required for considering a confirmation, or a request for a vote
  deriving (Eq, Show)

-- | Choice return types
-------------------------
-- In order to support upgrades of the Daml models, all choices should return records, which can
-- then be extended in future versions.

data Confirmation_ExpireResult = Confirmation_ExpireResult

data DsoRules_AddSvResult = DsoRules_AddSvResult with
    newDsoRules : ContractId DsoRules

data DsoRules_OffboardSvResult = DsoRules_OffboardSvResult with
    newDsoRules : ContractId DsoRules

data DsoRules_SubmitStatusReportResult = DsoRules_SubmitStatusReportResult with
    newReport : ContractId SvStatusReport

data DsoRules_AddConfirmedSvResult = DsoRules_AddConfirmedSvResult with
    newDsoRules : ContractId DsoRules

data DsoRules_SetSynchronizerNodeConfigResult = DsoRules_SetSynchronizerNodeConfigResult with
    svNodeState : ContractId SvNodeState

data DsoRules_RequestElectionResult = DsoRules_RequestElectionResult with
    electionRequestCid : ContractId ElectionRequest

data DsoRules_ElectDsoDelegateResult = DsoRules_ElectDsoDelegateResult with
    newDsoRules : ContractId DsoRules

data DsoRules_ArchiveOutdatedElectionRequestResult = DsoRules_ArchiveOutdatedElectionRequestResult

data DsoRules_ConfirmActionResult = DsoRules_ConfirmActionResult with
    confirmation : ContractId Confirmation

data DsoRules_ExecuteConfirmedActionResult = DsoRules_ExecuteConfirmedActionResult

data DsoRules_ExpireStaleConfirmationResult = DsoRules_ExpireStaleConfirmationResult

data DsoRules_RequestVoteResult = DsoRules_RequestVoteResult with
    voteRequest : ContractId VoteRequest

data DsoRules_CastVoteResult = DsoRules_CastVoteResult with
    voteRequest : ContractId VoteRequest

data DsoRules_UpdateAmuletPriceVoteResult = DsoRules_UpdateAmuletPriceVoteResult with
    amuletPriceVote : ContractId AmuletPriceVote

data DsoRules_GarbageCollectAmuletPriceVotesResult = DsoRules_GarbageCollectAmuletPriceVotesResult

data DsoRules_SetConfigResult = DsoRules_SetConfigResult with
    newDsoRules : ContractId DsoRules

data DsoRules_UpdateSvRewardWeightResult = DsoRules_UpdateSvRewardWeightResult with
    newDsoRules : ContractId DsoRules

data DsoRules_GrantFeaturedAppRightResult = DsoRules_GrantFeaturedAppRightResult with
    featuredAppRight : ContractId FeaturedAppRight

data DsoRules_RevokeFeaturedAppRightResult = DsoRules_RevokeFeaturedAppRightResult

data DsoRules_OnboardValidatorResult = DsoRules_OnboardValidatorResult with
    validatorLicense : ContractId ValidatorLicense

data DsoRules_MergeValidatorLicenseResult = DsoRules_MergeValidatorLicenseResult with
    validatorLicense : ContractId ValidatorLicense

data DsoRules_StartSvOnboardingResult = DsoRules_StartSvOnboardingResult with
    onboardingRequest : ContractId SvOnboardingRequest

data DsoRules_ExpireSvOnboardingRequestResult = DsoRules_ExpireSvOnboardingRequestResult

data DsoRules_ArchiveSvOnboardingRequestResult = DsoRules_ArchiveSvOnboardingRequestResult

data DsoRules_ConfirmSvOnboardingResult = DsoRules_ConfirmSvOnboardingResult with
    onboardingConfirmed : ContractId SvOnboardingConfirmed

data DsoRules_ExpireSvOnboardingConfirmedResult = DsoRules_ExpireSvOnboardingConfirmedResult with
    newDsoRules : ContractId DsoRules

data DsoRules_Amulet_ExpireResult = DsoRules_Amulet_ExpireResult with
    expireSum : AmuletExpireSummary

data DsoRules_LockedAmulet_ExpireAmuletResult = DsoRules_LockedAmulet_ExpireAmuletResult with
    expireSum : AmuletExpireSummary

data DsoRules_AdvanceOpenMiningRoundsResult = DsoRules_AdvanceOpenMiningRoundsResult with
    summarizingRound: ContractId SummarizingMiningRound
    openRound : ContractId OpenMiningRound

data DsoRules_CollectEntryRenewalPaymentResult = DsoRules_CollectEntryRenewalPaymentResult with
    ansEntry : ContractId AnsEntry
    subscriptionState : ContractId SubscriptionIdleState

data DsoRules_ExpireAnsEntryResult = DsoRules_ExpireAnsEntryResult

data DsoRules_ExpireSubscriptionResult = DsoRules_ExpireSubscriptionResult

data DsoRules_TerminateSubscriptionResult = DsoRules_TerminateSubscriptionResult

data DsoRules_ReceiveSvRewardCouponResult = DsoRules_ReceiveSvRewardCouponResult with
    svRewardState : ContractId SvRewardState
    svRewardCoupons : [ContractId SvRewardCoupon]

data DsoRules_ClaimExpiredRewardsResult = DsoRules_ClaimExpiredRewardsResult with
    unclaimedReward: Optional (ContractId UnclaimedReward)

data DsoRules_MergeUnclaimedRewardsResult = DsoRules_MergeUnclaimedRewardsResult with
    unclaimedReward: ContractId UnclaimedReward

data DsoRules_MiningRound_CloseResult = DsoRules_MiningRound_CloseResult with
    closedRound : ContractId ClosedMiningRound

data DsoRules_MergeMemberTrafficContractsResult = DsoRules_MergeMemberTrafficContractsResult with
    memberTraffic : ContractId MemberTraffic

data DsoRules_MergeSvRewardStateResult = DsoRules_MergeSvRewardStateResult with
    svRewardState : ContractId SvRewardState

data DsoRules_PruneAmuletConfigScheduleResult = DsoRules_PruneAmuletConfigScheduleResult with
    amuletRulesCid : ContractId AmuletRules

data DsoRules_CreateExternalPartyAmuletRulesResult = DsoRules_CreateExternalPartyAmuletRulesResult
  with
    externalPartyAmuletRulesCid : ContractId ExternalPartyAmuletRules
  deriving (Show, Eq)

data DsoRules_CreateTransferCommandCounterResult = DsoRules_CreateTransferCommandCounterResult
  with
    transferCommandCounterCid : ContractId TransferCommandCounter
  deriving (Show, Eq)

data DsoRules_ExpireTransferPreapprovalResult = DsoRules_ExpireTransferPreapprovalResult
  deriving (Show, Eq)

data DsoRules_AmuletRules_ConvertFeaturedAppActivityMarkersResult = DsoRules_AmuletRules_ConvertFeaturedAppActivityMarkersResult
  with
    result : AmuletRules_ConvertFeaturedAppActivityMarkersResult

data DsoRules_CreateUnallocatedUnclaimedActivityRecordResult = DsoRules_CreateUnallocatedUnclaimedActivityRecordResult with
    unallocatedUnclaimedActivityRecordCid : ContractId UnallocatedUnclaimedActivityRecord

data DsoRules_AllocateUnallocatedUnclaimedActivityRecordResult = DsoRules_AllocateUnallocatedUnclaimedActivityRecordResult with
    unclaimedActivityRecordCid : ContractId UnclaimedActivityRecord
    optUnclaimedRewardCid : Optional (ContractId UnclaimedReward)

data DsoRules_ExpireUnallocatedUnclaimedActivityRecordResult = DsoRules_ExpireUnallocatedUnclaimedActivityRecordResult

data DsoRules_ExpireUnclaimedActivityRecordResult = DsoRules_ExpireUnclaimedActivityRecordResult with
    unclaimedRewardCid : ContractId UnclaimedReward


-- Workflow templates
---------------------

-- | __Deprecated__ in favor of delegateless automation.
data ElectionRequestReason
  = ERR_DsoDelegateUnavailable
  | ERR_OtherReason Text
  | ExtElectionRequestReason with
      dummyUnitField : ()
        -- ^ Extension constructor (and field) to work around the current lack of upgrading for variants in Daml 3.0
  deriving (Eq, Ord, Show)

-- | __Deprecated__ in favor of delegateless automation.
--
-- A request to elect a new DSO delegate.
template ElectionRequest with
    dso : Party
    requester : Party
    epoch : Int  -- current epoch whose DSO delegate should be replaced
    reason : ElectionRequestReason -- reason for electing a new DSO delegate
    ranking : [Party] -- preference ranking for new DSO delegates
  where
    -- NOTE: we expect the requester to observe this contract by hosting the
    -- DSO party (as all SVs do). The requester can in
    -- particular not be a signatory, as otherwise fetching and archiving of
    -- the request would require the requesters confirmation instead of only
    -- the confirmation of the DSO party.
    signatory dso


-- | A confirmation for the SVs to take action as part of standard DSO.
-- Used for executing automated actions in a shortened process.
-- See the comments on `ActionRequiringConfirmation` for details.
template Confirmation with
    dso : Party
    confirmer : Party
    action : ActionRequiringConfirmation
    expiresAt : Time
  where
    signatory dso

    choice Confirmation_Expire : Confirmation_ExpireResult
      controller dso
      do assertDeadlineExceeded "expiresAt" expiresAt
         return Confirmation_ExpireResult

-- | A request for the other svs to vote on the execution of an action requiring confirmation.
-- We use this for implementing on-ledger governance actions triggered by SV operators in a uniform way.
--
-- See the comments on `ActionRequiringConfirmation` for details.
--
-- Version 3, which introduces effectivity in vote request.
template VoteRequest
  with
    dso : Party
    requester : Text
      -- ^ The SV that requested to execute the action.
    action : ActionRequiringConfirmation
      -- ^ The action whose confirmation is required.
    reason : Reason
      -- ^ The reason for requesting the execution of the action. Typically a reference to some off-ledger justification.
    voteBefore : Time
      -- ^ The time before which votes are accepted, and SHOULD be submitted.
    votes : Map.Map Text Vote
      -- ^ The votes cast by current or previous SVs. These may be previous SVs in case
      -- there was an SV change after the vote was requested.
    trackingCid : Optional (ContractId VoteRequest)
      -- ^ An optional tracking ContractId to be used for tracking the vote request through its updates.
      -- This is always set to the first ContractId of the original vote request (None on creation).
    targetEffectiveAt : Optional Time
      -- ^ The time when the action is targeted to be made effective. If None, the action is immediately effective upon 2/3 votes in favor.
  where
    ensure all (voteBefore <=) targetEffectiveAt
    signatory dso

data DsoRules_CloseVoteRequestResult = DsoRules_CloseVoteRequestResult with
    request : VoteRequest -- ^ The original vote request.
    completedAt : Time -- ^ When the vote request was completed.
    offboardedVoters : [Text] -- ^ SVs that voted but were offboarded before the vote completed.
    abstainingSvs : [Text] -- ^ SVs that did not vote.
    outcome : VoteRequestOutcome  -- ^ The final result of the vote.
  deriving (Eq, Show)

data VoteRequestOutcome
  = VRO_AcceptedButActionFailed with
      description : Text -- ^ Description of the failure.
  | VRO_Accepted with -- The action was accepted by a super-majority.
      effectiveAt : Time -- ^ Time when the action will be effective.
  | VRO_Rejected  -- The action was rejected by a super-majority.
  | VRO_Expired   -- The action was neither accepted nor rejected by a super-majority during the voting period.
  | ExtVoteRequestOutcome with
      dummyUnitField : ()
        --  ^ Extension constructor (and field) to work around the current lack of upgrading for variants in Daml 3.0
  deriving (Eq, Show)
--
-- | A vote cast by an SV.
data Vote = Vote with
    sv : Party -- ^ The SV party used to submit the vote.
    accept : Bool
      -- ^ Whether the responder accepted the request to execute the action or not.
    reason : Reason
      -- ^ The reason for voting this way.
    optCastAt : Optional Time
      -- ^ The time when the vote was cast. Used to rate-limit the casting of votes.
  deriving(Eq, Show)

data Reason = Reason with
    url : Text -- ^ Url pointing to additional background on the reason, e.g., using a https://w3c-ccg.github.io/hashlink/
    body : Text -- ^ Freeform text intended for human consumption.
  deriving (Eq, Show)


data DsoRulesConfig = DsoRulesConfig with
    numUnclaimedRewardsThreshold : Int -- ^ The minimum number of unclaimed rewards required for merging
    numMemberTrafficContractsThreshold : Int -- ^ The minimum number of member traffic contracts required for merging
    actionConfirmationTimeout : RelTime -- ^ The TTL for contracts representing a confirmation
    svOnboardingRequestTimeout : RelTime -- ^ The TTL for contracts representing an incomplete onboarding
    svOnboardingConfirmedTimeout : RelTime -- ^ The TTL for contracts representing an SV confirmation
    voteRequestTimeout : RelTime  -- ^ The TTL for a `VoteRequest` and its associated `Vote` s
    dsoDelegateInactiveTimeout: RelTime -- ^ The amount of time given to the DSO delegate to complete an action it should take care of
      -- ^ __Deprecated__ in favor of delegateless automation.
    synchronizerNodeConfigLimits : SynchronizerNodeConfigLimits  -- ^ Limits to enforce on the svs' `SynchronizerNodeConfig`
    maxTextLength : Int -- ^ Generic upper limit on text fields in choices and contracts.
    decentralizedSynchronizer : DsoDecentralizedSynchronizerConfig
    nextScheduledSynchronizerUpgrade: Optional SynchronizerUpgradeSchedule
    voteCooldownTime : Optional RelTime -- ^ The minimum time between two votes by the same SV.
  deriving (Eq, Show)

-- | Read the `voteCooldownTime` from the `DsoRulesConfig` with a default value of 1 minute.
getVoteCooldownTime : DsoRulesConfig -> RelTime
getVoteCooldownTime config = fromOptional (minutes 1) config.voteCooldownTime

data SynchronizerUpgradeSchedule = SynchronizerUpgradeSchedule with
    time : Time
      -- ^ The time at which the migration is scheduled to start.
    migrationId : Int
      -- ^ The incremental integer ID of the migration.
  deriving (Eq, Show)

data TrafficState = TrafficState with
    consumedTraffic: Int -- ^ Bytes of extra traffic consumed before the decentralized synchronizer was bootstrapped.
  deriving (Eq, Show)

template DsoRules with
    dso : Party
    epoch : Int
    svs : Map.Map Party SvInfo
    offboardedSvs : Map.Map Party OffboardedSvInfo
    dsoDelegate : Party
      -- ^ __Deprecated__ in favor of delegateless automation.
    config : DsoRulesConfig
    initialTrafficState: Map.Map Text TrafficState -- ^ Map from participant/mediator ID to its traffic state at the time of synchronizer bootstrapping. Used for testing, empty in prod.
    isDevNet : Bool
  where
    ensure
      config.numUnclaimedRewardsThreshold > 0

    -- NOTE: the svs are not direct signatories as that would not give us the right fault-tolerance wrt
    -- validating choices on this contract. Instead, the svs are indirect signatories by being
    -- hosting the DSO party with confirmation rights.
    signatory dso


    -- Sv management
    ------------------------

    choice DsoRules_AddSv : DsoRules_AddSvResult
      with
        newSvParty : Party
        newSvName : Text
        newSvRewardWeight : Int
        newSvParticipantId : Text
        joinedAsOfRound : Round
      controller dso
      do newDsoRules <- dsoRules_addSv this arg
         return DsoRules_AddSvResult with ..

    choice DsoRules_OffboardSv : DsoRules_OffboardSvResult
      with
        sv : Party
      controller dso
      do
        require "There is more than one sv" (Map.size svs > 1)
        case Map.lookup sv svs of
          None -> fail "Not a sv"
          Some info -> do
            -- NOTE: this immediate deletion will lead to the SV apps of the remaining svs
            -- revoking that sv's rights in the CometBFT network and the topology state.
            let newSvs = Map.delete sv svs
            -- We optimize for prompt removal of a sv if the vote said so.
            -- and instead just choose the sv with the lexicographically smallest name.
            let (newDsoDelegate, newEpoch)
                  | sv == dsoDelegate = (head (Map.keys newSvs), epoch + 1)
                  | otherwise        = (dsoDelegate, epoch)
            let offboardedSvInfo = OffboardedSvInfo with
                    name = info.name
                    participantId = info.participantId
            -- create the new rules contract
            newDsoRules <- create DsoRules with
              dso
              epoch = newEpoch
              dsoDelegate = newDsoDelegate
              svs = newSvs
              offboardedSvs = Map.insert sv offboardedSvInfo offboardedSvs
              config
              initialTrafficState
              isDevNet

            return DsoRules_OffboardSvResult with ..

    -- Update an SV's Status report
    nonconsuming choice DsoRules_SubmitStatusReport : DsoRules_SubmitStatusReportResult
      with
        sv : Party
        previousReportCid : ContractId SvStatusReport
        status : SvStatus
      controller sv
      do
        newReport <- case Map.lookup sv svs of
          None -> fail "SV is not an SV"
          Some info -> do
            previousReport <- fetchAndArchive (ForSvNode with dso; sv; svName = info.name) previousReportCid
            create SvStatusReport with
              dso
              sv
              svName = info.name
              number = previousReport.number + 1
              status = Some status
        return DsoRules_SubmitStatusReportResult with ..

    -- Called by SV candidates to add themselves to the DsoRules once they are confirmed and ready.
    -- We use the passed rounds for reliably determining the earliest open round, which will be
    -- the first round in which the new SV will receive rewards.
    nonconsuming choice DsoRules_AddConfirmedSv : DsoRules_AddConfirmedSvResult
      with
        sv : Party
        svOnboardingConfirmedCid : ContractId SvOnboardingConfirmed
        earliestRoundCid : ContractId OpenMiningRound
        middleRoundCid : ContractId OpenMiningRound
        latestRoundCid : ContractId OpenMiningRound
        amuletRulesCid: ContractId AmuletRules
        -- No longer used, but must be kept for smart-contract upgrading compatibility.
        -- (This was used when the current round number was tracked in the AmuletRules contract.)
      controller sv
      do

        svOnboardingConfirmed <- fetchAndArchive (ForOwner with dso; owner = sv) svOnboardingConfirmedCid
        assertWithinDeadline "svOnboardingConfirmed.expiresAt" svOnboardingConfirmed.expiresAt

        let forDso = ForDso with dso
        earliestRound <- fetchReferenceData forDso earliestRoundCid
        middleRound <- fetchReferenceData forDso middleRoundCid
        latestRound <- fetchReferenceData forDso latestRoundCid
        require "middleRound is one after earliestRound" (middleRound.round.number == earliestRound.round.number + 1)
        require "latestRound is one after middleRound" (latestRound.round.number == middleRound.round.number + 1)

        addSvResult <- exercise self DsoRules_AddSv with
          newSvParty = sv
          newSvName = svOnboardingConfirmed.svName
          newSvRewardWeight = svOnboardingConfirmed.svRewardWeight
          newSvParticipantId = svOnboardingConfirmed.svParticipantId
          joinedAsOfRound = earliestRound.round

        return DsoRules_AddConfirmedSvResult with
          newDsoRules = addSvResult.newDsoRules


    -- Decentralized synchronizer config management
    -----------------------------------

    -- Every SV can change their own synchronizer node's config within the configured limits.
    nonconsuming choice DsoRules_SetSynchronizerNodeConfig : DsoRules_SetSynchronizerNodeConfigResult
      with
        sv : Party
        synchronizerId : Text
        newNodeConfig : SynchronizerNodeConfig
        nodeStateCid : ContractId SvNodeState
      controller sv
      do
        -- check that the synchronizer is known
        require "Synchronizer with this id is configured" (synchronizerId `Map.member` config.decentralizedSynchronizer.synchronizers)
        -- check validity of config and constraint on voting power
        require "Valid configuration" (validSynchronizerNodeConfig config.synchronizerNodeConfigLimits newNodeConfig)
        unless isDevNet $
          require "CometBft voting power <= 1" (CometBft.totalVotingPower newNodeConfig.cometBft <= 1)
        -- update the SV operator node's state
        info <- getSvInfo sv this
        let svName = info.name
        nodeState <- fetchAndArchive (ForSvNode with dso; sv; svName) nodeStateCid
        let state = nodeState.state
        svNodeState <- create nodeState with
          state = state with
            synchronizerNodes = Map.insert synchronizerId newNodeConfig state.synchronizerNodes
        return DsoRules_SetSynchronizerNodeConfigResult with ..


    -- Automation DSO delegate election
    -----------------------------------

    -- __Deprecated__ in favor of delegateless automation.
    nonconsuming choice DsoRules_RequestElection : DsoRules_RequestElectionResult
      with
        requester : Party
        reason: ElectionRequestReason
        ranking : [Party]
      controller requester
      do
        deprecatedChoice "splice-dso-governance" "0.1.17" "DsoRules_RequestElection"

    -- __Deprecated__ in favor of delegateless automation.
    choice DsoRules_ElectDsoDelegate : DsoRules_ElectDsoDelegateResult
      with
        actor : Party
        requestCids : [ContractId ElectionRequest]
      controller actor
      do
        deprecatedChoice "splice-dso-governance" "0.1.17" "DsoRules_ElectDsoDelegate"


    -- __Deprecated__ in favor of delegateless automation.
    -- and checking that there are not too many outdated requests on long-term networks.
    nonconsuming choice DsoRules_ArchiveOutdatedElectionRequest : DsoRules_ArchiveOutdatedElectionRequestResult
      with
        requestCid : ContractId ElectionRequest
        sv : Optional Party
      controller sv
      do
        deprecatedChoice "splice-dso-governance" "0.1.17" "DsoRules_ArchiveOutdatedElectionRequest"


    -- Executing actions with confirmation
    --------------------------------------

    nonconsuming choice DsoRules_ConfirmAction : DsoRules_ConfirmActionResult
      with
        confirmer : Party
        action : ActionRequiringConfirmation
      controller confirmer
      do
        require "Confirmer is an SV" (confirmer `Map.member` svs)
        now <- getTime
        let expiresAt = now `addRelTime` config.actionConfirmationTimeout
        confirmation <- create Confirmation with
          dso
          confirmer
          action
          expiresAt
        return DsoRules_ConfirmActionResult with ..

    nonconsuming choice DsoRules_ExecuteConfirmedAction : DsoRules_ExecuteConfirmedActionResult
      with
        action : ActionRequiringConfirmation
        amuletRulesCid : Optional( ContractId AmuletRules )
        confirmationCids : [ContractId Confirmation]
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        let s = summarizeDso this
        let forDso = ForDso with dso
        require "Enough confirmations" (length confirmationCids >= s.requiredNumVotes)
        confirmers <- forA confirmationCids $ \confirmationCid -> do
          confirmation <- fetchAndArchive forDso confirmationCid
          require "Confirmer is an SV" (confirmation.confirmer `Map.member` svs)
          require "Confirmed action matches" (confirmation.action == action)
          assertWithinDeadline "confirmation.expiresAt" confirmation.expiresAt
          pure confirmation.confirmer
        require "No duplicate confirmers" (unique confirmers)
        executeActionRequiringConfirmation dso self amuletRulesCid action
        return DsoRules_ExecuteConfirmedActionResult


    -- Voting as part of on-ledger governance (version 3)
    -----------------------------------------------------

    -- TODO(#9317): rate limit inidiviual SVs wrt requesting votes
    nonconsuming choice DsoRules_RequestVote : DsoRules_RequestVoteResult
      with
        requester : Party
        action : ActionRequiringConfirmation
        reason : Reason
        voteRequestTimeout : Optional RelTime
        targetEffectiveAt : Optional Time
      controller requester
      do
        requesterName <- case requester `Map.lookup` svs of
          None -> fail "Requester is not an SV"
          Some info -> pure (info.name)
        requireWellformedReason config reason
        now <- getTime
        let voteBefore = case voteRequestTimeout of
              Some value ->
                now `addRelTime` value
              None ->
                now `addRelTime` config.voteRequestTimeout
        require "There is some time to vote" (now < voteBefore)
        let requesterVote = Vote with
              sv = requester
              accept = True
              reason = Reason with url = ""; body = "I accept, as I requested the vote."
              optCastAt = Some now
        voteRequest <- create VoteRequest with
          dso
          requester = requesterName
          action
          reason
          voteBefore
          votes = Map.fromList [(requesterName, requesterVote)]
          trackingCid = None
          targetEffectiveAt
        return DsoRules_RequestVoteResult with ..


    -- Note that this choice can be used to both cast the initial vote, and update a vote.
    nonconsuming choice DsoRules_CastVote : DsoRules_CastVoteResult
      with
        requestCid : ContractId VoteRequest
        vote : Vote
      controller vote.sv
      do
        -- validate vote parameters
        requireWellformedVote config vote
        voterName <- case Map.lookup vote.sv svs of
          None -> fail "Voter is not an SV"
          Some info -> pure info.name
        -- validate and archive request
        request <- fetchAndArchive (ForDso with dso) requestCid
        -- rate limit casting of votes by the same SV to avoid them blocking others from making progress
        -- Note: we currently ignore the optional self-declared vote casting time
        -- `vote.optCastAt`. We'll use that in the future when adding support for larger
        -- prepare-submission delays for external parties.
        enforceCooldown ("voteCooldownTime for " <> partyToText vote.sv) (getVoteCooldownTime config) $ do
          pastVote <- Map.lookup voterName request.votes
          pastVote.optCastAt
        -- store vote
        now <- getTime
        voteRequest <- create request with
          votes = Map.insert voterName (vote with optCastAt = Some now) request.votes
          trackingCid = Some (fromOptional requestCid request.trackingCid)
        return DsoRules_CastVoteResult with ..

    -- We expect the TxHistory log of the SV app to store the choice argument together
    -- with its result for historical reference.
    --
    --  Vote request semantics:
    --
    --  1. For vote requests with effective date-time (targetEffectiveAt != None)
    --    a. Voting Period Starts (now < voteBefore)
    --      -> early closing occurs if a super-majority of SVs rejects the vote request.
    --    b. Voting Period Ends (now >= voteBefore and now < targetEffectiveAt)
    --      -> if a super-majority has voted, the vote request remains open and SVs can still change their votes.
    --      -> otherwise, the vote request is marked as expired.
    --      -> early closing occurs upon a super-majority of rejections after expiration.
    --    c. Effective Date-Time Reached (now >= targetEffectiveAt)
    --      -> if a super-majority still accepts, then the change takes effect
    --      -> otherwise, the vote request is registered as rejected
    --  2. For vote requests without effective date-time (targetEffectiveAt = None)
    --    a. Voting Period Starts (now < voteBefore)
    --      -> early closing when a super-majority rejects
    --      -> early acceptance when a super-majority agrees
    --    b. Voting Period Ends (now >= voteBefore)
    --      -> the vote request gets closed as expired
    --
    nonconsuming choice DsoRules_CloseVoteRequest : DsoRules_CloseVoteRequestResult
      with
        requestCid : ContractId VoteRequest
        amuletRulesCid : Optional (ContractId AmuletRules)
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        now <- getTime

        let s = summarizeDso this
        request <- fetchAndArchive (ForDso with dso) requestCid

        let activeSvs = map (.name) $ Map.values svs

        let activeSvSet = Set.fromList activeSvs
        let (validVotes, offboardedVoters) = partitionEithers
              [ if voterName `Set.member` activeSvSet then Left vote else Right voterName
              | (voterName, vote) <- Map.toList request.votes
              ]
        let abstainingSvs = [ name | name <- activeSvs, not (name `Map.member` request.votes) ]
        let (yays, nays) = partition (.accept) validVotes
        let numYays = length yays
        let numNays = length nays
        let numVotes = numYays + numNays

        outcome <- case request.targetEffectiveAt of

                    Some _ | numNays >= s.requiredNumVotes ->
                      pure $ VRO_Rejected

                    Some _ | now >= request.voteBefore && numVotes < s.requiredNumVotes ->
                      pure $ VRO_Expired

                    Some effectiveTime | now >= effectiveTime && numYays >= s.requiredNumVotes ->
                      try do
                        executeActionRequiringConfirmation dso self amuletRulesCid request.action
                        pure $ VRO_Accepted with
                          effectiveAt = effectiveTime
                      catch
                        (ex : AnyException) ->
                          pure $ VRO_AcceptedButActionFailed with description = message ex

                    Some effectiveTime | now >= effectiveTime ->
                      pure $ VRO_Rejected

                    Some _ ->
                      fail "no definitive outcome for voting request with effectivity"

                    None | numNays >= s.requiredNumVotes ->
                      pure $ VRO_Rejected

                    None | numYays >= s.requiredNumVotes ->
                      try do
                        executeActionRequiringConfirmation dso self amuletRulesCid request.action
                        -- TODO(#16139): Remove Config Schedule from AmuletConfig
                        -- TODO(#16137): Implement effectivity on all actions
                        pure $ VRO_Accepted with
                            effectiveAt = fromOptional now $
                              actionRequiringConfirmationEffectiveAt request.action
                      catch
                        (ex : AnyException) ->
                          pure $ VRO_AcceptedButActionFailed with description = message ex

                    None | now >= request.voteBefore ->
                      pure $ VRO_Expired

                    None -> fail "no definite outcome for voting request without effectivity"

        -- archive vote request if it has a definitive outcome
        pure DsoRules_CloseVoteRequestResult with
            request
            completedAt = now
            offboardedVoters
            abstainingSvs
            outcome


    -- Voting on the amulet price
    ---------------------------

    nonconsuming choice DsoRules_UpdateAmuletPriceVote : DsoRules_UpdateAmuletPriceVoteResult
      with
        sv : Party
        voteCid : ContractId AmuletPriceVote
        amuletPrice : Decimal
      controller sv
      do
        pastVote <- fetchAndArchive (ForOwner with dso; owner = sv) voteCid
        -- rate limit, so that an SV cannot block round advancement by changing their price vote too often
        enforceCooldown ("voteCooldownTime for " <> partyToText sv) (getVoteCooldownTime config) (Some pastVote.lastUpdatedAt)
        now <- getTime
        -- create new vote
        amuletPriceVote <- create AmuletPriceVote with
          dso
          sv
          amuletPrice = Some amuletPrice
          lastUpdatedAt = now
        return DsoRules_UpdateAmuletPriceVoteResult with ..

    nonconsuming choice DsoRules_GarbageCollectAmuletPriceVotes : DsoRules_GarbageCollectAmuletPriceVotesResult
      -- ^ Garbage-collect AmuletPriceVotes from removed svs and duplicate ones that might
      -- happen due to a too quick removal and re-addition of a sv.
      -- We expect this to be run as an OnAssignedContractTrigger for the DsoRules contract.
      --
      -- Note: we do not archive the AmuletPriceVote of an SV on its removal,
      -- as that would allow that SV to block the removal via updating its AmuletPriceVote at the right time.
      --
      -- TODO(#10063): drop this code in favor of just keeping AmuletPriceVotes around.
      with
        nonSvVoteCids : [ContractId AmuletPriceVote]
        duplicateVoteCids : [[ContractId AmuletPriceVote]]
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        let forDso = ForDso with dso
        -- validate and archive non-sv votes
        forA_ nonSvVoteCids $ \voteCid -> do
          vote <- fetchAndArchive forDso voteCid
          require "SV is no sv" (not $ vote.sv `Map.member` svs)
        -- validate and archive duplicates
        forA_ duplicateVoteCids $ \voteCids -> do
          require "Unique references to duplicates" (unique voteCids)
          votes <- forA voteCids $ \voteCid -> do
            -- archival happens below for all but the most recent vote
            vote <- fetchButArchiveLater forDso voteCid
            pure (voteCid, vote)
          -- keep the most recently updated vote to avoid UI glitches
          case sortOn (\(_, vote) -> Down (vote.lastUpdatedAt)) votes of
            [] -> fail "empty list of duplicate votes"
            [_] -> fail "singleton list of duplicate votes"
            ((_, vote)::duplicates) -> do
              require "matching DSO party" (vote.dso == dso)
              require "SV is a sv" (vote.sv `Map.member` svs)
              forA_ duplicates $ \(duplicateCid, duplicate) -> do
                -- safe, as we fetched it before and check the constraints below
                potentiallyUnsafeArchive duplicateCid
                require "matching DSO party" (duplicate.dso == dso)
                require "SV of duplicate matches" (duplicate.sv == vote.sv)
        return DsoRules_GarbageCollectAmuletPriceVotesResult


    -- DSO rules config management
    ------------------------------

    choice DsoRules_SetConfig : DsoRules_SetConfigResult
      with
        newConfig : DsoRulesConfig
        baseConfig: Optional DsoRulesConfig
      controller dso
      do
        -- TODO(M3-57): sanity check the newConfig to avoid locking up operations, e.g., by setting `maxTextLength = -1`
        newDsoRules <- case baseConfig of
          None -> create this with config = newConfig
          Some baseConfig -> do
             create this with config = patch newConfig baseConfig this.config
        return DsoRules_SetConfigResult with ..

    choice DsoRules_UpdateSvRewardWeight : DsoRules_UpdateSvRewardWeightResult
      with
        svParty : Party
        newRewardWeight : Int
      controller dso
      do
        require "New reward weight is positive" (newRewardWeight >= 0)
        case Map.lookup svParty svs of
          None -> fail "SV party is not registered"
          Some sv -> do
            let newSv = sv with svRewardWeight = newRewardWeight
            let newSvs = Map.insert svParty newSv svs
            newDsoRules <- create this with svs = newSvs
            return DsoRules_UpdateSvRewardWeightResult with ..



    -- App rights management
    ------------------------

    nonconsuming choice DsoRules_GrantFeaturedAppRight : DsoRules_GrantFeaturedAppRightResult
      with
        provider : Party
      controller dso
      do
        featuredAppRight <- create FeaturedAppRight with
          dso
          provider
        return DsoRules_GrantFeaturedAppRightResult with ..

    nonconsuming choice DsoRules_RevokeFeaturedAppRight : DsoRules_RevokeFeaturedAppRightResult
      with
        rightCid : ContractId FeaturedAppRight
      controller dso
      do
        void $ fetchChecked (ForDso with dso) rightCid
        exercise rightCid FeaturedAppRight_Withdraw with
          reason = "revoked by governance decision"
        return DsoRules_RevokeFeaturedAppRightResult


    -- Validator onboarding
    -----------------------

    nonconsuming choice DsoRules_OnboardValidator : DsoRules_OnboardValidatorResult
      with
        sponsor : Party
        validator : Party
        version : Optional Text
        contactPoint : Optional Text
      controller sponsor
      do
        require "Sponsor is an SV" (sponsor `Map.member` svs)
        -- create license that records in particular which SV sponsored the onboarding of the validator
        now <- getTime
        validatorLicense <- create ValidatorLicense with
          dso
          sponsor
          validator
          faucetState = None
          metadata = fmap (\version -> ValidatorLicenseMetadata with version; contactPoint = fromOptional "" contactPoint; lastUpdatedAt = now) version
          lastActiveAt = Some now
          weight = None -- An individual SV can only create a license with the default weight.
          kind = None
        return DsoRules_OnboardValidatorResult with ..

    nonconsuming choice DsoRules_MergeValidatorLicense : DsoRules_MergeValidatorLicenseResult
      -- ^ Note: removes the old duplicated licenses and creates a new one with the highest lastReceivedFor round
      -- There should never be duplicates going forward.
      with
        validatorLicenseCids : [ContractId ValidatorLicense]
        sv : Optional Party
      controller sv
      do _ <- getAndValidateSvParty this sv
         require "Number of validatorLicense contracts to merge is >= 2" (length validatorLicenseCids >= 2)
         validatorLicenses <- forA validatorLicenseCids $ fetchAndArchive (ForDso this.dso)
         require "All validatorLicenses map to the same validator" ( length (dedup (map (.validator) validatorLicenses)) == 1)
         -- We don't attempt to merge the fields in the validator licence since there is no good
         -- way to do so and none of the fields other than lastReceivedFor round are crucial and for that
         -- taking the max is the correct merge.
         cid <- create $ maximumOn (\license ->
                     case license.faucetState of
                         None    -> Round 0
                         Some r  -> r.lastReceivedFor) validatorLicenses
         pure $ DsoRules_MergeValidatorLicenseResult cid

    -- SV onboarding
    ----------------

    nonconsuming choice DsoRules_StartSvOnboarding : DsoRules_StartSvOnboardingResult
      with
        candidateName : Text
        candidateParty : Party
        candidateParticipantId: Text
        token : Text
        sponsor : Party
      controller sponsor
      do
        require "Sponsor is an SV" (sponsor `Map.member` svs)
        now <- getTime
        let expiresAt = now `addRelTime` config.svOnboardingRequestTimeout
        onboardingRequest <- create SvOnboardingRequest with ..
        return DsoRules_StartSvOnboardingResult with ..

    nonconsuming choice DsoRules_ExpireSvOnboardingRequest : DsoRules_ExpireSvOnboardingRequestResult
      with
        cid: ContractId SvOnboardingRequest
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        exercise cid SvOnboardingRequest_Expire
        return DsoRules_ExpireSvOnboardingRequestResult

    nonconsuming choice DsoRules_ArchiveSvOnboardingRequest : DsoRules_ArchiveSvOnboardingRequestResult
      with
        svOnboardingRequestCid: ContractId SvOnboardingRequest
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        -- TODO(#3756) Enable archiving also before the sv is added, after a matching `SvOnboardingConfirmed` contract is created.
        svOnboardingRequest <- fetchAndArchive (ForDso with dso) svOnboardingRequestCid
        let maybeSv = Map.lookup svOnboardingRequest.candidateParty svs
        require "SV party is an SV" (isSome maybeSv)
        require "SV name matches" ((fromSome maybeSv).name == svOnboardingRequest.candidateName)
        return DsoRules_ArchiveSvOnboardingRequestResult

    nonconsuming choice DsoRules_ConfirmSvOnboarding : DsoRules_ConfirmSvOnboardingResult
      with
        newSvParty : Party
        newSvName : Text
        newParticipantId : Text
        newSvRewardWeight : Int
        reason : Text
      controller dso
      do
        ensureNeverOperatedNode newSvParty this
        if (not isDevNet)
          then
            require "SV name is expected to be new unless in devnet" (newSvName `notElem` (map (.name) (Map.values svs)))
          else pure ()
        now <- getTime
        let expiresAt = now `addRelTime` config.svOnboardingConfirmedTimeout
        onboardingConfirmed <- create SvOnboardingConfirmed with
          svParty = newSvParty
          svName = newSvName
          svRewardWeight = newSvRewardWeight
          svParticipantId = newParticipantId
          reason
          dso
          expiresAt
        return DsoRules_ConfirmSvOnboardingResult with ..

    choice DsoRules_ExpireSvOnboardingConfirmed : DsoRules_ExpireSvOnboardingConfirmedResult
      with
        cid: ContractId SvOnboardingConfirmed
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        svOnboardingConfirmed <- fetchButArchiveLater (ForDso with dso) cid
        exercise cid SvOnboardingConfirmed_Expire
        -- register the sv as offboarded so it's PartyToParticipant mapping for the DSO party gets removed
        let sv = svOnboardingConfirmed.svParty
        let offboardingInfo = OffboardedSvInfo with
              name = svOnboardingConfirmed.svName
              participantId = svOnboardingConfirmed.svParticipantId
        newDsoRules <- create this with
          offboardedSvs = Map.insert sv offboardingInfo offboardedSvs
        return DsoRules_ExpireSvOnboardingConfirmedResult with ..


    -- Amulet management driven directly by the DSO delegates
    ---------------------------------------------------------

    nonconsuming choice DsoRules_Amulet_Expire : DsoRules_Amulet_ExpireResult
      with
        cid : ContractId Amulet
        choiceArg : Amulet_Expire
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        result <- exercise cid choiceArg
        return DsoRules_Amulet_ExpireResult with
          expireSum = result.expireSum

    nonconsuming choice DsoRules_LockedAmulet_ExpireAmulet : DsoRules_LockedAmulet_ExpireAmuletResult
      with
        cid : ContractId LockedAmulet
        choiceArg : LockedAmulet_ExpireAmulet
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        result <- exercise cid choiceArg
        return DsoRules_LockedAmulet_ExpireAmuletResult with
          expireSum = result.expireSum


    -- Round management driven directly by the DSO delegates
    --------------------------------------------------------

    nonconsuming choice DsoRules_AdvanceOpenMiningRounds : DsoRules_AdvanceOpenMiningRoundsResult
      with
        amuletRulesCid : ContractId AmuletRules
        roundToArchiveCid : ContractId OpenMiningRound
        middleRoundCid : ContractId OpenMiningRound
        latestRoundCid : ContractId OpenMiningRound
        amuletPriceVoteCids : [ContractId AmuletPriceVote]
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        amuletPrice <- fetchMedianAmuletPrice dso (Map.keys svs) amuletPriceVoteCids
        result <- exercise amuletRulesCid AmuletRules_AdvanceOpenMiningRounds with ..
        return DsoRules_AdvanceOpenMiningRoundsResult with
          summarizingRound = result.summarizingRoundCid
          openRound = result.openRoundCid


    -- ANS entry and payment management driven directly by the DSO delegates
    ------------------------------------------------------------------------

    nonconsuming choice DsoRules_CollectEntryRenewalPayment : DsoRules_CollectEntryRenewalPaymentResult
      with
        ansEntryContextCid : ContractId AnsEntryContext
        choiceArg : AnsEntryContext_CollectEntryRenewalPayment
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        summary <- exercise ansEntryContextCid choiceArg
        return DsoRules_CollectEntryRenewalPaymentResult with
          ansEntry = summary.entryCid
          subscriptionState = summary.subscriptionStateCid

    nonconsuming choice DsoRules_ExpireAnsEntry : DsoRules_ExpireAnsEntryResult
      with
        ansEntryCid : ContractId AnsEntry
        choiceArg : AnsEntry_Expire
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        exercise ansEntryCid choiceArg
        pure DsoRules_ExpireAnsEntryResult

    nonconsuming choice DsoRules_ExpireSubscription : DsoRules_ExpireSubscriptionResult
      with
        ansEntryContextCid : ContractId AnsEntryContext
        subscriptionIdleStateCid: ContractId SubscriptionIdleState
        choiceArg : SubscriptionIdleState_ExpireSubscription
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        result <- exercise subscriptionIdleStateCid choiceArg
        exercise ansEntryContextCid (AnsEntryContext_Terminate dso result.terminatedSubscription)
        pure DsoRules_ExpireSubscriptionResult

    nonconsuming choice DsoRules_TerminateSubscription : DsoRules_TerminateSubscriptionResult
      with
        ansEntryContextCid : ContractId AnsEntryContext
        terminatedSubscriptionCid : ContractId TerminatedSubscription
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        exercise ansEntryContextCid (AnsEntryContext_Terminate dso terminatedSubscriptionCid)
        pure DsoRules_TerminateSubscriptionResult


    -- Reward management driven directly by the DSO delegates
    ---------------------------------------------------------

    nonconsuming choice DsoRules_ReceiveSvRewardCoupon : DsoRules_ReceiveSvRewardCouponResult
      with
        sv : Party
        openRoundCid : ContractId OpenMiningRound
        rewardStateCid : ContractId SvRewardState
        beneficiaries : [(Party, Int)]
      controller sv
      do
        case Map.lookup sv svs of
          None -> fail "SV is not an SV"
          Some info -> do
            -- check round
            now <- getTime
            openRound <- fetchReferenceData (ForDso with dso) openRoundCid
            require "OpenRound is open" (openRound.opensAt <= now)

            -- check and update state
            rewardState <- fetchAndArchive (ForSv with dso; svName = info.name) rewardStateCid
            let state = rewardState.state
            require
              ("Round " <> show openRound.round <> " is greater than the last round a reward has been received for " <> show state.lastRoundCollected)
              (state.lastRoundCollected < openRound.round)

            newRewardStateCid <- create rewardState with
              state = RewardState with
                lastRoundCollected = openRound.round
                numRoundsCollected = state.numRoundsCollected + 1
                numRoundsMissed =
                  state.numRoundsMissed + (openRound.round.number - state.lastRoundCollected.number - 1)
                numCouponsIssued = state.numCouponsIssued + length beneficiaries

            -- check weights and issue rewards
            let totalBenficiaryWeight = sum $ map snd beneficiaries
            require "Total beneficiary weight matches SV operator weight" (totalBenficiaryWeight == info.svRewardWeight)
            require "At most one coupon per beneficiary" (unique $ map fst beneficiaries)

            couponCids <- forA beneficiaries $ \(beneficiary, weight) ->
              create SvRewardCoupon with
                dso
                sv
                beneficiary
                weight
                round = openRound.round

            return DsoRules_ReceiveSvRewardCouponResult with
                svRewardState = newRewardStateCid
                svRewardCoupons = couponCids


    -- Batch expiry of unclaimed rewards for a specific claimed round
    -----------------------------------------------------------------
    nonconsuming choice DsoRules_ClaimExpiredRewards : DsoRules_ClaimExpiredRewardsResult
      with
        amuletRulesCid : ContractId AmuletRules
        choiceArg : AmuletRules_ClaimExpiredRewards
        sv : Optional Party
      controller sv
      do
        -- TODO(#2025) Deprecate AmuletRules_ClaimExpiredRewards. We did not do that in the same change
        -- as inlining the definition here so don't need to bump splice-amulet which also requires validators to upgrade.
        let AmuletRules_ClaimExpiredRewards{..} = choiceArg
        -- retrieve round
        closedRound <- fetchReferenceData (ForDso with dso) closedRoundCid

        -- expire validator rewards and compute their unclaimed rewards
        expiredValidatorRewards <- forA validatorRewardCouponCids $ \validatorRewardCouponCid -> do
          expireResult <- exercise validatorRewardCouponCid ValidatorRewardCoupon_DsoExpire with closedRoundCid
          return expireResult.amount

        let validatorRewards = sum expiredValidatorRewards

        -- expire validator faucet coupons and compute their unclaimed rewards
        forA_ (fromOptional [] optValidatorFaucetCouponCids) $ \validatorFaucetCouponCid -> do
          exercise validatorFaucetCouponCid ValidatorFaucetCoupon_DsoExpire with closedRoundCid

        let numValidatorFaucetCoupons = optional 0.0 (intToDecimal . length) optValidatorFaucetCouponCids

        -- expire validator liveness activity records and compute their unclaimed rewards
        forA_ (fromOptional [] optValidatorLivenessActivityRecordCids) $ \validatorLivenessActivityRecordCid -> do
          exercise validatorLivenessActivityRecordCid  ValidatorLivenessActivityRecord_DsoExpire with closedRoundCid

        let numValidatorLivenessActivityRecords = optional 0.0 (intToDecimal . length) optValidatorLivenessActivityRecordCids

        -- expire app rewards and compute their unclaimed rewards
        expiredAppRewards <- forA appCouponCids $ \appCouponCid -> do
          expireResult <- exercise appCouponCid AppRewardCoupon_DsoExpire with closedRoundCid
          return (expireResult.featured, expireResult.amount)

        let featuredAppRewards = sum [ amount | (featured, amount) <- expiredAppRewards, featured ]
        let unfeaturedAppRewards = sum [ amount | (featured, amount) <- expiredAppRewards, not featured ]

        -- expire validator rewards and compute their unclaimed rewards
        expiredSvRewards <- forA svRewardCouponCids $ \svRewardCouponCid -> do
          expireResult <- exercise svRewardCouponCid SvRewardCoupon_DsoExpire with closedRoundCid
          return expireResult.weight

        let svRewardsWeight = sum expiredSvRewards

        -- create unclaimed reward for the total
        let amount =
              validatorRewards * closedRound.issuancePerValidatorRewardCoupon +
              (numValidatorFaucetCoupons + numValidatorLivenessActivityRecords) * getClosedMiningRoundIssuancePerValidatorFaucetCoupon closedRound +
              featuredAppRewards * closedRound.issuancePerFeaturedAppRewardCoupon +
              unfeaturedAppRewards * closedRound.issuancePerUnfeaturedAppRewardCoupon +
              intToDecimal svRewardsWeight * closedRound.issuancePerSvRewardCoupon
        unclaimedRewardCid <- if (amount <= 0.0)
              then pure None
              else Some <$> create UnclaimedReward with dso; amount
        return DsoRules_ClaimExpiredRewardsResult with
          unclaimedReward = unclaimedRewardCid

    -- Batch merge of unclaimed rewards
    nonconsuming choice DsoRules_MergeUnclaimedRewards : DsoRules_MergeUnclaimedRewardsResult
      with
        amuletRulesCid : ContractId AmuletRules
        unclaimedRewardCids : [ContractId UnclaimedReward]
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        require "Number of unclaimed rewards is above the configured threshold" $ length unclaimedRewardCids > config.numUnclaimedRewardsThreshold
        result <- exercise amuletRulesCid AmuletRules_MergeUnclaimedRewards with ..
        return DsoRules_MergeUnclaimedRewardsResult with
          unclaimedReward = result.unclaimedRewardCid

    nonconsuming choice DsoRules_MiningRound_Close : DsoRules_MiningRound_CloseResult
      with
        amuletRulesCid : ContractId AmuletRules
        issuingRoundCid : ContractId IssuingMiningRound
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        result <- exercise amuletRulesCid AmuletRules_MiningRound_Close with ..
        return DsoRules_MiningRound_CloseResult with
          closedRound = result.closedRoundCid


    -- Contract Expiry
    ------------------

    -- TODO(M3-57): generalize this to `ExpiringContract` and use it for all expiring contracts in `Splice.DsoRules`
    nonconsuming choice DsoRules_ExpireStaleConfirmation : DsoRules_ExpireStaleConfirmationResult
      with
        staleConfirmationCid : ContractId Confirmation
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        fetchChecked (ForDso with dso) staleConfirmationCid
        exercise staleConfirmationCid Confirmation_Expire
        return DsoRules_ExpireStaleConfirmationResult

    -- Batch merge of member traffic contracts
    -------------------------------------------
    nonconsuming choice DsoRules_MergeMemberTrafficContracts : DsoRules_MergeMemberTrafficContractsResult
      with
        amuletRulesCid : ContractId AmuletRules
        trafficCids : [ContractId MemberTraffic]
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        require "Number of member traffic contracts is above the configured threshold" $ length trafficCids > config.numMemberTrafficContractsThreshold
        result <- exercise amuletRulesCid AmuletRules_MergeMemberTrafficContracts with ..
        return DsoRules_MergeMemberTrafficContractsResult with
          memberTraffic = result.mergedTrafficCid

    nonconsuming choice DsoRules_MergeSvRewardState : DsoRules_MergeSvRewardStateResult
      -- ^ Note this choice only exists to clean up duplicate contracts caused by the bug in #12495.
      -- There should never be duplicates going forward.
      with
        svName : Text
        rewardStateCids : [ContractId SvRewardState]
        sv : Optional Party
      controller sv
      do _ <- getAndValidateSvParty this sv
         require "Number of SvRewardState contracts to merge is >= 2" (length rewardStateCids >= 2)
         rewardStates <- forA rewardStateCids $ fetchAndArchive (ForSv this.dso svName)
         -- We don't attempt to merge the fields in the reward state since there is no good
         -- way to do so and none of the fields other than lastRoundCollected are crucial and for that
         -- taking the max is the correct merge.
         cid <- create $ maximumOn (\state -> state.state.lastRoundCollected) rewardStates
         pure $ DsoRules_MergeSvRewardStateResult cid

    -- __Deprecated__ AmuletConfigSchedule futureValues is not used anymore.
    nonconsuming choice DsoRules_PruneAmuletConfigSchedule : DsoRules_PruneAmuletConfigScheduleResult
      with
        amuletRulesCid : ContractId AmuletRules
        sv : Optional Party
      controller sv
      do _ <- getAndValidateSvParty this sv
         deprecatedChoice "splice-dso-governance" "0.1.16" "DsoRules_PruneAmuletConfigSchedule"

    -- external party
    -----------------
    nonconsuming choice DsoRules_CreateExternalPartyAmuletRules : DsoRules_CreateExternalPartyAmuletRulesResult
      controller dso
      do cid <- create ExternalPartyAmuletRules with dso
         pure (DsoRules_CreateExternalPartyAmuletRulesResult cid)

    nonconsuming choice DsoRules_CreateTransferCommandCounter : DsoRules_CreateTransferCommandCounterResult
      with
        sender : Party
      controller dso
      do cid <- create TransferCommandCounter with
           dso
           sender
           nextNonce = 0
         pure (DsoRules_CreateTransferCommandCounterResult cid)

    nonconsuming choice DsoRules_ExpireTransferPreapproval : DsoRules_ExpireTransferPreapprovalResult
      with
        transferPreapprovalCid : ContractId TransferPreapproval
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        exercise transferPreapprovalCid TransferPreapproval_Expire
        pure DsoRules_ExpireTransferPreapprovalResult

    nonconsuming choice DsoRules_AmuletRules_ConvertFeaturedAppActivityMarkers : DsoRules_AmuletRules_ConvertFeaturedAppActivityMarkersResult
      with
        amuletRulesCid : ContractId AmuletRules
        argument : AmuletRules_ConvertFeaturedAppActivityMarkers
        sv : Optional Party
      controller sv
      do
        _ <- getAndValidateSvParty this sv
        result <- exercise amuletRulesCid argument
        pure DsoRules_AmuletRules_ConvertFeaturedAppActivityMarkersResult with result


    -- Unallocated unclaimed activity record
    ----------------------------------------

    nonconsuming choice DsoRules_CreateUnallocatedUnclaimedActivityRecord : DsoRules_CreateUnallocatedUnclaimedActivityRecordResult
      with
        beneficiary : Party
        amount : Decimal
        reason : Text
        expiresAt : Time
      controller dso
      do
        now <- getTime
        -- Sanity check
        require "UnclaimedActivityRecord expires after current time" $ expiresAt > now
        unallocatedUnclaimedActivityRecordCid <-
          create UnallocatedUnclaimedActivityRecord with
            dso
            beneficiary
            amount
            reason
            expiresAt
        pure $ DsoRules_CreateUnallocatedUnclaimedActivityRecordResult with ..

    nonconsuming choice DsoRules_AllocateUnallocatedUnclaimedActivityRecord : DsoRules_AllocateUnallocatedUnclaimedActivityRecordResult
      with
        unallocatedUnclaimedActivityRecordCid : ContractId UnallocatedUnclaimedActivityRecord
        amuletRulesCid : ContractId AmuletRules
        unclaimedRewardsToBurnCids : [ContractId UnclaimedReward]
          -- ^ A sufficient list of `UnclaimedReward` to be archived.
          -- It must cover at least the requested amount.
        sv : Party
      controller sv
      do
        _ <- getAndValidateSvParty this (Some sv)
        UnallocatedUnclaimedActivityRecord{..} <- fetchAndArchive (ForDso with dso) unallocatedUnclaimedActivityRecordCid
        assertWithinDeadline "UnallocatedUnclaimedActivityRecord.expiresAt" expiresAt

        totalUnclaimedRewards <- sum <$> forA unclaimedRewardsToBurnCids \cid -> do
          unclaimedReward <- fetchAndArchive (ForDso with dso) cid
          pure unclaimedReward.amount
        let leftover = totalUnclaimedRewards - amount
        optUnclaimedRewardCid <-
          if | leftover < 0.0 -> abort $ "insufficient unclaimed rewards: " <> show (negate leftover)
             | leftover == 0.0 -> pure None
             | otherwise -> Some <$> create UnclaimedReward with dso; amount = leftover

        unclaimedActivityRecordCid <- create UnclaimedActivityRecord with
          dso
          beneficiary
          amount
          reason
          expiresAt

        pure $ DsoRules_AllocateUnallocatedUnclaimedActivityRecordResult with ..

    nonconsuming choice DsoRules_ExpireUnallocatedUnclaimedActivityRecord : DsoRules_ExpireUnallocatedUnclaimedActivityRecordResult
      with
        unallocatedUnclaimedActivityRecordCid : ContractId UnallocatedUnclaimedActivityRecord
        sv : Party
      controller sv
      do
        _ <- getAndValidateSvParty this (Some sv)
        unallocatedUnclaimedActivityRecord <- fetchAndArchive (ForDso with dso) unallocatedUnclaimedActivityRecordCid
        assertDeadlineExceeded "UnallocatedUnclaimedActivityRecord.expiresAt" unallocatedUnclaimedActivityRecord.expiresAt
        pure $ DsoRules_ExpireUnallocatedUnclaimedActivityRecordResult

    nonconsuming choice DsoRules_ExpireUnclaimedActivityRecord : DsoRules_ExpireUnclaimedActivityRecordResult
      with
        unclaimedActivityRecordCid : ContractId UnclaimedActivityRecord
        sv : Party
      controller sv
      do
        _ <- getAndValidateSvParty this (Some sv)
        UnclaimedActivityRecord_DsoExpireResult unclaimedRewardCid <-
          exercise unclaimedActivityRecordCid UnclaimedActivityRecord_DsoExpire
        pure DsoRules_ExpireUnclaimedActivityRecordResult with unclaimedRewardCid


pruneAtLeastOne : Ord t => t -> Schedule t a -> Optional (Schedule t a)
pruneAtLeastOne now schedule =
   case reverse past of
     [] -> None
     (_, newInitial) :: _ -> Some (Schedule newInitial future)
   where
     (past, future) = span (\(t, _) -> t <= now) schedule.futureValues

summarizeDso : DsoRules -> DsoSummary
summarizeDso dsoRules = DsoSummary with
    dsoDelegate = dsoRules.dsoDelegate
    numSvs
    requiredNumVotes =
      -- NOTE:
      --   For a vote with n svs and f = floor((n - 1) /3) byzantine svs, we want to have the following properties:
      --     *availability*: f operators abstaining, wont stop the vote
      --         numRequiredVotes <= n - f
      --     *tolerate DSO delegate selecting the votes*: the threshold must be independent of the number of votes cast
      --     *integrity*: f operators cannot boost their voting power for future votes by collaborating
      --         implies f < threshold-for-accepting-an-action
      --     *result acceptance*: outcome is accepted by SV operators
      --         we can pick between requiring numYays >= n / 2 + 1 (simple majority) and requiring numYays >= numRequiredVotes (super-majority)
      --   We favor the following threshold that agrees with our preference of having both integrity and availability.
      ceiling ((intToDecimal (numSvs + f + 1)) / 2.0)
  where
    numSvs = Map.size dsoRules.svs
    f = floor ((intToDecimal (numSvs - 1)) / 3.0)

-- | Execute an action which requires certain number of confirmations from SVs.
-- Each confirmed action can at most be executed once.
executeActionRequiringConfirmation: Party -> ContractId DsoRules -> Optional( ContractId AmuletRules ) -> ActionRequiringConfirmation -> Update ()
executeActionRequiringConfirmation dso dsoRulesCid amuletRulesCid act = case act of
  ARC_AmuletRules with .. ->
    case amuletRulesCid of
      None -> error "amuletRulesCid was not defined."
      Some amuletRulesCid -> do
        -- prudent engineering: check that the DSO party is as expected
        void $ fetchChecked (ForDso with dso) amuletRulesCid
        case amuletRulesAction of
          CRARC_MiningRound_StartIssuing choiceArg -> void $ exercise amuletRulesCid choiceArg
          CRARC_MiningRound_Archive choiceArg -> void $ exercise amuletRulesCid choiceArg
          CRARC_SetConfig choiceArg -> void $ exercise amuletRulesCid choiceArg
          CRARC_AddFutureAmuletConfigSchedule choiceArg -> void $ exercise amuletRulesCid choiceArg
          CRARC_RemoveFutureAmuletConfigSchedule choiceArg -> void $ exercise amuletRulesCid choiceArg
          CRARC_UpdateFutureAmuletConfigSchedule choiceArg -> void $ exercise amuletRulesCid choiceArg
  ARC_DsoRules with .. -> do
    void $ fetchChecked (ForDso with dso) dsoRulesCid
    case dsoAction of
      SRARC_AddSv choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_OffboardSv choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_ConfirmSvOnboarding choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_GrantFeaturedAppRight choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_RevokeFeaturedAppRight choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_SetConfig choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_UpdateSvRewardWeight choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_CreateExternalPartyAmuletRules choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_CreateTransferCommandCounter choiceArg -> void $ exercise dsoRulesCid choiceArg
      SRARC_CreateUnallocatedUnclaimedActivityRecord choiceArg -> void $ exercise dsoRulesCid choiceArg
  ARC_AnsEntryContext with .. -> do
    void $ fetchChecked (ForDso with dso) ansEntryContextCid
    case ansEntryContextAction of
      ANSRARC_CollectInitialEntryPayment choiceArg -> void $ exercise ansEntryContextCid choiceArg
      ANSRARC_RejectEntryInitialPayment choiceArg -> void $ exercise ansEntryContextCid choiceArg
  ExtActionRequiringConformation _dummyUnitField -> pure ()

-- | __Deprecated__ in favor of delegateless automation.
-- Functions implementing instant-runoff voting
-----------------------------------------------

data VotingState a = VotingState with
    rankings : Map.Map a [[a]]
      -- ^ Candidate and the remaining rankings in case that candidate is eliminated.
    loosers : Set.Set a
      -- ^ Loosers are tracked explicitly and removed lazily to avoid the cubic runtime
      -- that would result from filtering the remaining rankings eagerly.
  deriving (Eq, Show)


-- Wellformedness checks
------------------------

requireWellformedReason : DsoRulesConfig -> Reason -> Update ()
requireWellformedReason config reason = do
  require "Reason URL is not too long" (T.length reason.url <= config.maxTextLength)
  require "Reason body is not too long" (T.length reason.body <= config.maxTextLength)

requireWellformedVote : DsoRulesConfig -> Vote -> Update ()
requireWellformedVote config vote = do
  requireWellformedReason config vote.reason

ensureNotExpired : Time -> Update ()
ensureNotExpired expiresAt = do
  now <- getTime
  require "Contract has not yet expired" (now < expiresAt)


-- Vote Request support functions
---------------------------------

-- | Get the future-dated effectiveAt of an action requiring confirmation.
actionRequiringConfirmationEffectiveAt : ActionRequiringConfirmation -> Optional Time
actionRequiringConfirmationEffectiveAt action =
  case action of
    ARC_AmuletRules with .. ->
      case amuletRulesAction of
        CRARC_SetConfig _ -> None
        CRARC_AddFutureAmuletConfigSchedule choiceArg -> Some choiceArg.newScheduleItem._1
        CRARC_RemoveFutureAmuletConfigSchedule choiceArg -> Some choiceArg.scheduleTime
        CRARC_UpdateFutureAmuletConfigSchedule choiceArg -> Some choiceArg.scheduleItem._1
        CRARC_MiningRound_Archive _ -> None
        CRARC_MiningRound_StartIssuing _ -> None
    ARC_DsoRules with .. -> None
    ARC_AnsEntryContext with .. -> None
    ExtActionRequiringConformation _dummyUnitField ->
      error "Encountered unexpected ExtActionRequiringConformation at runtime"


-- On- and offboarding
----------------------

getSvInfo : Party -> DsoRules -> Update SvInfo
getSvInfo operator this =
  optional (fail "Not a sv") pure $ Map.lookup operator this.svs

lookupSvInfoByName : Text -> DsoRules -> Optional (Party, SvInfo)
lookupSvInfoByName svName DsoRules{..} =
  find (\info -> info._2.name == svName) $ Map.toList svs

-- | Returns True if an SV with that name is either currently onboarded
-- or an SV with that name has been onboarded before and is now in offboardedSvs.
svHasBeenOnboardedBefore : Text -> DsoRules -> Bool
svHasBeenOnboardedBefore svName this =
  isSome (lookupSvInfoByName svName this) || any (\info -> info.name == svName) (Map.values this.offboardedSvs)

ensureNeverOperatedNode : Party -> DsoRules -> Update ()
ensureNeverOperatedNode newSvParty this = do
  require "SV party has not yet operated a node" $
    not (newSvParty `Map.member` this.svs || newSvParty `Map.member` this.offboardedSvs)

-- factored out from the choice to avoid mistakes from having the fields of DsoRules{..} in scope
dsoRules_addSv : DsoRules -> DsoRules_AddSv -> Update (ContractId DsoRules)
dsoRules_addSv this0 arg@DsoRules_AddSv{..} = do
  ensureNeverOperatedNode newSvParty this0
  -- in DevNet we allow changing the operator of an existing sv, which we implement as a removal and re-addition
  this@DsoRules{..} <-
    if this0.isDevNet
      then
        let DsoRules{..} = this0 in -- bring all DsoRules fields into scope
        case lookupSvInfoByName newSvName this0 of
          None -> pure this0
          Some (sv, info) -> do
            let offboardingInfo = OffboardedSvInfo with
                  name = info.name
                  participantId = info.participantId
            pure $ this0 with
              svs = Map.delete sv svs
              offboardedSvs = Map.insert sv offboardingInfo offboardedSvs
      else do
        require "SV is not currently onboarded" (isNone $ lookupSvInfoByName newSvName this0)
        pure this0

  -- create per-sv contracts if they have never been onboarded
  unless (svHasBeenOnboardedBefore newSvName this) $
    createPerSvContracts this arg
  -- create per SV party contracts
  let initialAmuletPriceVote = None
  createPerSvPartyContracts dso newSvParty newSvName noSynchronizerNodes initialAmuletPriceVote (getVoteCooldownTime config)
  -- register the new operator in the DsoRules
  let svInfo = SvInfo with
        name = newSvName
        joinedAsOfRound
        svRewardWeight = newSvRewardWeight
        participantId = newSvParticipantId
  create this with
    svs = Map.insert newSvParty svInfo svs

createPerSvContracts : DsoRules -> DsoRules_AddSv -> Update ()
createPerSvContracts DsoRules{..} DsoRules_AddSv{..} = do
  void $ create SvRewardState with
    dso
    svName = newSvName
    state = RewardState with
      lastRoundCollected = Round (joinedAsOfRound.number - 1)
      numRoundsMissed = 0
      numRoundsCollected = 0
      numCouponsIssued = 0

createPerSvPartyContracts : Party -> Party -> Text -> SynchronizerNodeConfigMap -> Optional Decimal -> RelTime -> Update ()
createPerSvPartyContracts dso newSvParty newSvName synchronizerNodes amuletPrice voteCooldownTime = do
  -- Note: we currently track the amulet-price vote on a per operator basis.
  -- This implies it will be reset when an operator is offboarded and re-onboarded.
  now <- getTime
  void $ create AmuletPriceVote with
    dso
    sv = newSvParty
    amuletPrice
    lastUpdatedAt =
      -- allow casting a vote immediately after onboarding
      now `addRelTime` negate voteCooldownTime
  void $ create SvStatusReport with
    dso
    sv = newSvParty
    svName = newSvName
    number = 0
    status = None
  void $ create SvNodeState with
    dso
    sv = newSvParty
    svName = newSvName
    state = NodeState with
      synchronizerNodes

getAndValidateSvParty : DsoRules -> Optional Party -> Update Party
getAndValidateSvParty _ None = fail "no SV party provided"
getAndValidateSvParty rules (Some sv) = do
  require "SV party is an actual SV" (sv `Map.member` rules.svs)
  pure sv


-- Rate limiting
----------------

-- | Enforce that an action is not performed again before a cooldown period has passed.
enforceCooldown : Text -> RelTime -> Optional Time -> Update ()
enforceCooldown cooldownName cooldown lastActionTime = do
  case lastActionTime of
    Some lastTime -> do
      let nextAllowedTime = lastTime `addRelTime` cooldown
      assertDeadlineExceeded cooldownName nextAllowedTime
    None -> pure () -- no last action time, so no enforcement needed


-- Unallocated unclaimed activity record
----------------------------------------

-- | A governance-approved record representing intent to reward a beneficiary.
-- Once sufficient `UnclaimedReward` contracts are allocated and archived,
-- this contract results in the creation of a mintable `UnclaimedActivityRecord`.
template UnallocatedUnclaimedActivityRecord
  with
    dso : Party
    beneficiary : Party -- ^ The owner of the `Amulet` to be minted
    amount : Decimal -- ^ The amount of `Amulet` to be minted
    reason : Text -- ^ A reason to mint the `Amulet`
    expiresAt : Time -- ^ Selected timestamp defining the lifetime of the UnclaimedActivityRecord contract.
  where
    signatory dso
    ensure amount > 0.0


-- instances
------------

instance HasCheckedFetch DsoRules ForDso where
  contractGroupId DsoRules {..} = ForDso with dso

instance HasCheckedFetch ElectionRequest ForDso where
  contractGroupId ElectionRequest {..} = ForDso with dso

instance HasCheckedFetch VoteRequest ForDso where
  contractGroupId VoteRequest {..} = ForDso with dso

instance HasCheckedFetch FeaturedAppRight ForDso where
  contractGroupId FeaturedAppRight {..} = ForDso with dso

instance HasCheckedFetch UnallocatedUnclaimedActivityRecord ForDso where
  contractGroupId UnallocatedUnclaimedActivityRecord {..} = ForDso with dso

instance HasCheckedFetch Confirmation ForDso where
  contractGroupId Confirmation {..} = ForDso with dso

instance Patchable DsoRulesConfig where
  patch new base current = DsoRulesConfig with
    numUnclaimedRewardsThreshold = patch new.numUnclaimedRewardsThreshold base.numUnclaimedRewardsThreshold current.numUnclaimedRewardsThreshold
    numMemberTrafficContractsThreshold = patch new.numMemberTrafficContractsThreshold base.numMemberTrafficContractsThreshold current.numMemberTrafficContractsThreshold
    actionConfirmationTimeout = patch new.actionConfirmationTimeout base.actionConfirmationTimeout current.actionConfirmationTimeout
    svOnboardingRequestTimeout = patch new.svOnboardingRequestTimeout base.svOnboardingRequestTimeout current.svOnboardingRequestTimeout
    svOnboardingConfirmedTimeout = patch new.svOnboardingConfirmedTimeout base.svOnboardingConfirmedTimeout current.svOnboardingConfirmedTimeout
    voteRequestTimeout = patch new.voteRequestTimeout base.voteRequestTimeout current.voteRequestTimeout
    dsoDelegateInactiveTimeout = patch new.dsoDelegateInactiveTimeout base.dsoDelegateInactiveTimeout current.dsoDelegateInactiveTimeout
    synchronizerNodeConfigLimits = patch new.synchronizerNodeConfigLimits base.synchronizerNodeConfigLimits current.synchronizerNodeConfigLimits
    maxTextLength = patch new.maxTextLength base.maxTextLength current.maxTextLength
    decentralizedSynchronizer = patch new.decentralizedSynchronizer base.decentralizedSynchronizer current.decentralizedSynchronizer
    nextScheduledSynchronizerUpgrade = patch new.nextScheduledSynchronizerUpgrade base.nextScheduledSynchronizerUpgrade current.nextScheduledSynchronizerUpgrade
    voteCooldownTime = patch new.voteCooldownTime base.voteCooldownTime current.voteCooldownTime

instance Patchable SynchronizerUpgradeSchedule where
  patch new base current = SynchronizerUpgradeSchedule with
        time = patch new.time base.time current.time
        migrationId = patch new.migrationId base.migrationId current.migrationId
