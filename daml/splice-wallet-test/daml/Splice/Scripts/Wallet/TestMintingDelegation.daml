-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.Wallet.TestMintingDelegation where

import DA.Assert
import DA.Foldable (forA_)
import DA.Time
import Daml.Script

import Splice.Amulet (FeaturedAppActivityMarker(..))
import Splice.AmuletRules
import Splice.Api.FeaturedAppRightV1 (AppRewardBeneficiary(..))
import Splice.Util
import Splice.Util.Token.Wallet.MergeDelegation (FeaturedAppRightCall(..))
import Splice.Wallet.MintingDelegation
import Splice.ValidatorLicense

import Splice.Scripts.Util

testMintingDelegation : Script ()
testMintingDelegation = do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

  beneficiary <- allocateParty "beneficiary"
  let delegate = aliceValidator.primaryParty

  -- Create a MintingDelegation
  now <- getTime
  proposalCid <- submit beneficiary $ createCmd MintingDelegationProposal with
    delegation = MintingDelegation with
      dso = app.dso
      beneficiary
      delegate
      expiresAt = now `addRelTime` days 30
      amuletMergeLimit = defaultAmuletMergeLimit

  MintingDelegationProposal_AcceptResult mintingDelegationCid <- submitMulti [delegate] [app.dso] $ exerciseCmd proposalCid MintingDelegationProposal_Accept

  -- Create a ValidatorLicense for the beneficiary with weight 2.0
  let weight = 2.0
  validatorLicenseCid <- submit app.dso $ createCmd ValidatorLicense with
    validator = beneficiary
    sponsor = app.dso
    dso = app.dso
    faucetState = None
    metadata = None
    lastActiveAt = None
    weight = Some weight
    kind = None

  (openRoundCid, _) <- getLatestOpenRound app

  submitMulti [delegate] [beneficiary, app.dso] $ exerciseCmd mintingDelegationCid MintingDelegation_RecordValidatorLivenessActivity with
    validatorLicenseCid
    openRoundCid
    optFeaturedAppRight = None

  [(livenessActivityRecordCid, activityRecord)] <- query @ValidatorLivenessActivityRecord beneficiary
  activityRecord.weight === Some weight

  runNextIssuance app
  runNextIssuance app
  runNextIssuance app

  balanceBefore <- getNormalizedBalance beneficiary

  context <- getTransferContext app alice None

  (amuletRulesCid, _) <- getAmuletRules app
  submitMulti [delegate] [beneficiary, app.dso] $ exerciseCmd mintingDelegationCid MintingDelegation_Mint with
    inputs = [InputValidatorLivenessActivityRecord livenessActivityRecordCid]
    context = PaymentTransferContext with
      context
      amuletRules = amuletRulesCid

  balanceAfter <- getNormalizedBalance beneficiary
  let reward = balanceAfter - balanceBefore
  require "Reward should be around 5.7 (2.85 * 2)" (reward >= 5.5 && reward <= 5.8)

  pure ()

testMintingDelegation_checksExpiry : Script ()
testMintingDelegation_checksExpiry = do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

  beneficiary <- allocateParty "beneficiary"
  let delegate = aliceValidator.primaryParty
  let delegationLifetime = days 30

  now <- getTime
  proposalCid <- submit beneficiary $ createCmd MintingDelegationProposal with
    delegation = MintingDelegation with
      dso = app.dso
      beneficiary
      delegate
      expiresAt = now `addRelTime` delegationLifetime
      amuletMergeLimit = defaultAmuletMergeLimit

  MintingDelegationProposal_AcceptResult mintingDelegationCid <- submitMulti [delegate] [app.dso] $ exerciseCmd proposalCid MintingDelegationProposal_Accept

  validatorLicenseCid <- submit app.dso $ createCmd ValidatorLicense with
    validator = beneficiary
    sponsor = app.dso
    dso = app.dso
    faucetState = None
    metadata = None
    lastActiveAt = None
    weight = None
    kind = None

  -- Record an activity before expiry to have a valid livenessActivityRecordCid
  (openRoundCid, _) <- getLatestOpenRound app
  submitMulti [delegate] [beneficiary, app.dso] $ exerciseCmd mintingDelegationCid MintingDelegation_RecordValidatorLivenessActivity with
    validatorLicenseCid
    openRoundCid
    optFeaturedAppRight = None

  [(livenessActivityRecordCid, _)] <- query @ValidatorLivenessActivityRecord beneficiary

  -- Advance rounds so record can be minted
  runNextIssuance app
  runNextIssuance app
  runNextIssuance app

  (newOpenRoundCid, _) <- getLatestOpenRound app

  -- Advance time past expiry
  passTime delegationLifetime

  -- RecordValidatorLivenessActivity should fail after expiry
  submitMultiMustFail [delegate] [beneficiary, app.dso] $ exerciseCmd mintingDelegationCid MintingDelegation_RecordValidatorLivenessActivity with
    validatorLicenseCid
    openRoundCid = newOpenRoundCid
    optFeaturedAppRight = None

  -- Mint should fail after expiry
  context <- getTransferContext app alice None
  (amuletRulesCid, _) <- getAmuletRules app

  submitMultiMustFail [delegate] [beneficiary, app.dso] $ exerciseCmd mintingDelegationCid MintingDelegation_Mint with
    inputs = [InputValidatorLivenessActivityRecord livenessActivityRecordCid]
    context = PaymentTransferContext with
      context
      amuletRules = amuletRulesCid

  pure ()

testMintingDelegation_withFeaturedAppRight : Script ()
testMintingDelegation_withFeaturedAppRight = do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

  beneficiary <- allocateParty "beneficiary"
  let delegate = aliceValidator.primaryParty

  -- Feature the delegate's app
  featuredAppRightCid <- featureApp app aliceValidator

  -- Create a MintingDelegation
  now <- getTime
  proposalCid <- submit beneficiary $ createCmd MintingDelegationProposal with
    delegation = MintingDelegation with
      dso = app.dso
      beneficiary
      delegate
      expiresAt = now `addRelTime` days 30
      amuletMergeLimit = defaultAmuletMergeLimit

  MintingDelegationProposal_AcceptResult mintingDelegationCid <- submitMulti [delegate] [app.dso] $ exerciseCmd proposalCid MintingDelegationProposal_Accept

  -- Create a ValidatorLicense for the beneficiary
  validatorLicenseCid <- submit app.dso $ createCmd ValidatorLicense with
    validator = beneficiary
    sponsor = app.dso
    dso = app.dso
    faucetState = None
    metadata = None
    lastActiveAt = None
    weight = Some 1.0
    kind = None

  (openRoundCid, _) <- getLatestOpenRound app

  -- Allocate another beneficiary for the app reward
  appRewardBeneficiary2 <- allocateParty "appRewardBeneficiary2"

  -- Record activity with featured app right with multiple beneficiaries
  submitMulti [delegate] [beneficiary, app.dso] $ exerciseCmd mintingDelegationCid MintingDelegation_RecordValidatorLivenessActivity with
    validatorLicenseCid
    openRoundCid
    optFeaturedAppRight = Some FeaturedAppRightCall with
      appRightCid = toInterfaceContractId featuredAppRightCid
      beneficiaries =
        [ AppRewardBeneficiary with beneficiary = delegate, weight = 0.6
        , AppRewardBeneficiary with beneficiary = appRewardBeneficiary2, weight = 0.4
        ]

  -- Check that activity markers were created for both beneficiaries with correct weights
  allMarkers <- query @FeaturedAppActivityMarker delegate
  length allMarkers === 2

  let expectedWeights = [(delegate, 0.6), (appRewardBeneficiary2, 0.4)]
  forA_ expectedWeights $ \(b, expectedWeight) ->
    case find (\(_, m) -> m.beneficiary == b) allMarkers of
      Some (_, m) -> m.weight === expectedWeight
      None -> fail $ "Marker not found for " <> show b

  pure ()
