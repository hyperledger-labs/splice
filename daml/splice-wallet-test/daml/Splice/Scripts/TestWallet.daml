-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.Scripts.TestWallet where

import DA.Action
import DA.Assert
import DA.Time
import Daml.Script
import DA.List
import DA.Optional
import DA.TextMap as TextMap

import Splice.Amulet
import Splice.AmuletRules
import Splice.AmuletConfig (defaultTransferPreapprovalFee)
import Splice.Types
import Splice.Schedule
import Splice.DecentralizedSynchronizer
import Splice.Wallet.Install
import Splice.Wallet.Payment
import Splice.Wallet.Subscriptions
import Splice.Wallet.TopUpState
import Splice.Wallet.BuyTrafficRequest
import Splice.Wallet.TransferPreapproval
import Splice.Scripts.Wallet.TestSubscriptions
import Splice.Fees
import Splice.Scripts.Util
import Splice.Testing.Utils
import Splice.Testing.Registries.AmuletRegistry.Parameters
import Splice.Testing.Registries.AmuletRegistry qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApi qualified as RegistryApi
import qualified Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import qualified Splice.Api.Token.AllocationInstructionV1 as Api.Token.AllocationInstructionV1
import Splice.Api.Token.TransferInstructionV1 (TransferFactory_Transfer(..))
import qualified Splice.Api.Token.TransferInstructionV1 as Api.Token.TransferInstructionV1
import Splice.Api.Token.MetadataV1
import Splice.Testing.Apps.TradingApp
import Splice.Testing.TokenStandard.WalletClient qualified as WalletClient

createPaymentRequest : AmuletApp -> Party -> Party -> [(Party, PaymentAmount)] -> Script (ContractId AppPaymentRequest)
createPaymentRequest app provider sender receiverAmounts = do
  t <- getTime
  let description = "multi, sender: " <> show sender <> ", amount: " <> show receiverAmounts
  -- multi-party submit to simplify test
  submitMulti (sender :: provider :: map fst receiverAmounts) [] $ createCmd AppPaymentRequest with
    sender
    provider
    dso = app.dso
    receiverAmounts = map (uncurry ReceiverAmount) receiverAmounts
    expiresAt = t `addRelTime` minutes 5
    description

createSingleReceiverPaymentRequest : AmuletApp -> Party -> Party -> Party -> PaymentAmount -> Script (ContractId AppPaymentRequest)
createSingleReceiverPaymentRequest app provider sender receiver amount = do
  createPaymentRequest app provider sender [(receiver, amount)]

acceptPaymentRequest : AmuletApp -> AmuletUser -> Party -> Optional(ContractId FeaturedAppRight) -> ContractId AppPaymentRequest -> ContractId Amulet -> Script (ContractId AcceptedAppPayment)
acceptPaymentRequest app sender walletProvider providerFeaturedAppRight transferRequest amulet = do
  context <- getPaymentTransferContextFeaturedApp app sender providerFeaturedAppRight
  -- TODO(#2957): remove read-as DSO party.
  result <- submitMulti [sender.primaryParty, walletProvider] [app.dso] $ exerciseCmd transferRequest AppPaymentRequest_Accept with
    inputs = [InputAmulet amulet]
    context
    walletProvider
  return result.acceptedPayment

collectAcceptedPayment : AmuletApp -> AmuletUser -> ContractId AcceptedAppPayment -> Script AcceptedAppPayment_CollectResult
collectAcceptedPayment app provider acceptedAppPayment = do
  (_, round) <- getLatestOpenRound app
  collectAcceptedPaymentInRound app round.round provider acceptedAppPayment

collectAcceptedPaymentInRound : AmuletApp -> Round -> AmuletUser -> ContractId AcceptedAppPayment -> Script AcceptedAppPayment_CollectResult
collectAcceptedPaymentInRound app round provider acceptedAppPayment = do
  Some acceptedPayment <- queryContractId provider.primaryParty acceptedAppPayment
  context <- getAppTransferContextForRound app provider round
  -- multi party submit to simplify test
  submitMulti (signatory acceptedPayment) [app.dso] $ exerciseCmd acceptedAppPayment (AcceptedAppPayment_Collect context)

collectAcceptedPaymentMustFail : AmuletApp -> AmuletUser -> ContractId AcceptedAppPayment -> Script ()
collectAcceptedPaymentMustFail app provider acceptedAppPayment = do
  Some acceptedPayment <- queryContractId provider.primaryParty acceptedAppPayment
  context <- getAppTransferContext app provider
  -- multi party submit to simplify test
  _ <- submitMultiMustFail (signatory acceptedPayment) [app.dso] $ exerciseCmd acceptedAppPayment (AcceptedAppPayment_Collect context)
  pure ()

sendPreapprovedTransfer : AmuletApp -> AmuletUser -> AmuletUser -> AmuletUser -> Decimal -> Script AmuletOperationOutcome
sendPreapprovedTransfer app sender senderWalletProvider receiver amount = do
  [(preapprovalCid, preapproval)] <- queryFilter @TransferPreapproval app.dso (\co -> co.receiver == receiver.primaryParty)
  featuredAppRight <- queryFilter @FeaturedAppRight app.dso (\co -> co.provider == preapproval.provider)
  let receiverProviderFeaturedRight = listToOptional (fmap fst featuredAppRight)

  [(senderWalletInstall, _)] <- query @WalletAppInstall sender.primaryParty
  featuredAppRight <- queryFilter @FeaturedAppRight app.dso (\co -> co.provider == sender.primaryParty)
  let senderProviderFeaturedRight = listToOptional (fmap fst featuredAppRight)

  amulets <- query @Amulet sender.primaryParty
  context <- getPaymentTransferContextFeaturedApp app sender senderProviderFeaturedRight
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [senderWalletProvider.primaryParty] [sender.primaryParty, app.dso] $ exerciseCmd senderWalletInstall WalletAppInstall_ExecuteBatch with
    inputs = fmap ((\amulet -> InputAmulet amulet) . fst) amulets
    operations = [CO_TransferPreapprovalSend preapprovalCid receiverProviderFeaturedRight amount (Some "wallet-app-install-preapproval-send-description")]
    context
  pure (head outcomes)

checkAmuletPositions : AmuletUser -> [Decimal] -> Script ()
checkAmuletPositions owner expectedAmounts = do
    let ownerParty = owner.primaryParty
    actualAmulets <- queryFilter @Amulet ownerParty (\c -> c.owner == ownerParty)
    sort (map (._2.amount.initialAmount) actualAmulets) === sort expectedAmounts

testSinglerReceiverAmuletPaymentRequest : Script ()
testSinglerReceiverAmuletPaymentRequest = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app

  featureApp app provider1

  aliceInitialAmulets <- query @Amulet alice.primaryParty

  let paymentAmount = 41.5 -- chosen to not return sender change
  amulet <- tap app alice 42.0
  transferRequest <- createSingleReceiverPaymentRequest app
    provider1.primaryParty alice.primaryParty bob.primaryParty
    (PaymentAmount paymentAmount AmuletUnit)

  acceptedPaymentCid <- acceptPaymentRequest app alice aliceValidator.primaryParty None transferRequest amulet
  Some acceptedPayment <- queryContractId alice.primaryParty acceptedPaymentCid
  [(lockedAmuletCid, lockedAmulet)] <- query @LockedAmulet alice.primaryParty
  -- all of Alice's tapped amulet is used up
  aliceAmulets <- query @Amulet alice.primaryParty
  aliceAmulets === aliceInitialAmulets
  acceptedPayment === AcceptedAppPayment with
    sender = alice.primaryParty
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = paymentAmount)
      ]
    round = lockedAmulet.amulet.amount.createdAt
    reference = transferRequest

  AcceptedAppPayment_CollectResult [(receiver, amuletCid)] <- collectAcceptedPayment app provider1 acceptedPaymentCid
  receiver === bob.primaryParty

  Some amulet <- queryContractId bob.primaryParty amuletCid
  amulet.amount.initialAmount === paymentAmount

  pure ()

testExpiringAmuletPaymentRequest : Script ()
testExpiringAmuletPaymentRequest = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app

  transferRequest <- createSingleReceiverPaymentRequest app
    provider1.primaryParty alice.primaryParty bob.primaryParty
    (PaymentAmount 30.0 AmuletUnit)

  install <- submitMulti [alice.primaryParty, aliceValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice.primaryParty
    endUserName = "alice"
    dsoParty = app.dso
    validatorParty = aliceValidator.primaryParty

  -- Try expiring too early
  submitMultiMustFail [aliceValidator.primaryParty] [alice.primaryParty] $ exerciseCmd install
        WalletAppInstall_AppPaymentRequest_Expire with
          cid = transferRequest

  passTime (minutes 6)

  submitMulti [aliceValidator.primaryParty] [alice.primaryParty] $ exerciseCmd install
        WalletAppInstall_AppPaymentRequest_Expire with
          cid = transferRequest

  pure ()

testSingleReceiverUSDPaymentRequest : Script ()
testSingleReceiverUSDPaymentRequest = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToIssuanceWithPrice app 0.5
  runAmuletDepositBots app

  amulet <- tap app alice 62.0 -- Need to cover a 30USD payment with 1USD=2Amulet
  transferRequest <- createSingleReceiverPaymentRequest app
    provider1.primaryParty alice.primaryParty bob.primaryParty
    (PaymentAmount 30.0 USDUnit)

  acceptedPaymentCid <- acceptPaymentRequest app alice aliceValidator.primaryParty None transferRequest amulet
  Some acceptedPayment <- queryContractId alice.primaryParty acceptedPaymentCid
  [(lockedAmuletCid, lockedAmulet)] <- query @LockedAmulet alice.primaryParty
  [_, _] <- query @Amulet alice.primaryParty
  acceptedPayment === AcceptedAppPayment with
    sender = alice.primaryParty
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 60.0)
      ]
    round = lockedAmulet.amulet.amount.createdAt
    reference = transferRequest

  pure ()

testAmuletPaymentRequest : Script ()
testAmuletPaymentRequest = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToIssuanceWithPrice app 1.0
  runAmuletDepositBots app

  validatorUserId <- validateUserId "alice_validator"
  featuredValidator <- featureApp app (AmuletUser validatorUserId aliceValidator.primaryParty)

  -- retrieve the config
  config <- getAmuletConfig app
  let transferConfig = config.transferConfig
  amulet <- tap app alice 27.0
  transferRequest <-
    createPaymentRequest app provider1.primaryParty alice.primaryParty [
      (bob.primaryParty, PaymentAmount 15.0 AmuletUnit),
      (charlie.primaryParty, PaymentAmount 10.0 AmuletUnit)]
  acceptedPaymentCid <- acceptPaymentRequest app alice aliceValidator.primaryParty (Some featuredValidator) transferRequest amulet
  Some acceptedPayment <- queryContractId alice.primaryParty acceptedPaymentCid
  [(lockedAmulet, lockedAmuletPayload)] <- query @LockedAmulet alice.primaryParty
  lockedAmuletPayload.amulet.amount.initialAmount ===
    15.0 +
    10.0 +
    transferConfig.createFee.fee + chargeSteppedRate transferConfig.transferFee 15.0 +
    transferConfig.createFee.fee + chargeSteppedRate transferConfig.transferFee 10.0
  lockedAmuletPayload.lock.holders === map (.primaryParty) [bob, charlie, provider1]
  acceptedPayment === AcceptedAppPayment with
    sender = alice.primaryParty
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 15.0),
      (ReceiverAmuletAmount with receiver = charlie.primaryParty, amuletAmount = 10.0)
      ]
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmulet
    round = lockedAmuletPayload.amulet.amount.createdAt
    reference = transferRequest

  checkAmuletPositions alice [1.0, 1.615]
  checkAmuletPositions bob [1.0]
  checkAmuletPositions charlie [1.0]

  -- Check that the locked-amulet is visible to charlie
  [(charlieLockedAmuletCid, _)] <- query @LockedAmulet charlie.primaryParty
  charlieLockedAmuletCid === lockedAmulet


  result <- collectAcceptedPayment app alice acceptedPaymentCid

  case sortOn (._1) result.receiverAmulets of
    [(bob', bobAmulet), (charlie', charlieAmulet)] ->  do
      bob' === bob.primaryParty
      charlie' === charlie.primaryParty
      Some amulet <- queryContractId bob' bobAmulet
      amulet.amount.initialAmount === 15.0
      Some amulet <- queryContractId charlie' charlieAmulet
      amulet.amount.initialAmount === 10.0
    _ -> abort $ "Expected exactly two amulets but got " <> show result.receiverAmulets

  checkAmuletPositions alice [1.0, 1.615]
  checkAmuletPositions bob [1.0, 15.0]
  checkAmuletPositions charlie [1.0, 10.0]

  (_, round) <- getLatestActiveOpenRound app

  [(_, coupon)] <- query @AppRewardCoupon provider1.primaryParty
  let transferConfigAmulet = transferConfigAmuletFromOpenRound round
  coupon.amount ===
    transferConfigAmulet.transferFee.initialRate * (15.0 + 10.0) +
    transferConfigAmulet.createFee.fee * 2.0
  coupon.featured === False

  [(_, coupon)] <- query @AppRewardCoupon aliceValidator.primaryParty
  coupon.amount ===
    transferConfigAmulet.createFee.fee + -- for one locked amulet
    transferConfigAmulet.lockHolderFee.fee * 3.0 +
    transferConfigAmulet.extraFeaturedAppRewardAmount
  coupon.provider === aliceValidator.primaryParty
  coupon.featured === True

  pure ()

testAmuletPaymentCollectionRoundInLatestRoundMustFail : Script ()
testAmuletPaymentCollectionRoundInLatestRoundMustFail = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToIssuanceWithPrice app 1.0
  runAmuletDepositBots app

  amulet <- tap app alice 27.0
  transferRequest <-
    createPaymentRequest app provider1.primaryParty alice.primaryParty [
      (bob.primaryParty, PaymentAmount 15.0 AmuletUnit),
      (charlie.primaryParty, PaymentAmount 10.0 AmuletUnit)]


  acceptedPaymentCid <- acceptPaymentRequest app alice aliceValidator.primaryParty None transferRequest amulet

  Some acceptedPayment <- queryContractId alice.primaryParty acceptedPaymentCid

  runNextIssuance app

  collectAcceptedPaymentMustFail app alice acceptedPaymentCid

  collectAcceptedPaymentInRound app acceptedPayment.round alice acceptedPaymentCid

  pure ()

testUSDPaymentRequest : Script ()
testUSDPaymentRequest = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToIssuanceWithPrice app 0.5
  runAmuletDepositBots app

  amulet <- tap app alice 52.0
  transferRequest <-
    createPaymentRequest app provider1.primaryParty alice.primaryParty [
      (bob.primaryParty, PaymentAmount 10.0 USDUnit),
      (charlie.primaryParty, PaymentAmount 15.0 USDUnit)]
  acceptedPaymentCid <- acceptPaymentRequest app alice aliceValidator.primaryParty None transferRequest amulet
  Some acceptedPayment <- queryContractId alice.primaryParty acceptedPaymentCid
  [(lockedAmuletCid, lockedAmulet)] <- query @LockedAmulet alice.primaryParty
  acceptedPayment === AcceptedAppPayment with
    sender = alice.primaryParty
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 20.0),
      (ReceiverAmuletAmount with receiver = charlie.primaryParty, amuletAmount = 30.0)
      ]
    round = lockedAmulet.amulet.amount.createdAt
    reference = transferRequest

  pure ()

testMixedPaymentRequest : Script ()
testMixedPaymentRequest = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  advanceToIssuanceWithPrice app 0.5
  runAmuletDepositBots app

  amulet <- tap app alice 32.0
  transferRequest <-
    createPaymentRequest app provider1.primaryParty alice.primaryParty [
      (bob.primaryParty, PaymentAmount 10.0 AmuletUnit),
      (charlie.primaryParty, PaymentAmount 10.0 USDUnit)]
  acceptedPaymentCid <- acceptPaymentRequest app alice aliceValidator.primaryParty None transferRequest amulet
  Some acceptedPayment <- queryContractId alice.primaryParty acceptedPaymentCid
  [(lockedAmuletCid, lockedAmulet)] <- query @LockedAmulet alice.primaryParty
  acceptedPayment === AcceptedAppPayment with
    sender = alice.primaryParty
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 10.0),
      (ReceiverAmuletAmount with receiver = charlie.primaryParty, amuletAmount = 20.0)
      ]
    round = lockedAmulet.amulet.amount.createdAt
    reference = transferRequest

  pure ()

assertTerminatedPayment : Party -> ContractId AppPaymentRequest -> Script ()
assertTerminatedPayment p reference = do
  terminated <- queryFilter @TerminatedAppPayment p (\c -> c.reference == reference)
  unless (length terminated == 1) $ abort ("Expected one TerminatedAppPayment for " <> show reference <> " but got " <> show terminated)

testTerminatedPayments : Script ()
testTerminatedPayments = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app

  featureApp app provider1

  let paymentAmount = 41.5

  let createPaymentRequest = createSingleReceiverPaymentRequest app
        provider1.primaryParty alice.primaryParty bob.primaryParty
        (PaymentAmount paymentAmount AmuletUnit)

  paymentRequest <- createPaymentRequest
  submit alice.primaryParty $ exerciseCmd paymentRequest AppPaymentRequest_Reject
  assertTerminatedPayment alice.primaryParty paymentRequest

  paymentRequest <- createPaymentRequest
  submit bob.primaryParty $ exerciseCmd paymentRequest AppPaymentRequest_Withdraw
  assertTerminatedPayment alice.primaryParty paymentRequest

  let createAcceptedPayment = do
        amulet <- tap app alice 42.0
        paymentRequest <- createPaymentRequest
        accepted <- acceptPaymentRequest app alice aliceValidator.primaryParty None paymentRequest amulet
        pure (paymentRequest, accepted)

  (paymentRequest, acceptedPayment) <- createAcceptedPayment
  context <- getAppTransferContext app alice
  submitMulti [bob.primaryParty] [app.dso] $ exerciseCmd acceptedPayment (AcceptedAppPayment_Reject context)
  assertTerminatedPayment alice.primaryParty paymentRequest

  (paymentRequest, acceptedPayment) <- createAcceptedPayment
  context <- getAppTransferContext app alice
  let tickDuration = defaultAmuletConfig.tickDuration
  passTime (tickDuration + tickDuration + seconds 1) -- pass one full round of time
  submitMulti [alice.primaryParty, bob.primaryParty] [app.dso] $ exerciseCmd acceptedPayment (AcceptedAppPayment_Expire context)
  assertTerminatedPayment alice.primaryParty paymentRequest

  pure ()

testSuccessfulBatchAmuletPaymentRequests : Script ()
testSuccessfulBatchAmuletPaymentRequests = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app

  amulet <- tap app alice 42.0
  transferRequest <- createSingleReceiverPaymentRequest app
    provider1.primaryParty alice.primaryParty bob.primaryParty
    (PaymentAmount 1.0 AmuletUnit)
  transferRequest2 <-
    createPaymentRequest app provider1.primaryParty alice.primaryParty [
      (bob.primaryParty, PaymentAmount 2.0 AmuletUnit),
      (alice.primaryParty, PaymentAmount 2.0 AmuletUnit)]

  let endUserName = "wallet_service_participant_user"
  install <- submitMulti [alice.primaryParty, aliceValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice.primaryParty
    endUserName = endUserName
    dsoParty = app.dso
    validatorParty = aliceValidator.primaryParty

  context <- getPaymentTransferContext app alice
  executeBatchResult <- submitMulti [aliceValidator.primaryParty] [alice.primaryParty, app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    context
    inputs = [InputAmulet amulet]
    operations = [CO_AppPayment transferRequest, CO_AppPayment transferRequest2]

  let [COO_AcceptedAppPayment payment1Cid, COO_AcceptedAppPayment payment2Cid] = executeBatchResult.outcomes
  Some acceptedPayment <- queryContractId alice.primaryParty payment1Cid
  Some acceptedPayment2 <- queryContractId alice.primaryParty payment2Cid
  lockedAmulets <- query @LockedAmulet alice.primaryParty
  let [(lockedAmuletCid, lockedAmulet), (lockedAmuletCid2, lockedAmulet2)] = sortOn (\(_, lockedAmulet) -> lockedAmulet.amulet.amount.initialAmount) lockedAmulets
  [_, _] <- query @Amulet alice.primaryParty

  -- check results
  executeBatchResult.endUserName === endUserName
  acceptedPayment === AcceptedAppPayment with
    sender = alice.primaryParty
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid
    amuletReceiverAmounts = [
      ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 1.0 ]
    round = lockedAmulet.amulet.amount.createdAt
    reference = transferRequest

  acceptedPayment2 === AcceptedAppPayment with
    sender = alice.primaryParty
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 2.0),
      (ReceiverAmuletAmount with receiver = alice.primaryParty, amuletAmount = 2.0)
      ]
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid2
    round = lockedAmulet2.amulet.amount.createdAt
    reference = transferRequest2

  pure ()


testInsufficientFundsBatchAmuletPaymentRequests : Script ()
testInsufficientFundsBatchAmuletPaymentRequests = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runAmuletDepositBots app
  amulet <- tap app alice 42.0

  install <- submitMulti [alice.primaryParty, aliceValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice.primaryParty
    endUserName = "wallet_service_participant_user"
    dsoParty = app.dso
    validatorParty = aliceValidator.primaryParty

  transferRequest3 <- createSingleReceiverPaymentRequest app
    provider1.primaryParty alice.primaryParty bob.primaryParty
    (PaymentAmount 10000.0 AmuletUnit)
  transferRequest4 <-
    createPaymentRequest app provider1.primaryParty alice.primaryParty [
      (bob.primaryParty, PaymentAmount 3.0 AmuletUnit),
      (alice.primaryParty, PaymentAmount 3.0 AmuletUnit)]
  -- trying to fulfill the request for 10,000 Amulet will fail
  context <- getPaymentTransferContext app alice
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [aliceValidator.primaryParty] [alice.primaryParty, app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet amulet]
    operations = [CO_AppPayment transferRequest3, CO_AppPayment transferRequest4]
    context

  -- first command errors, second command is still executed
  let [COO_Error _, COO_AcceptedAppPayment payment3Cid] = outcomes
  Some acceptedPayment4 <- queryContractId alice.primaryParty payment3Cid

  -- Only one command executed, so there's only one locked amulet
  lockedAmulets <- query @LockedAmulet alice.primaryParty
  let [(lockedAmuletCid4, lockedAmulet4)] = lockedAmulets

  acceptedPayment4 === AcceptedAppPayment with
    sender = alice.primaryParty
    amuletReceiverAmounts = [
      (ReceiverAmuletAmount with receiver = bob.primaryParty, amuletAmount = 3.0),
      (ReceiverAmuletAmount with receiver = alice.primaryParty, amuletAmount = 3.0)
      ]
    provider = provider1.primaryParty
    dso = app.dso
    lockedAmulet = lockedAmuletCid4
    round = lockedAmulet4.amulet.amount.createdAt
    reference = transferRequest4

  pure ()


-- Smoke test - this functionality is tested more extensively in the WalletIntegrationTests
testCO_MergeTransferInputs : Script ()
testCO_MergeTransferInputs = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app

  amulet <- tap app alice 42.0
  amulet2 <- tap app alice 43.0

  install <- submitMulti [alice.primaryParty, aliceValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice.primaryParty
    endUserName = "wallet_service_participant_user"
    dsoParty = app.dso
    validatorParty = aliceValidator.primaryParty


  context <- getPaymentTransferContext app alice

  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [aliceValidator.primaryParty] [alice.primaryParty, app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet amulet, InputAmulet amulet2]
    operations = [CO_MergeTransferInputs]
    context

  let [COO_MergeTransferInputs (Some resultAmulet)] = outcomes
  aliceAmulets <- query @Amulet alice.primaryParty
  let [_, (mergedAmuletCid, _)] = sortOn (\(_, p) -> p.amount.initialAmount) aliceAmulets
  resultAmulet === mergedAmuletCid

  pure ()

testTransferPreapproval : Script ()
testTransferPreapproval = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app

  -- test CO_CreateExternalPartySetupProposal
  -- -----------------------------------------

  now <- getTime
  [(_, amuletRules)] <- query @AmuletRules app.dso
  let createFee = (Splice.Schedule.getValueAsOf now amuletRules.configSchedule).transferConfig.createFee.fee

  install <- submitMulti [aliceValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = aliceValidator.primaryParty
    endUserName = "alice_validator_user"
    dsoParty = app.dso
    validatorParty = aliceValidator.primaryParty

  let initialAmount = 42.0
  amulet <- tap app aliceValidator initialAmount
  context <- getPaymentTransferContext app aliceValidator
  appRewardsBefore <- query @AppRewardCoupon aliceValidator.primaryParty
  validatorRewardsBefore <- query @ValidatorRewardCoupon aliceValidator.primaryParty

  let duration = days 1
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [aliceValidator.primaryParty] [aliceValidator.primaryParty, app.dso] $
    exerciseCmd install WalletAppInstall_ExecuteBatch with
      inputs = [InputAmulet amulet]
      operations = [CO_CreateExternalPartySetupProposal alice.primaryParty (now `addRelTime` duration)]
      context

  let [COO_CreateExternalPartySetupProposal proposalCid] = outcomes
  Some proposal <- queryContractId aliceValidator.primaryParty proposalCid
  proposal === ExternalPartySetupProposal with
    user = alice.primaryParty
    validator = aliceValidator.primaryParty
    dso = app.dso
    createdAt = now
    preapprovalExpiresAt = (now `addRelTime` duration)

  -- Check results of TransferPreapproval purchase
  (preapprovalFee, _) <- calculateTransferPreapprovalFee app duration
  -- Setup creates 1 amulet of value 1. The input amulet is split to pay the fee, so createFees are also charged
  checkAmuletPositions aliceValidator [1.0, initialAmount - preapprovalFee - 2.0*createFee]
  appRewardsAfter <- query @AppRewardCoupon aliceValidator.primaryParty
  validatorRewardsAfter <- query @ValidatorRewardCoupon aliceValidator.primaryParty
  appRewardsAfter === appRewardsBefore
  let Some [(_, newCoupon)] = stripPrefix validatorRewardsBefore validatorRewardsAfter
  newCoupon.user === aliceValidator.primaryParty
  newCoupon.amount === preapprovalFee + createFee

  result <- submit alice.primaryParty $ exerciseCmd proposalCid ExternalPartySetupProposal_Accept {}
  let preapprovalCid = result.transferPreapprovalCid
  Some preapproval <- queryContractId alice.primaryParty preapprovalCid

  -- test CO_RenewTransferPreapproval
  -- --------------------------------

  let newExpiresAt = preapproval.expiresAt `addRelTime` duration
  aliceValidatorAmulets <- query @Amulet aliceValidator.primaryParty
  let [_, (changeAmuletCid, _)] = sortOn (\(_, p) -> p.amount.initialAmount) aliceValidatorAmulets
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [aliceValidator.primaryParty] [aliceValidator.primaryParty, app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet changeAmuletCid]
    operations = [CO_RenewTransferPreapproval preapprovalCid newExpiresAt]
    context

  let [COO_RenewTransferPreapproval preapprovalCid2] = outcomes
  preapprovalCid2 =/= preapprovalCid
  Some preapproval2 <- queryContractId aliceValidator.primaryParty preapprovalCid2
  preapproval2 === preapproval with
    lastRenewedAt = now
    expiresAt = newExpiresAt

  checkAmuletPositions aliceValidator [1.0, initialAmount - 2.0*preapprovalFee - 4.0*createFee]

  -- test CO_TransferPreapprovalSend
  -- --------------------------------

  tap app bob 42.0

  submitMulti [bob.primaryParty, bobValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = bob.primaryParty
    endUserName = "bob_user"
    dsoParty = app.dso
    validatorParty = bobValidator.primaryParty

  -- Send via pre-approval works for unfeatured senders
  outcome <- sendPreapprovedTransfer app bob bobValidator alice 10.0
  let COO_TransferPreapprovalSend (Some changeAmuletCid) = outcome
  bobAmulets <- query @Amulet bob.primaryParty
  let [(mergedAmuletCid, _)] = sortOn (\(_, p) -> p.amount.initialAmount) bobAmulets
  mergedAmuletCid === changeAmuletCid
  checkAmuletPositions alice [1.0, 10.0] -- setup creates an initial amulet of value 1

  featureApp app bob

  -- Send via pre-approval works for featured senders
  outcome <- sendPreapprovedTransfer app bob bobValidator alice 20.0
  let COO_TransferPreapprovalSend (Some changeAmuletCid) = outcome
  bobAmulets <- query @Amulet bob.primaryParty
  let [(mergedAmuletCid, _)] = sortOn (\(_, p) -> p.amount.initialAmount) bobAmulets
  mergedAmuletCid === changeAmuletCid
  checkAmuletPositions alice [1.0, 10.0, 20.0]

  -- test CO_AcceptTransferPreapprovalProposal
  -- ------------------------------------------

  now <- getTime
  bobValidatorAmulet <- tap app bobValidator 10.0
  bobValidatorPaymentContext <- getPaymentTransferContext app bobValidator

  preapprovalProposalCid <- submit bob.primaryParty $ createCmd TransferPreapprovalProposal with
    receiver = bob.primaryParty
    provider = bobValidator.primaryParty

  bobValidatorInstall <- submitMulti [bobValidator.primaryParty] [] $ createCmd $ WalletAppInstall with
    endUserParty = bobValidator.primaryParty
    endUserName = "bob_validator_user"
    dsoParty = app.dso
    validatorParty = bobValidator.primaryParty

  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [bobValidator.primaryParty] [bobValidator.primaryParty, app.dso] $
    exerciseCmd bobValidatorInstall WalletAppInstall_ExecuteBatch with
      inputs = [InputAmulet bobValidatorAmulet]
      operations = [CO_AcceptTransferPreapprovalProposal preapprovalProposalCid (now `addRelTime` duration)]
      context = bobValidatorPaymentContext

  let [COO_AcceptTransferPreapprovalProposal bobPreapprovalCid] = outcomes
  Some bobPreapproval <- queryContractId bob.primaryParty bobPreapprovalCid
  bobPreapproval === TransferPreapproval with
    receiver = bob.primaryParty
    provider = bobValidator.primaryParty
    dso = app.dso
    validFrom = now
    lastRenewedAt = now
    expiresAt = now `addRelTime` duration

  checkAmuletPositions bobValidator [1.0, 10.0 - preapprovalFee - 2.0*createFee]

  pure ()


-- Test to sanity check that buying member traffic works
testBuyMemberTraffic : Script ()
testBuyMemberTraffic = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers
  runNextIssuance app
  runAmuletDepositBots app
  (_, openRound) <- getLatestOpenRound app

  now <- getTime
  [(amuletRulesCid, amuletRules)] <- query @AmuletRules app.dso
  let decentralizedSynchronizerConfig = (Splice.Schedule.getValueAsOf now amuletRules.configSchedule).decentralizedSynchronizer
  let synchronizerId = decentralizedSynchronizerConfig.activeSynchronizer
  let migrationId = 0
  let testParticipantId = "alice_validator_participant_id"

  -- Test that self top-ups work

  -- set the validator up with some amulet and its own wallet install contract
  submit aliceValidator.primaryParty $ createCmd $ WalletAppInstall with
    endUserParty = aliceValidator.primaryParty
    endUserName = "alice_validator_wallet_user"
    dsoParty = app.dso
    validatorParty = aliceValidator.primaryParty

  -- create initial validator top-up state contract
  topupStateCid <- submit aliceValidator.primaryParty $
    createCmd (initialValidatorTopUpState app.dso aliceValidator.primaryParty testParticipantId synchronizerId)

  -- test that buying less extra traffic than the configured min topup amount fails
  let minTopupAmount = decentralizedSynchronizerConfig.fees.minTopupAmount
  outcome <- executeAmuletOperation app aliceValidator $
    CO_BuyMemberTraffic (minTopupAmount-1) testParticipantId synchronizerId migrationId (minutes 1) (Some topupStateCid)
  outcome === COO_Error (ITR_InsufficientTopupAmount (minTopupAmount-1) minTopupAmount)

  -- test that providing an invalid decentralized synchronizer ID fails
  let invalidSynchronizerId = synchronizerId <> "_invalid"
  invalidTopupStateCid <- submit aliceValidator.primaryParty $
    createCmd (initialValidatorTopUpState app.dso aliceValidator.primaryParty testParticipantId invalidSynchronizerId)
  outcome <- executeAmuletOperation app aliceValidator $
    CO_BuyMemberTraffic (minTopupAmount-1) testParticipantId invalidSynchronizerId migrationId (minutes 1) (Some invalidTopupStateCid)
  outcome === COO_Error (ITR_UnknownSynchronizer invalidSynchronizerId)
  submit aliceValidator.primaryParty $ archiveCmd invalidTopupStateCid

  -- test that creating the initial traffic contract works
  before <- query @Amulet aliceValidator.primaryParty
  r <- executeAmuletOperation app aliceValidator $
    CO_BuyMemberTraffic minTopupAmount testParticipantId synchronizerId migrationId (minutes 1) (Some topupStateCid)
  COO_BuyMemberTraffic trafficCid1 <- pure r
  after <- query @Amulet aliceValidator.primaryParty
  before === after

  -- validate the state of the member traffic contract
  Some traffic1 <- queryContractId @MemberTraffic app.dso trafficCid1
  (amuletSpent, usdSpent) <- calculateSynchronizerFees app minTopupAmount
  traffic1.totalPurchased === minTopupAmount
  traffic1.numPurchases === 1
  traffic1.amuletSpent === amuletSpent
  traffic1.usdSpent === usdSpent

  -- validate that the topup state got updated
  [(topupStateCid2, topupState2)] <- query @ValidatorTopUpState aliceValidator.primaryParty
  topupStateCid2 =/= topupStateCid
  topupState2.lastPurchasedAt === now

  -- check that no app reward coupons were issued to aliceValidator
  [] <- query @AppRewardCoupon app.dso

  -- check that a single validator reward coupon was issued over the full purchase amount
  [(_, coupon)] <- query @ValidatorRewardCoupon aliceValidator.primaryParty
  coupon === ValidatorRewardCoupon with
    dso = app.dso
    round = Round 2
    amount = amuletSpent
    user = aliceValidator.primaryParty

  -- topping up too soon fails
  outcome <- executeAmuletOperation app aliceValidator $
    CO_BuyMemberTraffic minTopupAmount testParticipantId synchronizerId migrationId (minutes 1) (Some topupStateCid2)
  outcome === COO_Error (ITR_Other ("The requirement 'enough time has elapsed since the last topup' was not met."))

  -- once a minute has passed, the same topup succeeds
  passTime (minutes 1)
  COO_BuyMemberTraffic trafficCid2 <- executeAmuletOperation app aliceValidator $
    CO_BuyMemberTraffic minTopupAmount testParticipantId synchronizerId migrationId (minutes 1) (Some topupStateCid2)
  Some traffic2 <- queryContractId @MemberTraffic app.dso trafficCid2

  -- check the app reward coupons once more
  [] <- query @AppRewardCoupon app.dso

  -- Test that third-party top-ups work

  -- advance rounds to ensure that reward coupons issued have a different round number
  runNextIssuance app
  (_, openRound2) <- getLatestOpenRound app
  openRound2.round.number === openRound.round.number + 1

  -- create a wallet install contract and tap some amulets for provider1 validator
  submit provider1Validator.primaryParty $ createCmd $ WalletAppInstall with
    endUserParty = provider1Validator.primaryParty
    endUserName = "provider1_validator_wallet_user"
    dsoParty = app.dso
    validatorParty = provider1Validator.primaryParty
  _ <- tap app provider1Validator 10.0

  -- provider1 purchases extra traffic for the same participant
  COO_BuyMemberTraffic providerTrafficCid <- executeAmuletOperation app provider1Validator $
    CO_BuyMemberTraffic (minTopupAmount + 1) testParticipantId synchronizerId migrationId (minutes 1) None

  -- validate the state of the member traffic contract
  Some providerTraffic <- queryContractId @MemberTraffic app.dso providerTrafficCid
  let totalPurchased = minTopupAmount + 1
  (amuletSpent, usdSpent) <- calculateSynchronizerFees app totalPurchased
  providerTraffic.totalPurchased === totalPurchased
  providerTraffic.numPurchases === 1
  providerTraffic.amuletSpent === amuletSpent
  providerTraffic.usdSpent === usdSpent

  -- check that the app reward coupons were issued to the provider
  [] <- query @AppRewardCoupon provider1Validator.primaryParty

  -- Test that top-ups by means of BuyTrafficRequest contracts work

  -- advance rounds to ensure that reward coupons issued have a different round number
  runNextIssuance app
  (_, openRound3) <- getLatestOpenRound app
  openRound3.round.number === openRound2.round.number + 1

  -- create a wallet install contract and tap some amulets for provider2
  provider2Install <- submitMulti [provider2.primaryParty, provider2Validator.primaryParty] [] $ createCmd $ WalletAppInstall with
      endUserParty = provider2.primaryParty
      endUserName = "provider2_wallet_user"
      dsoParty = app.dso
      validatorParty = provider2Validator.primaryParty
  _ <- tap app provider2 10.0

  let createTrafficRequest amount memberId synchronizerId trackingId expiresAt = do
      result <- submitMulti [provider2Validator.primaryParty] [provider2.primaryParty] $
          exerciseCmd provider2Install $ WalletAppInstall_CreateBuyTrafficRequest with
            trafficAmount = amount
            memberId = memberId
            synchronizerId = synchronizerId
            migrationId = 0
            trackingId = trackingId
            expiresAt = expiresAt
      return result.buyTrafficRequest

  now <- getTime
  -- time-expired traffic requests cannot be completed or cancelled, only archived
  request1 <- createTrafficRequest minTopupAmount testParticipantId synchronizerId "request1" now
  COO_Error (ITR_Other ("The requirement 'Contract has not expired' was not met.")) <- executeAmuletOperation app provider2 $
    CO_CompleteBuyTrafficRequest request1
  submitMustFail provider2.primaryParty $ exerciseCmd request1 BuyTrafficRequest_Cancel with reason = "not required"
  result <- submit provider2.primaryParty $ exerciseCmd request1 BuyTrafficRequest_Expire
  let trackingInfo = result.trackingInfo
  trackingInfo.endUserParty === provider2.primaryParty
  trackingInfo.trackingId === "request1"

  -- unexpired traffic requests are completed successfully
  request2 <- createTrafficRequest minTopupAmount testParticipantId synchronizerId "request2" (now `addRelTime` minutes 1)
  COO_CompleteBuyTrafficRequest (requestTrafficCid, trackingInfo) <- executeAmuletOperation app provider2 $
    CO_CompleteBuyTrafficRequest request2
  Some requestedTraffic <- queryContractId @MemberTraffic app.dso requestTrafficCid
  requestedTraffic.totalPurchased === minTopupAmount
  requestedTraffic.memberId === testParticipantId
  requestedTraffic.synchronizerId === synchronizerId
  trackingInfo.trackingId === "request2"
  trackingInfo.endUserParty === provider2.primaryParty
  -- check that no app reward coupons were issued to the provider
  [] <- query @AppRewardCoupon provider2.primaryParty

  -- check that traffic requests can be cancelled by the requester
  request3 <- createTrafficRequest minTopupAmount testParticipantId synchronizerId "request3" (now `addRelTime` minutes 1)
  result <- submit provider2.primaryParty $
    exerciseCmd request3 BuyTrafficRequest_Cancel with reason = "not required"
  let trackingInfo = result.trackingInfo
  trackingInfo.trackingId === "request3"
  trackingInfo.endUserParty === provider2.primaryParty
  None <- queryContractId @BuyTrafficRequest provider2.primaryParty request3

  -- Merging traffic contracts

  -- test that the SVs can merge multiple member traffic contracts
  let trafficCids = [trafficCid1, trafficCid2, providerTrafficCid, requestTrafficCid]
  submit app.dso $ exerciseCmd amuletRulesCid AmuletRules_MergeMemberTrafficContracts with trafficCids
  [(mergedTrafficCid, mergedTraffic)] <- queryFilter @MemberTraffic app.dso (\t -> t.memberId == testParticipantId)
  assert $ notElem mergedTrafficCid trafficCids
  mergedTraffic.totalPurchased === 4 * minTopupAmount + 1
  mergedTraffic.numPurchases === 4
  mergedTraffic.usdSpent === traffic1.usdSpent + traffic2.usdSpent + providerTraffic.usdSpent + requestedTraffic.usdSpent
  mergedTraffic.amuletSpent === traffic1.amuletSpent + traffic2.amuletSpent + providerTraffic.amuletSpent + requestedTraffic.amuletSpent

  -- at least 1 contract must be provided to merge
  submitMustFail app.dso $ exerciseCmd amuletRulesCid AmuletRules_MergeMemberTrafficContracts with
    trafficCids = []

  pure ()


testInsufficientFundsBatchSubscriptions : Script ()
testInsufficientFundsBatchSubscriptions = script do
  app <- setupApp
  runNextIssuance app
  runAmuletDepositBots app

  validator <- setupValidator app "validator1"
  alice <- setupUser app "alice" validator
  pizzeria <- setupUser app "pizzeria" validator
  provider <- setupUser app "la_famiglia" validator

  install <- submitMulti [alice.primaryParty, validator] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice.primaryParty
    endUserName = "wallet_service_participant_user"
    dsoParty = app.dso
    validatorParty = validator

  let payData = SubscriptionPayData with
        paymentInterval = days 28
        paymentDuration = days 1
        paymentAmount = PaymentAmount 10.0 USDUnit

  let subscriptionData = SubscriptionData with
        sender = alice.primaryParty
        receiver = pizzeria.primaryParty
        provider = provider.primaryParty
        dso = app.dso
        description = "test subscription"

  subscriptionRequestCid <- submitMulti [alice.primaryParty, pizzeria.primaryParty, provider.primaryParty] [] $ createCmd (SubscriptionRequest subscriptionData payData)

  context <- getPaymentTransferContext app alice
  amulet <- tap  app alice 5.0
  -- TODO(#2957): remove read-as DSO party.
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [alice.primaryParty, validator] [app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet amulet]
    operations = [CO_SubscriptionAcceptAndMakeInitialPayment subscriptionRequestCid]
    context

  outcomes === [COO_Error (ITR_InsufficientFunds (5.17))]

  amulet <- tap app alice 15.0
  -- TODO(#2957): remove read-as DSO party.
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [alice.primaryParty, validator] [app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet amulet]
    operations = [CO_SubscriptionAcceptAndMakeInitialPayment subscriptionRequestCid]
    context
  initialPaymentCid <- case outcomes of
    [COO_SubscriptionInitialPayment cid] -> pure cid
    _ -> abort $ "Expected initial subscription payment to succeed but got " <> show outcomes

  (_, subscriptionIdleStateCid, _) <- collectInitialSubscriptionPayment app provider pizzeria alice.primaryParty initialPaymentCid

  passTime (days 27)
  runNextIssuance app
  amulet <- tap app alice 5.0
  -- TODO(#2957): remove read-as DSO party.
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [alice.primaryParty, validator] [app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet amulet]
    operations = [CO_SubscriptionMakePayment subscriptionIdleStateCid]
    context
  outcomes === [COO_Error (ITR_InsufficientFunds (5.17))]

  amulet <- tap app alice 15.0
  -- TODO(#2957): remove read-as DSO party.
  WalletAppInstall_ExecuteBatchResult { outcomes } <- submitMulti [alice.primaryParty, validator] [app.dso] $ exerciseCmd install WalletAppInstall_ExecuteBatch with
    inputs = [InputAmulet amulet]
    operations = [CO_SubscriptionMakePayment subscriptionIdleStateCid]
    context
  case outcomes of
    [COO_SubscriptionPayment _] -> pure ()
    _ -> abort $ "Expected subscription payment to succeed but got " <> show outcomes
  pure ()

testTokenStandardTransfer : Script ()
testTokenStandardTransfer = script do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig

  aliceValidator <- allocateParty "aliceValidator"
  alice <- allocateParty "alice"

  bobValidator <- allocateParty "bobValidator"
  bob <- allocateParty "bob"

  aliceInstall <- submitMulti [alice, aliceValidator] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice
    endUserName = "alice_user"
    dsoParty = registry.dso
    validatorParty = aliceValidator

  bobInstall <- submitMulti [bob, bobValidator] [] $ createCmd $ WalletAppInstall with
    endUserParty = bob
    endUserName = "bob_user"
    dsoParty = registry.dso
    validatorParty = bobValidator


  holdingCid <- AmuletRegistry.tapFaucet registry alice 100.0

  now <- getTime

  let
    defaultTransfer = Api.Token.TransferInstructionV1.Transfer with
      sender = alice
      receiver = bob
      amount = 10.0
      instrumentId = registry.instrumentId
      requestedAt = now
      executeBefore = now `addRelTime` days 1
      inputHoldingCids = []
      meta = emptyMetadata

  let transfer = defaultTransfer with
        sender = alice
        receiver = bob
        inputHoldingCids = [holdingCid]

  enrichedChoice <- RegistryApi.getTransferFactory registry TransferFactory_Transfer with
    expectedAdmin = registry.dso
    transfer
    extraArgs = emptyExtraArgs

  result <- submitMulti [aliceValidator] [alice, registry.dso] $ exerciseCmd aliceInstall WalletAppInstall_TransferFactory_Transfer with
    transferFactoryCid = enrichedChoice.factoryCid
    transferArg = enrichedChoice.arg
  Api.Token.TransferInstructionV1.TransferInstructionResult_Pending aliceInstrCid <- pure result.output
  let change1 = result.senderChangeCids

  context <- RegistryApi.getTransferInstruction_WithdrawContext registry aliceInstrCid emptyMetadata
  result <- submitMulti [aliceValidator] [alice, registry.dso] $ exerciseCmd aliceInstall WalletAppInstall_TransferInstruction_Withdraw with
    transferInstructionCid = aliceInstrCid
    withdrawArg = Api.Token.TransferInstructionV1.TransferInstruction_Withdraw with
      extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  Api.Token.TransferInstructionV1.TransferInstructionResult_Failed === result.output
  let change2 = result.senderChangeCids

  result <- submitMulti [aliceValidator] [alice, registry.dso] $ exerciseCmd aliceInstall WalletAppInstall_TransferFactory_Transfer with
    transferFactoryCid = enrichedChoice.factoryCid
    transferArg = Api.Token.TransferInstructionV1.TransferFactory_Transfer with
      expectedAdmin = registry.dso
      transfer = enrichedChoice.arg.transfer with
        inputHoldingCids = change1 ++ change2
      extraArgs = enrichedChoice.arg.extraArgs

  Api.Token.TransferInstructionV1.TransferInstructionResult_Pending aliceInstrCid <- pure result.output
  let change3 = result.senderChangeCids

  result <- submitMulti [bobValidator] [bob, registry.dso] $ exerciseCmd bobInstall WalletAppInstall_TransferInstruction_Reject with
    transferInstructionCid = aliceInstrCid
    rejectArg = Api.Token.TransferInstructionV1.TransferInstruction_Reject with
      extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  Api.Token.TransferInstructionV1.TransferInstructionResult_Failed === result.output
  let change4 = result.senderChangeCids

  result <- submitMulti [aliceValidator] [alice, registry.dso] $ exerciseCmd aliceInstall WalletAppInstall_TransferFactory_Transfer with
    transferFactoryCid = enrichedChoice.factoryCid
    transferArg =  Api.Token.TransferInstructionV1.TransferFactory_Transfer with
      expectedAdmin = registry.dso
      transfer = enrichedChoice.arg.transfer with
        inputHoldingCids = change3 ++ change4
      extraArgs = enrichedChoice.arg.extraArgs

  Api.Token.TransferInstructionV1.TransferInstructionResult_Pending aliceInstrCid <- pure result.output
  context <- RegistryApi.getTransferInstruction_AcceptContext registry aliceInstrCid emptyMetadata

  result <- submitMulti [bobValidator] [bob, registry.dso] $ exerciseCmd bobInstall WalletAppInstall_TransferInstruction_Accept with
    transferInstructionCid = aliceInstrCid
    acceptArg =  Api.Token.TransferInstructionV1.TransferInstruction_Accept with
      extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  Api.Token.TransferInstructionV1.TransferInstructionResult_Completed _ <- pure result.output

  pure ()

testTokenStandardAllocate : Script ()
testTokenStandardAllocate = script do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig

  aliceValidator <- allocateParty "aliceValidator"
  alice <- allocateParty "alice"

  provider <- allocateParty "provider"

  aliceInstall <- submitMulti [alice, aliceValidator] [] $ createCmd $ WalletAppInstall with
    endUserParty = alice
    endUserName = "alice_user"
    dsoParty = registry.dso
    validatorParty = aliceValidator

  let amuletId = registry.instrumentId
  let mkTransfer sender receiver amount = Api.Token.AllocationV1.TransferLeg with
        sender
        receiver
        amount
        instrumentId = amuletId
        meta = emptyMetadata
  let aliceLeg = mkTransfer alice alice 100.0

  -- alice proposes trade with herself
  proposalCid <- submit alice $ createCmd OTCTradeProposal with
    venue = provider
    tradeCid = None
    transferLegs = TextMap.fromList [("leg0", aliceLeg)]
    approvers = [alice]

  -- provider initiates settlement
  now <- getTime
  let settleBefore = now `addRelTime` hours 2
  _ <- submit provider $
    exerciseCmd proposalCid OTCTradeProposal_InitiateSettlement with
      prepareUntil = now `addRelTime` hours 1
      settleBefore

  [aliceAlloc] <- WalletClient.listRequestedAllocations alice amuletId

  holdingCid <- AmuletRegistry.tapFaucet registry alice 200.0

  enrichedChoice <- RegistryApi.getAllocationFactory registry Api.Token.AllocationInstructionV1.AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = aliceAlloc
    inputHoldingCids = [holdingCid]
    requestedAt = now
    extraArgs = emptyExtraArgs

  result <- submitMulti [aliceValidator] [alice, registry.dso] $ exerciseCmd aliceInstall WalletAppInstall_AllocationFactory_Allocate with
    allocationFactory = enrichedChoice.factoryCid
    allocateArg = enrichedChoice.arg

  Api.Token.AllocationInstructionV1.AllocationInstructionResult_Completed allocationCid <- pure result.output

  context <- RegistryApi.getAllocation_WithdrawContext registry allocationCid emptyMetadata

  _ <- submitMulti [aliceValidator] [alice, registry.dso] $ exerciseCmd aliceInstall WalletAppInstall_Allocation_Withdraw with
    allocationCid = allocationCid
    withdrawArg = Api.Token.AllocationV1.Allocation_Withdraw with
      extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  None <- queryInterfaceContractId alice allocationCid

  pure ()


-- Utilities
------------

withError : CanAbort m => [AmuletOperationOutcome] -> (InvalidTransferReason -> m a) -> m a
withError outcomes f = case outcomes of
  [COO_Error e] -> f e
  _ -> abort $ "Expected COO_Error but got " <> show outcomes

executeAmuletOperation : AmuletApp -> AmuletUser -> AmuletOperation -> Script AmuletOperationOutcome
executeAmuletOperation app user op = do
  [(installCid, install)] <- queryFilter @WalletAppInstall user.primaryParty (\i -> i.endUserParty == user.primaryParty)
  context <- getPaymentTransferContext app user
  amulets <- queryFilter @Amulet user.primaryParty (\amulet -> amulet.owner == user.primaryParty)
  -- TODO(#2957): remove read-as DSO party.
  result <- submitMulti [install.validatorParty] [install.endUserParty, install.validatorParty, app.dso] $
    exerciseCmd installCid WalletAppInstall_ExecuteBatch with
      inputs = [InputAmulet amulet._1 | amulet <- amulets]
      operations = [op]
      context
  let [outcome] = result.outcomes
  pure outcome

calculateSynchronizerFees : AmuletApp -> Int -> Script (Decimal, Decimal)
calculateSynchronizerFees app trafficAmount = do
  now <- getTime
  [(_, amuletRules)] <- query @AmuletRules app.dso
  let decentralizedSynchronizerConfig = (Splice.Schedule.getValueAsOf now amuletRules.configSchedule).decentralizedSynchronizer
  let extraTrafficPrice = decentralizedSynchronizerConfig.fees.extraTrafficPrice
  (_, openRound) <- getLatestOpenRound app
  let amuletPrice = openRound.amuletPrice
  let trafficCostUsd = intToDecimal trafficAmount / 1e6 * extraTrafficPrice
  let trafficCostCc = trafficCostUsd / amuletPrice
  pure (trafficCostCc, trafficCostUsd)

calculateTransferPreapprovalFee : AmuletApp -> RelTime -> Script (Decimal, Decimal)
calculateTransferPreapprovalFee app duration = do
  [(_, amuletRules)] <- query @AmuletRules app.dso
  now <- getTime
  let configUsd = getValueAsOf now amuletRules.configSchedule
  let preapprovalFeeUsd = (relTimeToDays duration) * (fromOptional defaultTransferPreapprovalFee configUsd.transferPreapprovalFee)
  (_, openRound) <- getLatestOpenRound app
  let amuletPrice = openRound.amuletPrice
  let preapprovalFeeAmulet = preapprovalFeeUsd / amuletPrice
  return (preapprovalFeeAmulet, preapprovalFeeUsd)
