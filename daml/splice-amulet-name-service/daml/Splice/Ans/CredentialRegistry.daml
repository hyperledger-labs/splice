-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Credential registry implementation provided as part of the Amulet Name Service (ANS)
-- run as port of the Decentralized Synchronizer Operations (DSO).
module Splice.Ans.CredentialRegistry where

import DA.Assert
import DA.Foldable (forA_)
import DA.Time
import DA.Text as T
import DA.TextMap as TextMap

import Splice.Types
import Splice.Util

import Splice.Api.Token.MetadataV1 (emptyMetadata)
import Splice.Api.Credential.RegistryV1 qualified as RegistryV1


-- | Credential registry factory contract.
template AnsCredentialRegistry with
    dso : Party
  where
    signatory dso

    interface instance RegistryV1.CredentialFactory for AnsCredentialRegistry where
      view = RegistryV1.CredentialFactoryView with
        admin = dso
        meta = emptyMetadata

      credentialFactory_updateCredentialsImpl _self RegistryV1.CredentialFactory_UpdateCredentials{..} = do
        assertDeadlineExceeded "newCreatedAt" newCreatedAt
        -- TODO: make configurable
        let defaultExpiresAt = addRelTime newCreatedAt (days 90) -- default to 90 day expiry

        -- check admin
        require "admin matches" (admin == dso)

        -- archive old credential records
        forA_ oldCredentials \oldCredentialCid -> do
          let ansCredentialCid = fromInterfaceContractId @AnsCredentialRecord oldCredentialCid
          oldCredential <- fetchAndArchive (ForOwner with dso; owner = holder) ansCredentialCid
          require "issuer matches" (oldCredential.issuer == issuer)

        -- create new records
        newCredentials <- forA newCredentialClaims \claims -> do
          toInterfaceContractId <$> create AnsCredentialRecord with
            dso
            issuer
            holder
            claims -- TODO: normalize claims by dropping redundant '#holder' suffixes
            createdAt = newCreatedAt
            expiresAt = optional defaultExpiresAt (min defaultExpiresAt) claims.validUntil

        pure RegistryV1.CredentialFactory_UpdateCredentialsResult with
          newCredentials
          meta = emptyMetadata

-- | A credential record visible to the DSO and served by its Scan service.
template AnsCredentialRecord
  with
    dso : Party
    issuer : Party
    holder : Party
    claims : RegistryV1.Claims
    createdAt : Time
    expiresAt : Time
  where
    ensure validCredentialRecord this

    signatory issuer, holder
    observer dso

    interface instance RegistryV1.Credential for AnsCredentialRecord where
      view = RegistryV1.CredentialView with
        admin = dso
        issuer = issuer
        holder = holder
        claims = claims
        createdAt = Some createdAt
        expiresAt = Some expiresAt
        meta = emptyMetadata

    choice AnsCredential_Expire : ()
      with
        actor : Party
      controller actor
      do
        require "actor is stakeholder" (actor == holder || actor == issuer || actor == dso)
        assertDeadlineExceeded "expiresAt" expiresAt

    choice AnsCredential_DsoArchiveInvalid : ()
      -- ^ Archive this credential record if it is invalid according to the DSO rules.
      -- Required as the DSO party is only an observer and thus cannot control the creation of records.
      controller dso
      do
        -- created at cannot be in the future
        assertWithinDeadline "createdAt" createdAt
        -- TODO: add check that expiresAt is not too far in the future
        -- TODO: consider how to check that reliably when the allowed TTL changes
        pure ()


-- Credential record validation
-------------------------------

-- | Credential record validation to ensure that the credentials are not too large and
-- can be efficiently indexed and processed by the Scan service.
--
-- No content-level validation is performed, as that is application-specific and would
-- bind the registry to specific use cases.
validCredentialRecord : AnsCredentialRecord -> Bool
validCredentialRecord credential =
  validClaims credential.createdAt credential.claims
  -- no validation other than for the claims

validClaims : Time -> RegistryV1.Claims -> Bool
validClaims createdAt claims =
  -- at most 32 claims per credential to constrain indexing overhead
  TextMap.size claims.values <= 32 &&
  -- claim values are valid
  all validClaimValue (TextMap.toList claims.values) &&
  -- validity dates are consistent
  case (claims.validFrom, claims.validUntil) of
    (Some from, Some until) -> createdAt <= from && from < until
    (Some from, None)       -> createdAt <= from
    (None, Some until)      -> createdAt < until
    (None, None)            -> True

validClaimValue : (Text, Text) -> Bool
validClaimValue (k, v) =
  validKey k &&
  T.length v < 2048

-- | Keys are constrained to be < 512 characters, as they need to be indexed efficiently.
validKey : Text -> Bool
validKey k =
  case T.splitOn "#" k of
    [property] -> validProperty property
    [property, subject] -> validProperty property && validSubject subject
    _ -> False

validProperty : Text -> Bool
validProperty property =
  -- 254 chosen to ensure total key length is below 512 with subject suffixes
  T.length property <= 254 && all validPropertyCodepoint (T.toCodePoints property)

validSubject : Text -> Bool
validSubject subject =
  -- 255 chosen to allow full party-ids
  T.length subject <= 255 && all validPropertyCodepoint (T.toCodePoints subject)

validPropertyCodepoint : Int -> Bool
validPropertyCodepoint c =
  -- yeah, Daml does not have rgex support yet
     (c >= 0x30 && c <= 0x39) -- '0' - '9'
  || (c >= 0x41 && c <= 0x5A) -- 'A' - 'Z'
  || (c >= 0x61 && c <= 0x7A) -- 'a' - 'z'
  || c == 0x2E                -- '.'
  || c == 0x5F                -- '_'
  || c == 0x3A                -- ':'
  || c == 0x2D                -- '-'
  || c == 0x2F                -- '/'


-- checked fetches
------------------

instance HasCheckedFetch AnsCredentialRegistry ForDso where
  contractGroupId AnsCredentialRegistry{..} = ForDso with dso

instance HasCheckedFetch AnsCredentialRecord ForOwner where
  contractGroupId AnsCredentialRecord{..} = ForOwner with dso; owner = holder
