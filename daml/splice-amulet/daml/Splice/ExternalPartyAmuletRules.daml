-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE MultiWayIf #-}
module Splice.ExternalPartyAmuletRules where

import DA.Foldable (forA_)
import DA.Optional

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.TransferInstructionV1 qualified as Api.Token.TransferInstructionV1
import Splice.Api.Token.AllocationInstructionV1 as Api.Token.AllocationInstructionV1

import Splice.Amulet.TokenApiUtils
import Splice.Amulet.TwoStepTransfer
import Splice.AmuletAllocation
import Splice.AmuletTransferInstruction
import Splice.AmuletRules
import Splice.Types
import Splice.Util


import DA.Exception

-- | Rules contract that can be used in transactions that require signatures
-- from an external party. This is intended to get archived and recreated as rarely as possible
-- to support long delays between preparing and signing a transaction.
template ExternalPartyAmuletRules
  with
    dso : Party
  where
    signatory dso

    -- This choice is not guarded by any resource consumption other than the traffic required to pay for the submission of the exercising of this choice.
    -- If this is being abused the DSO party can blacklist (or rate limit) the submitting participant node.
    nonconsuming choice ExternalPartyAmuletRules_CreateTransferCommand : ExternalPartyAmuletRules_CreateTransferCommandResult
      with
        sender : Party
        receiver : Party
        delegate : Party
        amount : Decimal
        expiresAt : Time
        nonce : Int
      controller sender
      do -- TODO(#18633): once the `isLedgerTimeXX` primitives are in, enforce that `expiresAt` is in the future
         -- We don't do that yet, as otherwise this would be a regression, as it would introduce a time-bound
         -- on the prepared transaction creating the transfer command.
         cmd <- create TransferCommand with
           dso
           sender
           receiver
           delegate
           amount
           expiresAt
           nonce
         pure (ExternalPartyAmuletRules_CreateTransferCommandResult cmd)

    interface instance Api.Token.TransferInstructionV1.TransferFactory for ExternalPartyAmuletRules where
      view = Api.Token.TransferInstructionV1.TransferFactoryView with
        admin = dso
        meta = emptyMetadata

      transferFactory_transferImpl self arg = amulet_transferFactory_transferImpl this self arg
      transferFactory_publicFetchImpl _self arg = do
        requireExpectedAdminMatch arg.expectedAdmin dso
        pure (view $ toInterface @Api.Token.TransferInstructionV1.TransferFactory this)

    interface instance AllocationFactory for ExternalPartyAmuletRules where
      view = AllocationFactoryView with
        admin = dso
        meta = emptyMetadata

      allocationFactory_allocateImpl self arg = amulet_allocationFactory_allocateImpl this self arg
      allocationFactory_publicFetchImpl _self arg = do
        requireExpectedAdminMatch arg.expectedAdmin dso
        pure (view $ toInterface @Api.Token.AllocationInstructionV1.AllocationFactory this)

data ExternalPartyAmuletRules_CreateTransferCommandResult = ExternalPartyAmuletRules_CreateTransferCommandResult
  with
    transferCommandCid : ContractId TransferCommand
  deriving (Show, Eq)

-- | A contract tracking the number of completed TransferCommands per sender,
-- which is used to determine the nonces used in TransferCommands for deduplication.
template TransferCommandCounter
  with
    dso : Party
    sender : Party
    nextNonce : Int
  where
    signatory dso
    observer sender

instance HasCheckedFetch TransferCommandCounter ForOwner where
  contractGroupId TransferCommandCounter{..} =
    ForOwner with
      owner = sender
      dso

-- | One-time delegation to execute a transfer to the given receiver
-- for the given amount.
--
-- We externally sign this instead of the transfer itself to support a longer delay between
-- prepare/execute which would be prevented by signing the transfer directly as that one pins
-- down the mining rounds that are relatively short lived.
template TransferCommand
  with
    dso : Party
    sender : Party
    receiver : Party
    delegate : Party -- ^ The delegate that actually executes the transfer
    amount : Decimal
    expiresAt : Time -- ^ Expiry of the command until when TransferCommand_Send must be called
    nonce : Int
      -- ^ Expected nonce value to order and deduplicate concurrent transfers.
      -- Starts at 0 and the next value to use can then be read from TransferCommandCounter and the in-flight TransferCommand contracts.
  where
    -- The DSO party is a signatory to make sure
    -- that the external signature
    -- is visible to the SVs.
    signatory sender, dso
    observer delegate

    choice TransferCommand_Send : TransferCommand_SendResult
      with
        context : PaymentTransferContext
        inputs : [TransferInput]
        -- The delegate is expected to select inputs that cover the amount being transferred, provided they exist.
        -- Otherwise the transfer will fail.
        transferPreapprovalCidO : Optional (ContractId TransferPreapproval)
        -- Unspecified if the transfer preapproval does not exist. The transfer command will get rejected in that case
        transferCounterCid : ContractId TransferCommandCounter
      controller delegate
      do transferCounter <- fetchChecked (ForOwner with owner = sender, dso) transferCounterCid

         let mergeInputsAndReportError error = do
             -- In the absence of automatic merging of inputs for external parties, it is possible for
             -- a user to accumulate tons of small amulet holdings and be unable to do a transfer.
             -- We do a self-transfer to merge inputs even in case of a failed transfer to guard against this.
             _ <- fetchChecked (ForDso dso) context.amuletRules
             _ <- exercisePaymentTransfer context Transfer with
               sender
               provider = delegate
               inputs = inputs
               outputs = []
               beneficiaries = None -- No beneficiaries for self-transfer merge.
             pure (TransferCommandResultFailure error)

         if | transferCounter.nextNonce > nonce ->
              -- Fail but archive the TransferCommand
              pure TransferCommand_SendResult with
                result = TransferCommandResultFailure $ ITR_Other $ "Expected nonce " <> show nonce <> " is smaller than current counter " <> show transferCounter.nextNonce
                sender
                nonce
            | transferCounter.nextNonce < nonce ->
              -- Fail but don't archive the command so it can be retried
              abort ("Expected nonce " <> show nonce <> " is bigger than current counter " <> show transferCounter.nextNonce)
            | otherwise -> do
              -- Consider the nonce spent independent of whether funds get transferred or not.
              -- Thereby ensuring that transfer instructions get executed promptly.
              -- Clients are expected to retry in case their transfer fails unexpectedly.
              _ <- potentiallyUnsafeArchive transferCounterCid
              _ <- create transferCounter with nextNonce = transferCounter.nextNonce + 1
              case transferPreapprovalCidO of
                None ->
                  -- We cannot verify in Daml that the TransferPreapproval actually does not exist.
                  -- For now we trust the DSO delegate to chose correctly. The other SVs can monitor
                  -- this and change the delegate or even remove the SV if it does not operate
                  -- correctly.
                  pure TransferCommand_SendResult with
                    result = TransferCommandResultFailure $ ITR_Other $ "No TransferPreapproval for receiver " <> show receiver
                    sender
                    nonce
                Some transferPreapprovalCid -> do
                  -- Verify that receiver and DSO party match. We don't validate that the reeiver's provider matches
                 -- as changing that should be up to the receiver and not require the sender to resign.
                  _ <- fetchChecked (ForOwner with owner = receiver, dso) transferPreapprovalCid
                  assertWithinDeadline "TransferCommand.expiresAt" expiresAt
                  result <-
                    try do
                      TransferPreapproval_SendResult result <- exercise transferPreapprovalCid (TransferPreapproval_Send context inputs amount sender)
                      pure (TransferCommandResultSuccess result)
                    catch
                      (ex : InvalidTransfer) -> mergeInputsAndReportError ex.reason
                      (ex : AnyException) -> mergeInputsAndReportError (ITR_Other $ message ex)
                  pure TransferCommand_SendResult with
                    result
                    sender
                    nonce

    choice TransferCommand_Withdraw : TransferCommand_WithdrawResult
      controller sender
      do pure TransferCommand_WithdrawResult with
           sender
           nonce

    choice TransferCommand_Expire : TransferCommand_ExpireResult
      with
        p : Party
      controller p
      do require "Controller is a stakeholder" (p `elem` stakeholder this)
         assertDeadlineExceeded "TransferCommand.expiresAt" expiresAt
         pure TransferCommand_ExpireResult with
           sender
           nonce

instance HasCheckedFetch TransferCommand ForDso where
  contractGroupId TransferCommand{..} = ForDso dso

data TransferCommand_SendResult = TransferCommand_SendResult
  with
    result : TransferCommandResult
    sender : Party -- Returned to simplify tx log parsing
    nonce : Int -- Returned to simplify tx log parsing
  deriving (Show, Eq)

data TransferCommandResult
  = TransferCommandResultFailure with
      reason : InvalidTransferReason
  | TransferCommandResultSuccess with
      result : TransferResult
  deriving (Show, Eq)

data TransferCommand_WithdrawResult = TransferCommand_WithdrawResult
  with
    sender : Party -- Returned to simplify tx log parsing
    nonce : Int -- Returned to simplify tx log parsing
  deriving (Show, Eq)

data TransferCommand_ExpireResult = TransferCommand_ExpireResult
  with
    sender : Party -- Returned to simplify tx log parsing
    nonce : Int -- Returned to simplify tx log parsing
  deriving (Show, Eq)


-- Token standard transfer factory
----------------------------------

amulet_transferFactory_transferImpl
  : ExternalPartyAmuletRules
  -> ContractId Api.Token.TransferInstructionV1.TransferFactory
  -> Api.Token.TransferInstructionV1.TransferFactory_Transfer
  -> Update Api.Token.TransferInstructionV1.TransferInstructionResult
amulet_transferFactory_transferImpl this _self arg = do
  let Api.Token.TransferInstructionV1.TransferFactory_Transfer {transfer, extraArgs} = arg
  let dso = this.dso
  -- validate call to factory and retrieve context
  requireExpectedAdminMatch arg.expectedAdmin dso

  -- == validate each field of the transfer specification ==
  -- sender: nothing to validate
  -- receiver: validate preapproval if given
  optPreapprovalCid <- lookupFromContextU @(ContractId TransferPreapproval) extraArgs.context transferPreapprovalContextKey
  forA_ optPreapprovalCid \preapprovalCid ->
    fetchChecked (ForOwner with dso; owner = transfer.receiver) preapprovalCid
  -- instrumentId:
  let expectedInstrumentId = amuletInstrumentId this.dso
  require
    ("Expected instrumentId " <> show expectedInstrumentId <> " matches actual instrumentId " <> show transfer.instrumentId)
    (expectedInstrumentId == transfer.instrumentId)
  -- amount:
  require "Amount must be positive" (transfer.amount > 0.0)
  -- requestedAt:
  assertDeadlineExceeded "Transfer.requestedAt" transfer.requestedAt
  -- executeBefore:
  assertWithinDeadline "Transfer.executeBefore" transfer.executeBefore
  -- inputHoldingCids: note that their detailed validation is done in the transfer itself
  require "At least one holding must be provided" (not $ null transfer.inputHoldingCids)

  -- execute the right kind of transfer
  case optPreapprovalCid of
    None
      | transfer.receiver == transfer.sender -> do
          -- execute a self-transfer
          paymentContext <- unfeaturedPaymentContextFromChoiceContext dso extraArgs.context
          inputs <- holdingToTransferInputs (ForOwner with dso; owner = transfer.sender) paymentContext transfer.inputHoldingCids
          result <- exercisePaymentTransfer paymentContext Transfer with
            sender = transfer.sender
            provider = transfer.sender
            inputs
            outputs = [ TransferOutput with
              receiver = transfer.sender
              amount = transfer.amount
              receiverFeeRatio = 0.0
              lock = None ]
            beneficiaries = None
          pure Api.Token.TransferInstructionV1.TransferInstructionResult with
            senderChangeCids = toInterfaceContractId <$> optionalToList result.senderChangeAmulet
            output = Api.Token.TransferInstructionV1.TransferInstructionResult_Completed with
              receiverHoldingCids = createdAmuletToHolding <$> result.createdAmulets
            meta = copyOnlyBurnMeta result.meta

      | otherwise -> do
          -- prepare a two-step transfer
          let twoStepTransfer = standardTransferToTwoStepTransfer arg.transfer
          let requestedAt = arg.transfer.requestedAt
          paymentContext <- unfeaturedPaymentContextFromChoiceContext dso extraArgs.context
          (lockedAmulet, senderChangeCids, meta) <- prepareTwoStepTransfer twoStepTransfer requestedAt arg.transfer.inputHoldingCids paymentContext
          -- create the transfer instruction tracking this locked amulet
          transferInstructionCid <- toInterfaceContractId <$> create AmuletTransferInstruction with
            transfer = arg.transfer with
              inputHoldingCids = [toInterfaceContractId lockedAmulet] -- report the locked holding backing the transfer
            lockedAmulet
          -- return result
          pure Api.Token.TransferInstructionV1.TransferInstructionResult with
            senderChangeCids
            output = Api.Token.TransferInstructionV1.TransferInstructionResult_Pending
              with
                transferInstructionCid
            meta

    Some preapprovalCid -> do
      -- use a payment context with featuring so the preapproval provider can be featured
      paymentContext <- paymentFromChoiceContext dso extraArgs.context
      -- execute a direct transfer
      inputs <- holdingToTransferInputs (ForOwner with dso; owner = transfer.sender) paymentContext transfer.inputHoldingCids
      result <- exercise preapprovalCid TransferPreapproval_Send
        with
          sender = transfer.sender
          context = paymentContext
          inputs
          amount = transfer.amount

      -- return result
      pure Api.Token.TransferInstructionV1.TransferInstructionResult with
        senderChangeCids = toInterfaceContractId <$> optionalToList result.result.senderChangeAmulet
        output = Api.Token.TransferInstructionV1.TransferInstructionResult_Completed with
          receiverHoldingCids = createdAmuletToHolding <$> result.result.createdAmulets
        meta = copyOnlyBurnMeta result.result.meta


-- Token standard allocation factory
------------------------------------

amulet_allocationFactory_allocateImpl
  : ExternalPartyAmuletRules
  -> ContractId AllocationFactory
  -> AllocationFactory_Allocate
  -> Update AllocationInstructionResult
amulet_allocationFactory_allocateImpl externalAmuletRules _self arg = do
  let dso = externalAmuletRules.dso
  let AllocationFactory_Allocate {allocation, requestedAt, inputHoldingCids, extraArgs} = arg
  -- validate call to factory and retrieve context
  requireExpectedAdminMatch arg.expectedAdmin dso

  -- We are using an unfeatured payment context, as the locking to self should not be featured.
  -- Ideally we could feature the 'settlement.executor', but at this point we don't have the
  -- necessary authorization from them.
  --
  -- The latter transfer that happens as part of the settlement will feature the 'settlement.executor',
  -- which is what we want: incentivize successful settlements.
  paymentContext <- unfeaturedPaymentContextFromChoiceContext dso extraArgs.context

  -- == validate each field of the requested allocation
  let settlement = allocation.settlement
  let transferLeg = allocation.transferLeg

  -- settlement.executor: no check
  -- settlement.settlementRef: no check
  -- settlement.requestedAt:
  assertDeadlineExceeded "Allocation.settlement.requestedAt" settlement.requestedAt
  -- settlement.allocateBefore:
  assertWithinDeadline "Allocation.settlement.allocateBefore" settlement.allocateBefore
  -- settlement.settleBefore:
  require "Allocation.settlement.allocateBefore <= Allocation.settlement.settleBefore" (settlement.allocateBefore <= settlement.settleBefore)

  -- transferLegId: no check

  -- transferLeg.sender: no check
  -- transferLeg.receiver: nothing to check
  -- transferLeg.amount
  require "Transfer amount must be positive" (transferLeg.amount > 0.0)
  -- transferLeg.instrumentId
  require "Instrument-id must match the factory" (transferLeg.instrumentId == amuletInstrumentId dso)
  -- transferLeg.meta: no check

  -- requestedAt (of the allocation instruction itself):
  assertDeadlineExceeded "requestedAt" requestedAt

  -- inputHoldingCids:
  require "At least one input holding must be provided" (not $ null inputHoldingCids)

  -- lock the funds
  let twoStepTransfer = allocationToTwoStepTransfer arg.allocation
  (lockedAmulet, senderChangeCids, meta) <-
    prepareTwoStepTransfer twoStepTransfer arg.requestedAt inputHoldingCids paymentContext
  -- create the amulet allocation
  allocationCid <- toInterfaceContractId <$> create AmuletAllocation with
    allocation = arg.allocation
    lockedAmulet

  -- finaly done: return the result
  pure AllocationInstructionResult with
    senderChangeCids
    output = AllocationInstructionResult_Completed with allocationCid
    meta

requireExpectedAdminMatch : Party -> Party -> Update ()
requireExpectedAdminMatch expected actual =   require ("Expected admin " <> show expected <> " matches actual admin " <> show actual) (expected == actual)
