-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE MultiWayIf #-}
module Splice.ExternalPartyAmuletRules where

import DA.Time (RelTime, subTime)

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.TransferInstructionV1 qualified as Api.Token.TransferInstructionV1
import Splice.Api.Token.AllocationInstructionV1 as Api.Token.AllocationInstructionV1

import Splice.Amulet.TokenApiUtils
import Splice.AmuletAllocation
import Splice.AmuletRules
import Splice.Expiry
import Splice.Fees
import Splice.Round
import Splice.Types
import Splice.Util


import DA.Exception

-- | Rules contract that can be used in transactions that require signatures
-- from an external party. This is intended to get archived and recreated as rarely as possible
-- to support long delays between preparing and signing a transaction.
template ExternalPartyAmuletRules
  with
    dso : Party
  where
    signatory dso

    -- This choice is not guarded by any resource consumption other than the traffic required to pay for the submission of the exercising of this choice.
    -- If this is being abused the DSO party can blacklist (or rate limit) the submitting participant node.
    nonconsuming choice ExternalPartyAmuletRules_CreateTransferCommand : ExternalPartyAmuletRules_CreateTransferCommandResult
      with
        sender : Party
        receiver : Party
        delegate : Party
        amount : Decimal
        expiresAt : Time
        nonce : Int
      controller sender
      do cmd <- create TransferCommand with
           dso
           sender
           receiver
           delegate
           amount
           -- We cannot enforce a max expiry as we cannot call getTime.
           expiresAt
           nonce
         pure (ExternalPartyAmuletRules_CreateTransferCommandResult cmd)

    interface instance Api.Token.TransferInstructionV1.TransferFactory for ExternalPartyAmuletRules where
      view = Api.Token.TransferInstructionV1.TransferFactoryView with
        admin = dso

      transferFactory_transferImpl self arg = amulet_transferFactory_transferImpl this self arg

    interface instance AllocationFactory for ExternalPartyAmuletRules where
      view = AllocationFactoryView with
        admin = dso

      allocationFactory_allocateImpl self arg = amulet_allocationFactory_allocateImpl this self arg

data ExternalPartyAmuletRules_CreateTransferCommandResult = ExternalPartyAmuletRules_CreateTransferCommandResult
  with
    transferCommandCid : ContractId TransferCommand
  deriving (Show, Eq)

-- | A contract tracking the number of completed TransferCommands per sender,
-- which is used to determine the nonces used in TransferCommands for deduplication.
template TransferCommandCounter
  with
    dso : Party
    sender : Party
    nextNonce : Int
  where
    signatory dso
    observer sender

instance HasCheckedFetch TransferCommandCounter ForOwner where
  contractGroupId TransferCommandCounter{..} =
    ForOwner with
      owner = sender
      dso

-- | One-time delegation to execute a transfer to the given receiver
-- for the given amount.
--
-- We externally sign this instead of the transfer itself to support a longer delay between
-- prepare/execute which would be prevented by signing the transfer directly as that one pins
-- down the mining rounds that are relatively short lived and relies on `getTime` which
-- means it would fail due to the max allowed skew between ledger effective time and record
-- time.
template TransferCommand
  with
    dso : Party
    sender : Party
    receiver : Party
    delegate : Party -- ^ The delegate that actually executes the transfer
    amount : Decimal
    expiresAt : Time -- ^ Expiry of the command until when TransferCommand_Send must be called
    nonce : Int
      -- ^ Expected nonce value to order and deduplicate concurrent transfers.
      -- Starts at 0 and the next value to use can then be read from TransferCommandCounter and the in-flight TransferCommand contracts.
  where
    -- The DSO party is a signatory to make sure
    -- that the external signature
    -- is visible to the SVs.
    signatory sender, dso
    observer delegate

    choice TransferCommand_Send : TransferCommand_SendResult
      with
        context : PaymentTransferContext
        inputs : [TransferInput]
        -- The delegate is expected to select inputs that cover the amount being transferred, provided they exist.
        -- Otherwise the transfer will fail.
        transferPreapprovalCidO : Optional (ContractId TransferPreapproval)
        -- Unspecified if the transfer preapproval does not exist. The transfer command will get rejected in that case
        transferCounterCid : ContractId TransferCommandCounter
      controller delegate
      do transferCounter <- fetchChecked (ForOwner with owner = sender, dso) transferCounterCid

         let mergeInputsAndReportError error = do
             -- In the absence of automatic merging of inputs for external parties, it is possible for
             -- a user to accumulate tons of small amulet holdings and be unable to do a transfer.
             -- We do a self-transfer to merge inputs even in case of a failed transfer to guard against this.
             _ <- fetchChecked (ForDso dso) context.amuletRules
             _ <- exercisePaymentTransfer context Transfer with
               sender
               provider = delegate
               inputs = inputs
               outputs = []
             pure (TransferCommandResultFailure error)

         if | transferCounter.nextNonce > nonce ->
              -- Fail but archive the TransferCommand
              pure TransferCommand_SendResult with
                result = TransferCommandResultFailure $ ITR_Other $ "Expected nonce " <> show nonce <> " is smaller than current counter " <> show transferCounter.nextNonce
                sender
                nonce
            | transferCounter.nextNonce < nonce ->
              -- Fail but don't archive the command so it can be retried
              abort ("Expected nonce " <> show nonce <> " is bigger than current counter " <> show transferCounter.nextNonce)
            | otherwise -> do
              -- Consider the nonce spent independent of whether funds get transferred or not.
              -- Thereby ensuring that transfer instructions get executed promptly.
              -- Clients are expected to retry in case their transfer fails unexpectedly.
              _ <- potentiallyUnsafeArchive transferCounterCid
              _ <- create transferCounter with nextNonce = transferCounter.nextNonce + 1
              case transferPreapprovalCidO of
                None ->
                  -- We cannot verify in Daml that the TransferPreapproval actually does not exist.
                  -- For now we trust the DSO delegate to chose correctly. The other SVs can monitor
                  -- this and change the delegate or even remove the SV if it does not operate
                  -- correctly.
                  pure TransferCommand_SendResult with
                    result = TransferCommandResultFailure $ ITR_Other $ "No TransferPreapproval for receiver " <> show receiver
                    sender
                    nonce
                Some transferPreapprovalCid -> do
                  -- Verify that receiver and DSO party match. We don't validate that the reeiver's provider matches
                 -- as changing that should be up to the receiver and not require the sender to resign.
                  _ <- fetchChecked (ForOwner with owner = receiver, dso) transferPreapprovalCid
                  now <- getTime -- This is run by the DSO party where getTime is fine
                  require ("Current time " <> show now <> " is before expiry of TransferCommand " <> show expiresAt) (expiresAt > now)
                  result <-
                    try do
                      TransferPreapproval_SendResult result <- exercise transferPreapprovalCid (TransferPreapproval_Send context inputs amount sender)
                      pure (TransferCommandResultSuccess result)
                    catch
                      (ex : InvalidTransfer) -> mergeInputsAndReportError ex.reason
                      (ex : AnyException) -> mergeInputsAndReportError (ITR_Other $ message ex)
                  pure TransferCommand_SendResult with
                    result
                    sender
                    nonce

    choice TransferCommand_Withdraw : TransferCommand_WithdrawResult
      controller sender
      do pure TransferCommand_WithdrawResult with
           sender
           nonce

    choice TransferCommand_Expire : TransferCommand_ExpireResult
      with
        p : Party
      controller p
      do require "Controller is a stakeholder" (p `elem` stakeholder this)
         now <- getTime
         require "TransferCommand is expired" (expiresAt <= now)
         pure TransferCommand_ExpireResult with
           sender
           nonce

instance HasCheckedFetch TransferCommand ForDso where
  contractGroupId TransferCommand{..} = ForDso dso

data TransferCommand_SendResult = TransferCommand_SendResult
  with
    result : TransferCommandResult
    sender : Party -- Returned to simplify tx log parsing
    nonce : Int -- Returned to simplify tx log parsing
  deriving (Show, Eq)

data TransferCommandResult
  = TransferCommandResultFailure with
      reason : InvalidTransferReason
  | TransferCommandResultSuccess with
      result : TransferResult
  deriving (Show, Eq)

data TransferCommand_WithdrawResult = TransferCommand_WithdrawResult
  with
    sender : Party -- Returned to simplify tx log parsing
    nonce : Int -- Returned to simplify tx log parsing
  deriving (Show, Eq)

data TransferCommand_ExpireResult = TransferCommand_ExpireResult
  with
    sender : Party -- Returned to simplify tx log parsing
    nonce : Int -- Returned to simplify tx log parsing
  deriving (Show, Eq)


-- Token standard transfer factory
----------------------------------

amulet_transferFactory_transferImpl
  : ExternalPartyAmuletRules
  -> ContractId Api.Token.TransferInstructionV1.TransferFactory
  -> Api.Token.TransferInstructionV1.TransferFactory_Transfer
  -> Update Api.Token.TransferInstructionV1.TransferFactory_TransferResult
amulet_transferFactory_transferImpl this _self arg = do
  let Api.Token.TransferInstructionV1.TransferFactory_Transfer {expectedAdmin, transfer, extraArgs} = arg
  let dso = this.dso
  -- validate call to factory and retrieve context
  require ("Expected admin " <> show expectedAdmin <> " matches actual admin " <> show this.dso) (expectedAdmin == dso)
  context <- getAmuletContext extraArgs
  paymentContext <- paymentFromChoiceContext dso context

  -- == validate each field of the transfer specification ==
  -- sender: nothing to validate
  -- receiver: validate that it approves the preapproval
  preapprovalCid <- getContextContractId @TransferPreapproval context transferPreapprovalContextKey
  preapproval <- fetchChecked (ForOwner with dso; owner = transfer.receiver) preapprovalCid
  require "Preapproval receiver matches transfer receiver" (preapproval.receiver == transfer.receiver)
  -- amount:
  require "Amount must be positive" (transfer.amount > 0.0)
  -- instrumentId:
  let expectedInstrumentId = amuletInstrumentId this.dso
  require
    ("Expected instrumentId " <> show expectedInstrumentId <> " matches actual instrumentId " <> show transfer.instrumentId)
    (expectedInstrumentId == transfer.instrumentId)
  -- executeBefore:
  now <- getTime
  require "Transfer must be executed before expiry" (now < transfer.executeBefore)
  -- holdingCids: note that their detailed validation is done in the transfer itself
  let holdings = transfer.holdingCids
  require "At least one holding must be provided" (not $ null transfer.holdingCids)

  -- execute transfer
  _ <- exercise preapprovalCid TransferPreapproval_Send
    with
      sender = transfer.sender
      context = paymentContext
      inputs = [ InputAmulet (coerceContractId holding) | holding <- holdings ]
      amount = transfer.amount

  -- return result
  pure Api.Token.TransferInstructionV1.TransferFactory_TransferResult with
    optTransferInstructionCid = None
    meta = emptyMetadata


-- Token standard allocation factory
------------------------------------

-- | The extra allocation that is made to guard against the transfer fees changing
-- between the time of locking the amulet and the time of executing the actual transfer.
feeReserveMultiplier : Decimal
feeReserveMultiplier = 4.0

amulet_allocationFactory_allocateImpl
  : ExternalPartyAmuletRules
  -> ContractId AllocationFactory
  -> AllocationFactory_Allocate
  -> Update AllocationFactory_AllocateResult
amulet_allocationFactory_allocateImpl externalAmuletRules _self arg = do
  let dso = externalAmuletRules.dso
  let AllocationFactory_Allocate {expectedAdmin, allocation, inputHoldings, extraArgs} = arg
  -- validate call to factory and retrieve context
  require ("Expected admin " <> show expectedAdmin <> " matches actual admin " <> show dso) (expectedAdmin == dso)
  context <- getAmuletContext extraArgs

  -- We are using an unfeatured payment context, as the locking to self should not be featured.
  -- Ideally we could feature the 'settlement.executor', but at this point we don't have the
  -- necessary authorization from them.
  --
  -- The latter transfer that happens as part of the settlement will feature the 'settlement.executor',
  -- which is what we want: incentivize successful settlements.
  paymentContext <- unfeaturedPaymentContextFromChoiceContext dso context

  -- == validate each field of the requested allocation
  let settlement = allocation.settlement
  let transferLeg = allocation.transferLeg

  -- NOTE: this dependency on getTime should be avoided in other implementations, and replaced
  -- with inequalities against the sequencing time. It is part of the Amulet implementation,
  -- as its holding fees currently require the current time to estimate the fees. However,
  -- that is planned to be changed, so we recommend not copying the very strict checks below,
  -- which are in principle not necessary.
  now <- getTime

  -- settlement.executor: no check
  -- settlement.settlementRef: no check
  -- settlement.requestedAt:
  require "Requested at must be in the past" (settlement.requestedAt <= now)
  -- settlement.allocateBefore:
  require "Allocate before must be in the future" (now <= settlement.allocateBefore)
  -- settlement.settleBefore:
  require "settlement.allocateBefore <= settlement.settleBefore" (settlement.allocateBefore <= settlement.settleBefore)

  -- transferLegId: no check

  -- transferLeg.sender: no check
  -- transferLeg.receiver: nothing to check
  -- transferLeg.amount
  require "Transfer amount must be positive" (transferLeg.amount > 0.0)
  -- transferLeg.instrumentId
  require "Instrument-id must match the factory" (transferLeg.instrumentId == amuletInstrumentId dso)
  -- transferLeg.meta: no check

  -- inputHoldings:
  require "At least one input holding must be provided" (not $ null inputHoldings)

  -- == create allocation
  -- over-approximate fees that will be due on the actual transfer
  let receiverOutputForActualTransfer = allocationToAmuletOutput allocation
  [expectedTransferFees] <- exerciseComputeFees paymentContext transferLeg.sender [receiverOutputForActualTransfer]
  openRound <- fetchChecked (ForDso with dso) paymentContext.context.openMiningRound
  let lockDuration = settlement.settleBefore `subTime` now
  let approximateHoldingFees = holdingFeesForDuration lockDuration openRound
  let feesReserveAmount = (expectedTransferFees + approximateHoldingFees) * feeReserveMultiplier

  -- lock the amulet
  let transferInputs = [ InputAmulet (coerceContractId holding) | holding <- inputHoldings ]
  let transfer = Splice.AmuletRules.Transfer with
        sender = transferLeg.sender
        provider = transferLeg.sender -- we do not have a separate app provider
        outputs =
          [ TransferOutput with
              receiver = transferLeg.sender
              amount = transferLeg.amount + feesReserveAmount
              receiverFeeRatio = 0.0 -- locking fees are paid by the sender
              lock = Some TimeLock with
                expiresAt = settlement.settleBefore
                holders = [dso]
          ]
        inputs = transferInputs

  result <- exerciseCheckedPaymentTransfer dso paymentContext transfer

  -- create the amulet allocation
  let [TransferResultLockedAmulet lockedAmulet] = result.createdAmulets
  allocCid <- toInterfaceContractId <$> create AmuletAllocation with
    allocation
    lockedAmulet

  -- finaly done: return the result
  pure AllocationFactory_AllocateResult with
    allocationOrInstruction = AOI_Allocation with allocation = allocCid
    meta = emptyMetadata


holdingFeesForDuration : RelTime -> OpenMiningRound -> Decimal
holdingFeesForDuration duration openRound =
    holdingFeesUsd / amuletPerUsd
  where
    holdingFeesPerDayUsd = ratePerRoundToRatePerDay openRound.transferConfigUsd.holdingFee openRound.tickDuration
    holdingFeesUsd = chargeRatePerDay holdingFeesPerDayUsd duration
    amuletPerUsd = openRound.amuletPrice
