-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | The contracts representing the long-term state of Splice.
module Splice.Amulet where

import Prelude
import DA.Action (void)
import DA.Assert
import DA.Map as Map
import DA.TextMap as TextMap
import DA.Optional (fromOptional)

import Splice.Api.Token.MetadataV1 qualified as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 qualified as Api.Token.HoldingV1
import Splice.Api.RewardAssignmentV1 qualified as Api.RewardAssignmentV1

import Splice.Amulet.TokenApiUtils
import Splice.Expiry
import Splice.ExternalPartyConfigState
import Splice.Fees
import qualified Splice.Api.FeaturedAppRightV1
import qualified Splice.Api.FeaturedAppRightV2
import Splice.Round
import Splice.Types

import Splice.Util

data AmuletExpireSummary = AmuletExpireSummary with
    owner : Party
    round: Round -- ^ Round for which this expiry was registered.
    changeToInitialAmountAsOfRoundZero : Decimal
    -- The change to the total balance introduced by a amulet expiry, normalized to round zero, i.e.,
    -- a amulet created in round 3 is treated as a amulet created in round 0 with a higher initial amount.
    changeToHoldingFeesRate : Decimal
      -- ^ The change of total holding fees introduced by a amulet expiry.
  deriving (Eq, Show)

-- | Result of an operation that created a new amulet, e.g.,
-- by minting a fresh amulet, or by unlocking a locked amulet.
data AmuletCreateSummary amuletContractId = AmuletCreateSummary with
    amulet : amuletContractId -- ^ The new amulet that was created
    amuletPrice : Decimal -- ^ The amulet price at the round the amulet was created
    round: Round -- ^ Round for which this amulet was created.
  deriving (Eq, Show)

data Amulet_ExpireResult = Amulet_ExpireResult with
  expireSum : AmuletExpireSummary
  meta : Optional Api.Token.MetadataV1.Metadata

data Amulet_ExpireV2Result = Amulet_ExpireV2Result with
  expireSum : AmuletExpireSummary -- FIXME: Consider trimming this down, scan and wallet tx log parser do currently need the non-round values though
  meta : Api.Token.MetadataV1.Metadata

data LockedAmulet_UnlockResult = LockedAmulet_UnlockResult with
  amuletSum : AmuletCreateSummary (ContractId Amulet)
  meta : Optional Api.Token.MetadataV1.Metadata

data LockedAmulet_UnlockV2Result = LockedAmulet_UnlockV2Result with
  amuletCid : ContractId Amulet
  meta : Api.Token.MetadataV1.Metadata

data LockedAmulet_OwnerExpireLockResult = LockedAmulet_OwnerExpireLockResult with
  amuletSum : AmuletCreateSummary (ContractId Amulet)
  meta : Optional Api.Token.MetadataV1.Metadata

data LockedAmulet_OwnerExpireLockV2Result = LockedAmulet_OwnerExpireLockV2Result with
  amuletCid : ContractId Amulet
  meta : Api.Token.MetadataV1.Metadata

data LockedAmulet_ExpireAmuletResult = LockedAmulet_ExpireAmuletResult with
  expireSum : AmuletExpireSummary
  meta : Optional Api.Token.MetadataV1.Metadata

data LockedAmulet_ExpireAmuletV2Result = LockedAmulet_ExpireAmuletV2Result with
  expireSum : AmuletExpireSummary
  meta : Api.Token.MetadataV1.Metadata

data ValidatorRight_ArchiveAsValidatorResult = ValidatorRight_ArchiveAsValidatorResult

data ValidatorRight_ArchiveAsUserResult = ValidatorRight_ArchiveAsUserResult

data FeaturedAppRight_WithdrawResult = FeaturedAppRight_WithdrawResult

data FeaturedAppRight_CancelResult = FeaturedAppRight_CancelResult

data AppRewardCoupon_DsoExpireResult = AppRewardCoupon_DsoExpireResult with
  featured : Bool
  amount : Decimal

data RewardCouponV2_DsoExpireResult = RewardCouponV2_DsoExpireResult with
  amount : Decimal

data ValidatorRewardCoupon_DsoExpireResult = ValidatorRewardCoupon_DsoExpireResult with
  amount : Decimal

data ValidatorRewardCoupon_ArchiveAsValidatorResult = ValidatorRewardCoupon_ArchiveAsValidatorResult with

data SvRewardCoupon_DsoExpireResult = SvRewardCoupon_DsoExpireResult with
  weight: Int

data SvRewardCoupon_ArchiveAsBeneficiaryResult = SvRewardCoupon_ArchiveAsBeneficiaryResult

data UnclaimedActivityRecord_ArchiveAsBeneficiaryResult = UnclaimedActivityRecord_ArchiveAsBeneficiaryResult

data UnclaimedActivityRecord_DsoExpireResult = UnclaimedActivityRecord_DsoExpireResult with
  unclaimedRewardCid : ContractId UnclaimedReward

data DevelopmentFundCoupon_WithdrawResult = DevelopmentFundCoupon_WithdrawResult with
  unclaimedDevelopmentFundCouponCid : ContractId UnclaimedDevelopmentFundCoupon

data DevelopmentFundCoupon_RejectResult = DevelopmentFundCoupon_RejectResult with
  unclaimedDevelopmentFundCouponCid : ContractId UnclaimedDevelopmentFundCoupon

data DevelopmentFundCoupon_DsoExpireResult = DevelopmentFundCoupon_DsoExpireResult with
  unclaimedDevelopmentFundCouponCid : ContractId UnclaimedDevelopmentFundCoupon

-- | A amulet, which can be locked and whose amount expires over time.
--
-- The expiry serves to charge an inactivity fee, and thereby ensures that the
-- SVs can reclaim the corresponding storage space at some point in the future.
template Amulet
  with
    dso : Party
    owner : Party
    amount : ExpiringAmount
  where
    signatory dso, owner
    ensure validExpiringAmount amount

    choice Amulet_Expire : Amulet_ExpireResult
      with
        roundCid : ContractId OpenMiningRound
      controller dso
      do deprecatedChoice "splice-amulet" "FIXME" "Amulet_Expire"

    choice Amulet_ExpireV2 : Amulet_ExpireV2Result
      with
        externalPartyConfigState0Cid : ContractId ExternalPartyConfigState
        externalPartyConfigState1Cid : ContractId ExternalPartyConfigState
      controller dso
      do  requireAmuletExpiredForAllRounds externalPartyConfigState0Cid externalPartyConfigState1Cid this
          let expireSum = AmuletExpireSummary with
                owner = owner
                round = amount.createdAt
                changeToInitialAmountAsOfRoundZero = - getValueAsOfRound0 amount
                changeToHoldingFeesRate = - (amount.ratePerRound.rate)
          return Amulet_ExpireV2Result with
            meta = simpleHoldingTxMeta TxKind_ExpireDust None (Some amount.initialAmount)
            ..

    interface instance Api.Token.HoldingV1.Holding for Amulet where
      view = Api.Token.HoldingV1.HoldingView with
        owner
        instrumentId = amuletInstrumentId dso
        amount = amount.initialAmount
        lock = None
        meta = amuletMetadata this

amuletMetadata : Amulet -> Api.Token.MetadataV1.Metadata
amuletMetadata Amulet{..} =
  Api.Token.MetadataV1.Metadata with
    values = TextMap.fromList [
      (createdInRoundMetaKey, show amount.createdAt.number),
      (ratePerRoundMetaKey, show amount.ratePerRound.rate)
      ]

template LockedAmulet
  with
    amulet : Amulet
    lock : TimeLock
  where
    signatory lock.holders, signatory amulet

    interface instance Api.Token.HoldingV1.Holding for LockedAmulet where
      view = Api.Token.HoldingV1.HoldingView with
        owner = amulet.owner
        instrumentId = amuletInstrumentId amulet.dso
        amount = amulet.amount.initialAmount
        lock = Some Api.Token.HoldingV1.Lock with
          holders = lock.holders
          expiresAt = Some lock.expiresAt
          expiresAfter = None
          context = lock.optContext
        meta = amuletMetadata amulet

    choice LockedAmulet_Unlock : LockedAmulet_UnlockResult
      with
        openRoundCid : ContractId OpenMiningRound
      controller amulet.owner :: lock.holders
      do deprecatedChoice "splice-amulet" "FIXME" "LockedAmulet_Unlock"

    choice LockedAmulet_UnlockV2 : LockedAmulet_UnlockV2Result
      controller amulet.owner :: lock.holders
      do amuletCid <- create amulet
         return LockedAmulet_UnlockV2Result with
           meta = simpleHoldingTxMeta TxKind_Unlock (Some "holders released lock") None, ..

    choice LockedAmulet_OwnerExpireLock : LockedAmulet_OwnerExpireLockResult
      with
        openRoundCid : ContractId OpenMiningRound
      controller amulet.owner
      do deprecatedChoice "splice-amulet" "FIXME" "LockedAmulet_OwnerExpireLock"

    choice LockedAmulet_OwnerExpireLockV2 : LockedAmulet_OwnerExpireLockV2Result
      controller amulet.owner
      do assertDeadlineExceeded "Lock.expiresAt" lock.expiresAt
         amuletCid <- create amulet
         return LockedAmulet_OwnerExpireLockV2Result with
          meta = simpleHoldingTxMeta TxKind_Unlock (Some "lock expired") None, ..

    choice LockedAmulet_ExpireAmulet : LockedAmulet_ExpireAmuletResult
      with
        roundCid : ContractId OpenMiningRound
      controller amulet.dso
      do deprecatedChoice "splice-amulet" "FIXME" "LockedAmulet_ExpireAmulet"

    choice LockedAmulet_ExpireAmuletV2 : LockedAmulet_ExpireAmuletV2Result
      with
        externalPartyConfigState0Cid : ContractId ExternalPartyConfigState
        externalPartyConfigState1Cid : ContractId ExternalPartyConfigState
      controller amulet.dso
      do
         requireAmuletExpiredForAllRounds externalPartyConfigState0Cid externalPartyConfigState1Cid amulet
         let expireSum = AmuletExpireSummary with
               owner = amulet.owner
               round = amulet.amount.createdAt
               changeToInitialAmountAsOfRoundZero = -(getValueAsOfRound0 amulet.amount)
               changeToHoldingFeesRate = - (amulet.amount.ratePerRound.rate)
         return LockedAmulet_ExpireAmuletV2Result with
           meta = simpleHoldingTxMeta TxKind_ExpireDust None (Some amulet.amount.initialAmount)
           ..


-- Contracts to implement reward issuance
-- ======================================

-- | The right to claim amulet issuances for a user's burns as their validator.
template ValidatorRight with
    dso : Party
    user : Party
    validator : Party
  where
    signatory user, validator

    choice ValidatorRight_ArchiveAsValidator : ValidatorRight_ArchiveAsValidatorResult
      controller validator
      do return ValidatorRight_ArchiveAsValidatorResult

    choice ValidatorRight_ArchiveAsUser : ValidatorRight_ArchiveAsUserResult
      controller user
      do return ValidatorRight_ArchiveAsUserResult

    -- TODO(M3-90): cancellation, withdrawal


-- | The right for an application provider to earn featured app rewards.
template FeaturedAppRight with
    dso : Party
    provider : Party
  where
    signatory dso
    observer provider

    choice FeaturedAppRight_Withdraw : FeaturedAppRight_WithdrawResult
      with
        reason : Text
      controller dso
      do return FeaturedAppRight_WithdrawResult

    choice FeaturedAppRight_Cancel : FeaturedAppRight_CancelResult
      controller provider
      do return FeaturedAppRight_CancelResult

    interface instance Splice.Api.FeaturedAppRightV1.FeaturedAppRight for FeaturedAppRight where
      view = Splice.Api.FeaturedAppRightV1.FeaturedAppRightView with dso, provider

      featuredAppRight_CreateActivityMarkerImpl _self arg = do
        validateAppRewardBeneficiaries arg.beneficiaries
        let groupedBeneficiaries = Map.fromListWithR (+) (map (\b -> (b.beneficiary, b.weight)) arg.beneficiaries)
        cids <- forA (Map.toList groupedBeneficiaries) $ \(beneficiary, weight) ->
          create FeaturedAppActivityMarker
            with
              dso
              provider
              beneficiary = beneficiary
              weight = weight
        pure (Splice.Api.FeaturedAppRightV1.FeaturedAppRight_CreateActivityMarkerResult $ map toInterfaceContractId cids)

    interface instance Splice.Api.FeaturedAppRightV2.FeaturedAppRight for FeaturedAppRight where
      view = Splice.Api.FeaturedAppRightV2.FeaturedAppRightView with dso, provider

      featuredAppRight_CreateActivityMarkerImpl _self arg = do
        validateAppRewardBeneficiariesV2 arg.beneficiaries
        require "Weight >= 1.0" (fromOptional 1.0 arg.weight >= 1.0)
        require "Weight <= 10000.0" (fromOptional 1.0 arg.weight <= 10000.0)
        let groupedBeneficiaries = Map.fromListWithR (+) (map (\b -> (b.beneficiary, b.weight)) arg.beneficiaries)
        cids <- forA (Map.toList groupedBeneficiaries) $ \(beneficiary, weight) ->
          create FeaturedAppActivityMarker
            with
              dso
              provider
              beneficiary = beneficiary
              weight = weight * fromOptional 1.0 arg.weight
        pure (Splice.Api.FeaturedAppRightV2.FeaturedAppRight_CreateActivityMarkerResult $ map toInterfaceContractId cids)

validateAppRewardBeneficiaries : [Splice.Api.FeaturedAppRightV1.AppRewardBeneficiary] -> Update ()
validateAppRewardBeneficiaries beneficiaries = do
  require "Beneficiary weights are between 0.0 and 1.0" (all (\beneficiary -> 0.0 < beneficiary.weight && beneficiary.weight <= 1.0) beneficiaries)
  require "Beneficiary weights add up to 1.0" (sum (map (.weight) beneficiaries) == 1.0)
  require "There are at most 20 beneficiaries" (length beneficiaries <= 20)

validateAppRewardBeneficiariesV2 : [Splice.Api.FeaturedAppRightV2.AppRewardBeneficiary] -> Update ()
validateAppRewardBeneficiariesV2 beneficiaries = do
  require "Beneficiary weights are between 0.0 and 1.0" (all (\beneficiary -> 0.0 < beneficiary.weight && beneficiary.weight <= 1.0) beneficiaries)
  require "Beneficiary weights add up to 1.0" (sum (map (.weight) beneficiaries) == 1.0)
  require "There are at most 20 beneficiaries" (length beneficiaries <= 20)

-- | A marker created by a featured application for activity generated from that app. This is used
-- to record activity other than amulet transfers where regular AppRewardCoupons are not created directly.
--
-- Will be converted to a AppRewardCoupon through automation run by the SVs and can then be
-- minted as part of the normal minting process.
template FeaturedAppActivityMarker
  with
    dso : Party
    provider : Party
      -- ^ The featured app provider that created the activity marker.
    beneficiary : Party
      -- ^ The party that has the right to mint the reward.
    weight : Decimal
      -- ^ The weight of the marker. This is used to split the rewards
      -- for a single action, e.g., multiple parties collaborating to enable
      -- a transfer,
      -- by creating several FeaturedAppActivityMarkers with different
      -- beneficiaries such that the weights add up to 1.0.
  where
    signatory dso
    observer provider, beneficiary
    ensure 0.0 < weight && weight <= 10000.0

    interface instance Splice.Api.FeaturedAppRightV1.FeaturedAppActivityMarker for FeaturedAppActivityMarker where
      view = Splice.Api.FeaturedAppRightV1.FeaturedAppActivityMarkerView with dso, provider, beneficiary, weight

    interface instance Splice.Api.FeaturedAppRightV2.FeaturedAppActivityMarker for FeaturedAppActivityMarker where
      view = Splice.Api.FeaturedAppRightV2.FeaturedAppActivityMarkerView with dso, provider, beneficiary, weight


-- | A coupon for receiving app rewards proportional to the usage fee paid as part of a
-- Amulet transfer coordinated by the app of a provider.
template AppRewardCoupon
  with
    dso : Party
    provider : Party -- ^ Application provider
    featured : Bool
    amount : Decimal
    round : Round
    beneficiary : Optional Party
      -- ^ The party that can mint this reward.
      -- If not set, this is the provider
  where
    signatory dso
    ensure amount > 0.0

    -- The provider is no signatory so their node's unavailability does not hold up the rewards issuance process.
    -- The coupon will be archived once it expired as part of standard DSO.
    observer provider, beneficiary

    choice AppRewardCoupon_DsoExpire : AppRewardCoupon_DsoExpireResult
      with
        closedRoundCid : ContractId ClosedMiningRound
      controller dso
      do
         -- Expiry requires proof of the coupon's round being closed, as all rounds go through their phases at their own pace
         void $ fetchReferenceData (ForRound with dso; round) closedRoundCid
         return AppRewardCoupon_DsoExpireResult with
           ..

-- | A coupon for receiving rewards, which is currently only used for
-- traffic-based app rewards.
--
-- Designed to be flexible so we could extend it to include other kinds of rewards
-- that are based on on off-ledger calculations.
-- See Splice.Amulet.RewardAccountingV2 for details.
template RewardCouponV2
  with
    dso : Party
    beneficiary : Party -- ^ The party that can claim the reward.
    round : Round -- ^ The round for which this reward can be claimed.
    amount : Decimal -- ^ The amount of reward to be claimed. Denominated in Amulet.
    expiresAt : Time -- ^ Time-based expiry. Used to determine when the reward can no longer be claimed.
    beneficiaryIsObserver : Bool
      -- ^ Whether the beneficiary should be an observer, which they are unless
      -- their vetting state at the time of coupon creation does not allow it.
      -- The DSO will then attempt to make the beneficiary an observer when they
      -- change their vetting state unless the coupon expired in the meantime.
  where
    signatory dso
    observer if beneficiaryIsObserver then [beneficiary] else []
    ensure amount > 0.0

    choice RewardCouponV2_DsoExpire : RewardCouponV2_DsoExpireResult
      controller dso
      do
        assertDeadlineExceeded "expiresAt" expiresAt
        return RewardCouponV2_DsoExpireResult with
          amount

    interface instance Api.RewardAssignmentV1.RewardCoupon for RewardCouponV2 where
      view = Api.RewardAssignmentV1.RewardCouponView with
        dso
        provider = beneficiary -- FIXME: rename benefiary to provider in coupon
        beneficiary
        amount
        expiresAt
        meta = Api.Token.MetadataV1.emptyMetadata
        maxNumNewBeneficiaries = maxNumNewCouponV2Beneficiaries

      rewardCoupon_assignBeneficiariesImpl _self arg = rewardCouponV2_assignBeneficiariesImpl this arg


-- | A coupon for receiving validator rewards proportional to the usage fee paid by a user
-- hosted by a validator operator.
template ValidatorRewardCoupon
  with
    dso : Party
    user : Party
    amount : Decimal
    round : Round
  where
    signatory dso
    ensure amount > 0.0

    -- The user is no signatory so their node's unavailability does not hold up the rewards issuance process.
    -- The coupon will be archived once it expired as part of standard DSO.
    observer user

    choice ValidatorRewardCoupon_DsoExpire : ValidatorRewardCoupon_DsoExpireResult
      with
        closedRoundCid : ContractId ClosedMiningRound
      controller dso
      do
         -- Expiry requires proof of the coupon's round being closed, as all rounds go through their phases at their own pace
        void $ fetchReferenceData (ForRound with dso; round) closedRoundCid
        return ValidatorRewardCoupon_DsoExpireResult with ..


    choice ValidatorRewardCoupon_ArchiveAsValidator : ValidatorRewardCoupon_ArchiveAsValidatorResult
      -- ^ This choice is used by validators to archive the burn receipt upon claiming its corresponding issuance.
      with
        validator : Party
        rightCid : ContractId ValidatorRight
      controller dso, validator
      do
        requireMatchingContract rightCid (ValidatorRight with dso; validator, user)
        return ValidatorRewardCoupon_ArchiveAsValidatorResult


-- | A coupon for a beneficiary to receive part of the SV issuance for a specific SV node and round.
template SvRewardCoupon with
    dso : Party
    sv : Party -- ^ The party identifying the SV node for which the reward is issued.
    beneficiary : Party -- ^ The beneficiary allowed to receive the reward.
    round : Round
    weight : Int -- ^ Coupons receive a share of the SV issuance proportional to their weight.
  where
    ensure weight > 0

    signatory dso

    -- The beneficiary is an observer of the coupon, as they need to be able to claim it; but they are not
    -- a signatory, to avoid their node's unavailability to block the coupon issuance.
    observer beneficiary

    -- The SV is an observes so they can see both the transaction creating and the one archiving the coupon.
    -- They are not a signatory to ensure their node's unavailability cannot block the coupon redemption.
    observer sv

    choice SvRewardCoupon_DsoExpire : SvRewardCoupon_DsoExpireResult
      with
        closedRoundCid : ContractId ClosedMiningRound
      controller dso
      do
         -- Expiry requires proof of the coupon's round being closed, as all rounds go through their phases at their own pace
        void $ fetchReferenceData (ForRound with dso; round) closedRoundCid
        return SvRewardCoupon_DsoExpireResult with ..

    -- Choice called by the beneficiary as part of a AmuletRules_Transfer to claim the reward.
    choice SvRewardCoupon_ArchiveAsBeneficiary : SvRewardCoupon_ArchiveAsBeneficiaryResult
      controller beneficiary
      do return SvRewardCoupon_ArchiveAsBeneficiaryResult


-- | A coupon recording an emission for the Development Fund from CIP-0082 that
-- was not yet assigned to a specific beneficiary.
template UnclaimedDevelopmentFundCoupon
  with
    dso : Party
    amount : Decimal -- ^ The total amount of `Amulet` to mint on collection.
  where
    signatory dso
    ensure amount > 0.0

-- | A coupon recording an emission for the Development Fund under CIP-0082,
-- which can be collected by the designated beneficiary.
template DevelopmentFundCoupon
  with
    dso : Party
    beneficiary : Party -- ^ The owner of the `Amulet` to be minted.
    fundManager : Party
      -- ^ The party that executed the assignment of the coupon to the beneficiary
      -- so they can mint from the development fund.
    amount : Decimal -- ^ The total amount of `Amulet` to mint on collection.
    expiresAt : Time -- ^ Until when the minting can be completed.
    reason : Text -- ^ Reason for the emission of the coupon.
  where
    ensure amount > 0.0

    signatory dso

    -- The beneficiary is an observer of the coupon, as they need to be able to claim it.
    observer beneficiary

    -- The fundManager is an observer so they can see both the transaction creating and the one archiving the coupon.
    observer fundManager

    choice DevelopmentFundCoupon_Withdraw : DevelopmentFundCoupon_WithdrawResult
      with
        reason : Text -- ^ Reason for withdrawing the coupon.
      controller fundManager
      do
        assertWithinDeadline "DevelopmentFundCoupon.expiresAt" expiresAt
        unclaimedDevelopmentFundCouponCid <- create UnclaimedDevelopmentFundCoupon with dso; amount
        return DevelopmentFundCoupon_WithdrawResult with unclaimedDevelopmentFundCouponCid

    choice DevelopmentFundCoupon_Reject : DevelopmentFundCoupon_RejectResult
      with
        reason : Text -- ^ Reason for rejecting the coupon.
      controller beneficiary
      do
        assertWithinDeadline "DevelopmentFundCoupon.expiresAt" expiresAt
        unclaimedDevelopmentFundCouponCid <- create UnclaimedDevelopmentFundCoupon with dso; amount
        return DevelopmentFundCoupon_RejectResult with unclaimedDevelopmentFundCouponCid

    choice DevelopmentFundCoupon_DsoExpire : DevelopmentFundCoupon_DsoExpireResult
      controller dso
      do
        assertDeadlineExceeded "DevelopmentFundCoupon.expiresAt" expiresAt
        unclaimedDevelopmentFundCouponCid <- create UnclaimedDevelopmentFundCoupon with dso; amount
        pure DevelopmentFundCoupon_DsoExpireResult with unclaimedDevelopmentFundCouponCid


-- | Rewards that have not been claimed and are thus at the disposal of the foundation.
template UnclaimedReward with
    dso : Party
    amount : Decimal
  where
    ensure amount > 0.0

    signatory dso

-- | A record of activity that can be minted by the beneficiary.
-- Note that these do not come out of the per-round issuance but are instead created by burning
-- UnclaimedRewardCoupon as defined through a vote by the SVs. That's also why expiry is a separate
-- time-based expiry instead of being tied to a round like the other activity records.
template UnclaimedActivityRecord
  with
    dso : Party
    beneficiary : Party -- ^ The owner of the `Amulet` to be minted.
    amount : Decimal -- ^ The amount of `Amulet` to be minted.
    reason : Text -- ^ A reason to mint the `Amulet`.
    expiresAt : Time -- ^ Selected timestamp defining the lifetime of the contract.
  where
    signatory dso
    observer beneficiary
    ensure amount > 0.0

    choice UnclaimedActivityRecord_DsoExpire : UnclaimedActivityRecord_DsoExpireResult
      controller dso
      do
        assertDeadlineExceeded "UnclaimedActivityRecord.expiresAt" expiresAt
        unclaimedRewardCid <- create UnclaimedReward with dso; amount
        pure UnclaimedActivityRecord_DsoExpireResult with unclaimedRewardCid


-- Support code
---------------

requireAmuletExpiredForAllRounds : ContractId ExternalPartyConfigState -> ContractId ExternalPartyConfigState -> Amulet -> Update ()
requireAmuletExpiredForAllRounds externalPartyConfigState0Cid externalPartyConfigState1Cid amulet = do
  require "externalPartyConfigState0Cid /= externalPartyConfigState1Cid" (externalPartyConfigState0Cid /= externalPartyConfigState1Cid)
  config0 <- fetchReferenceData (ForDso with dso = amulet.dso) externalPartyConfigState0Cid
  config1 <- fetchReferenceData (ForDso with dso = amulet.dso) externalPartyConfigState1Cid
  let round = min config0.holdingFeesOpenRoundNumber config1.holdingFeesOpenRoundNumber
  require "Amulet is expired" (isAmuletExpired round amulet.amount)

-- | Maximum number of new beneficiaries that can be assigned to a RewardCouponV2.
-- Set to the same limit as the one for featured-app-marker beneficiaries to minmize migration effort
-- for app providers.
maxNumNewCouponV2Beneficiaries : Int
maxNumNewCouponV2Beneficiaries = 20

-- | Implementation of the 'RewardCoupon_AssignBeneficiaries' choice for 'RewardCouponV2'.
rewardCouponV2_assignBeneficiariesImpl
  : RewardCouponV2
  -> Api.RewardAssignmentV1.RewardCoupon_AssignBeneficiaries
  -> Update Api.RewardAssignmentV1.RewardCoupon_AssignBeneficiariesResult
rewardCouponV2_assignBeneficiariesImpl coupon arg = do
  let newBeneficiaries = arg.newBeneficiaries
  let totalNewBeneficiaryAmount = sum (map (.amount) arg.newBeneficiaries)
  require ("No more than " <> show maxNumNewCouponV2Beneficiaries <> " beneficiaries assigned")
    (length arg.newBeneficiaries <= maxNumNewCouponV2Beneficiaries)
  require "Total amount assigned to new beneficiaries below coupon amount" (totalNewBeneficiaryAmount <= coupon.amount)

  -- return remainder to original beneficiary
  let remainingAmount = coupon.amount - totalNewBeneficiaryAmount
  originalBeneficiaryRemainderCid <-
    if (remainingAmount > 0.0)
      then do
        Some <$> create coupon with
          amount = remainingAmount
          beneficiaryIsObserver = True
      else do
        pure None

  -- create coupons for new beneficiaries
  newBeneficiaryCouponCids <- forA newBeneficiaries $ \newBeneficiary -> do
    create coupon with
      amount = newBeneficiary.amount
      beneficiary = newBeneficiary.beneficiary
      beneficiaryIsObserver = True

  return Api.RewardAssignmentV1.RewardCoupon_AssignBeneficiariesResult with
    newBeneficiariesCouponCids = map toInterfaceContractId newBeneficiaryCouponCids
    originalBeneficiaryRemainderCid = fmap toInterfaceContractId originalBeneficiaryRemainderCid


-- instances
------------

instance HasCheckedFetch Amulet ForOwner where
  contractGroupId Amulet{..} = ForOwner with ..

instance HasCheckedFetch LockedAmulet ForOwner where
  contractGroupId lockedAmulet = contractGroupId (lockedAmulet.amulet)

instance HasCheckedFetch AppRewardCoupon ForOwner where
  contractGroupId AppRewardCoupon{..} = ForOwner with dso; owner = fromOptional provider beneficiary

instance HasCheckedFetch RewardCouponV2 ForOwner where
  contractGroupId RewardCouponV2{..} = ForOwner with dso; owner = beneficiary

instance HasCheckedFetch RewardCouponV2 ForDso where
  contractGroupId RewardCouponV2{..} = ForDso with dso

instance HasCheckedFetch SvRewardCoupon ForOwner where
  contractGroupId SvRewardCoupon{..} = ForOwner with dso; owner = beneficiary

-- This instance is slightly dangerous, as it could lead to a missed check of the validator.
-- We accept this, as at least the DSO party check is done, and the remainder is careful coding.
instance HasCheckedFetch ValidatorRewardCoupon ForDso where
  contractGroupId ValidatorRewardCoupon {..} = ForDso with dso

instance HasCheckedFetch UnclaimedReward ForDso where
  contractGroupId UnclaimedReward {..} = ForDso with dso

instance HasCheckedFetch FeaturedAppActivityMarker ForOwner where
  contractGroupId FeaturedAppActivityMarker {..} = ForOwner with dso; owner = provider

instance HasCheckedFetch FeaturedAppActivityMarker ForDso where
  contractGroupId FeaturedAppActivityMarker {..} = ForDso with dso

instance HasCheckedFetch UnclaimedActivityRecord ForOwner where
  contractGroupId UnclaimedActivityRecord{..} = ForOwner with dso; owner = beneficiary

instance HasCheckedFetch UnclaimedDevelopmentFundCoupon ForDso where
  contractGroupId UnclaimedDevelopmentFundCoupon{..} = ForDso with dso

instance HasCheckedFetch DevelopmentFundCoupon ForOwner where
  contractGroupId DevelopmentFundCoupon{..} = ForOwner with dso; owner = beneficiary

instance HasCheckedFetch DevelopmentFundCoupon ForDso where
  contractGroupId DevelopmentFundCoupon{..} = ForDso with dso
