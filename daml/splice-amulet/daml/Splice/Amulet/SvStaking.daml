-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Staking for the SV rewards tranche Splice Amulet.
module Splice.Amulet.SvStaking where

import DA.Map as Map
import DA.Time
import DA.Set as Set


-- Data types
-------------

-- | DSO level configuration for SV staking.
data StakingConfig = StakingConfig with
    stakingDelay : RelTime -- ^ Delay before a stake becomes active.
    unlockDelay : RelTime -- ^ Delay until a stake is fully unlocked.
    minStakeAmount : Decimal
      -- ^ Minimum amount required to stake.
      -- Used to avoid lots of small stakes that cause a high tracking overhead.
      --
      -- Note: unlocks are only allowed if the remaining stake is 0.0 or >= minStakeAmount.
    stakingWeightSchedule  : [(Decimal, Decimal)] -- ^ List of (percentageLocked, percentageEarned) pairs.
  deriving (Eq, Show)

-- | Configuration determined by each staker for their own stakes.
data StakerConfig = StakerConfig with
    relockRatio : Decimal -- ^ Ratio of unlocked stake that is automatically relocked. Most be in [0.0, 1.0].
  deriving (Eq, Show)

-- | State of an individual staker.
data StakerState = StakerState with
    config :  StakerConfig -- ^ Configuration chosen by the staker.
    lifetimeRewards : Decimal -- ^ Total lifetime rewards earned by the staker.
    exemptedLifetimeRewards : Decimal
      -- ^ Portion of lifetime rewards that are exempted from staking requirements.
      -- MAY be negative to reflect an exemption for future rewards.
      --
      -- Determined using SV voting.
    mintingAllowance : Decimal -- ^ Unused minting allowance for SV rewards.
    unconstrainedStake : Decimal -- ^ Amount of stake that is not currently locked or constrained.
    stakes : [Stake] -- ^ Stakes with constraints.
  deriving (Eq, Show)

-- | An individual stake with its associated metadata.
data Stake = Stake with
    amount : Decimal
    stakedAt : Time -- ^ When the stake was created.
    requestedUnlockAt : Optional Time -- ^ When an unlock was requested, if any.
  deriving (Eq, Show)

-- | State of the SV staking system.
data StakingState = StakingState with
    config : StakingConfig -- ^ Global staking configuration.
    stakers : Map Party StakerState
    -- ^ State per staker.
    --
    -- NOTE: in the actual implementation, we would maintain each of these entries as its own contract
    -- on the ledger to avoid scalability issues.
    --
    -- The likely implementation is one where there's DSO only state that keeps track of the
    -- staking state; and a separate reconciliation process that updates the states visible
    -- to stakers on a regular basis. Thereby avoiding that a staker which unvets splice-amulet
    -- can block the reward distribution to other stakers.
    --
    -- The computation is likely organized using off-ledger agreement on the totals for the
    -- third-party staking pool and then each staker's state is updated in its own transaction.
    -- The total is computed using action-with confirmation. We exploit that the total staked
    -- as of a particular time does not change due to the explicit time information associated
    -- with stakes.
  deriving (Eq, Show)


-- Reward calculation
---------------------

-- | Context information required to compute SV minting allowances.
data SvMintingContext = SvMintingContext with
    roundClosedAt : Time -- ^ Time when the mining round was closed. Used to determine eligibility of stakes.
    totalSvMintingAllowance : Decimal
    svWeights : Map Party Decimal -- ^ Weights of SV parties configured as part of DSO governance.
    skippedSvs : Set Party -- ^ SVs to skip for this round; e.g.. due to being unavailable.

-- | Update the minting allowances of all stakers based on their stakes to
-- reflect their new minting allowance for a minting round.
updateMintingAllowances : SvMintingContext -> StakingState -> StakingState
updateMintingAllowances context stakingState =
    stakingState with
      stakers = Map.fromList $ map updateStakerState $ Map.toList stakingState.stakers
  where
    -- evaluate all time-dependent conditions at the round closing time
    now = context.roundClosedAt

    isStaked : Stake -> Bool
    isStaked stake =
      stake.stakedAt `addRelTime` stakingState.config.stakingDelay <= now &&
      case stake.requestedUnlockAt of
        None -> True
        Some unlockRequestedAt ->
          now < unlockRequestedAt `addRelTime` stakingState.config.unlockDelay

    getStakedAmount : StakerState -> Decimal
    getStakedAmount stakerState =
      stakerState.unconstrainedStake + sum do
        stake <- stakerState.stakes
        guard (isStaked stake)
        pure stake.amount

    -- determine forward earned and unearned SV weigths per SV staker
    adjustedSvWeights : Map Party (Decimal, Decimal) -- (earnedWeight, unearnedWeight)
    adjustedSvWeights = Map.fromList $ do
      (sv, weight) <- Map.toList context.svWeights
      if Set.member sv context.skippedSvs
        then pure (sv, (0.0, weight)) -- weight of a skipped SV staker goes entirely to unearned weight
        else case Map.lookup sv stakingState.stakers of
          None -> pure (sv, (0.0, weight))
          Some stakerState -> do
            let stakedAmount = getStakedAmount stakerState
            let consideredLifetimeRewards =
                  max 0.0 (stakerState.lifetimeRewards - stakerState.exemptedLifetimeRewards)
            let stakedRatio
                  | consideredLifetimeRewards == 0.0 = 1.0
                  | otherwise = min 1.0 (stakedAmount / consideredLifetimeRewards)
            let earnedRatio = getEarnedRatio stakingState.config.stakingWeightSchedule stakedRatio
            let earnedWeight = weight * earnedRatio
            let unearnedWeight = weight - earnedWeight
            pure (sv, (earnedWeight, unearnedWeight))

    -- compute split of minting allowance between staking pool and SV pool
    stakingPoolWeight = sum [ unearnedWeight | (_, unearnedWeight) <- Map.values adjustedSvWeights ]
    svPoolWeight = sum [ earnedWeight | (earnedWeight, _) <- Map.values adjustedSvWeights ]
    totalWeight = stakingPoolWeight + svPoolWeight

    stakingPoolMintingAllowance : Decimal
    stakingPoolMintingAllowance
      | totalWeight <= 0.0 = context.totalSvMintingAllowance
      | otherwise = (context.totalSvMintingAllowance * stakingPoolWeight) / totalWeight

    svPoolMintingAllowance : Decimal
    svPoolMintingAllowance = context.totalSvMintingAllowance - stakingPoolMintingAllowance

    -- compute allowance params
    totalThirdPartyStake = sum $ do
      (staker, stakerState) <- Map.toList stakingState.stakers
      guard (not (Map.member staker adjustedSvWeights))
      pure (getStakedAmount stakerState)

    mintingAllowancePerSvWeight : Decimal
    mintingAllowancePerSvWeight
      | svPoolWeight > 0.0 = svPoolMintingAllowance / svPoolWeight
      | otherwise = 0.0

    -- update staker state with new minting allowances
    updateStakerState : (Party, StakerState) -> (Party, StakerState)
    updateStakerState (staker, stakerState) =
        (staker, newStakerState)
      where
        newStakerState =
          case Map.lookup staker adjustedSvWeights of
            -- SV staker: issue for earned weight only
            Some (earnedWeight, _) ->
              let totalAllowance = earnedWeight * mintingAllowancePerSvWeight
              in
                  addTotalAllowance totalAllowance stakerState

            None ->
              -- Third-party staker: issue from staking pool for their part of the total pool stake
              -- Note that an SV staker that is offboarded from the SVs will become a third-party staker.
              let stakedAmount = getStakedAmount stakerState
                  totalAllowance = stakingPoolMintingAllowance * (stakedAmount / totalThirdPartyStake)
                  -- TODO: double-check that division by zero is not possible here; it should not as the stakedAmount is added to the totalThirdPartyStake
              in
                addTotalAllowance totalAllowance stakerState

addTotalAllowance : Decimal -> StakerState -> StakerState
addTotalAllowance totalAllowance stakerState =
    stakerState with
      lifetimeRewards = stakerState.lifetimeRewards + totalAllowance
      mintingAllowance = stakerState.mintingAllowance + mintAmount
      unconstrainedStake = stakerState.unconstrainedStake + relockAmount
  where
    relockAmount = totalAllowance * stakerState.config.relockRatio
    mintAmount = totalAllowance - relockAmount

getEarnedRatio : [(Decimal, Decimal)] -> Decimal -> Decimal
getEarnedRatio schedule stakedRatio =
  case dropWhile (\(minStakedRatio, _) -> stakedRatio < minStakedRatio) (reverse schedule) of
    [] -> 0.0
    (_, earnedRatio) :: _ -> earnedRatio


-- Normalization of stakes
--------------------------

-- NOTE: normalization is not strictly required for correctness of the staking logic.
-- It is a potential optimization to reduce the number of stakes that need to be tracked.
-- Care must be taken to synchronize normalization with off-ledger stake total computations for
-- a specific round.

-- | Normalize stakes as of the given time so that as many stakes as possible are absorbed
-- into the unconstrained stake or the minting allowance.
normalizeStakingStateAsOf : Time -> StakingState -> StakingState
normalizeStakingStateAsOf now stakingState =
    stakingState with
      stakers = fmap (normalizeStakesAsOf now stakingState.config) stakingState.stakers

-- | Normalize stakes as of the given time so that as many stakes as possible are absorbed
-- into the unconstrained stake or the minting allowance.
normalizeStakesAsOf : Time -> StakingConfig -> StakerState -> StakerState
normalizeStakesAsOf now stakingConfig stakerState =
    newStakingState with
      stakes = reverse newStakingState.stakes
  where
    newStakingState = foldl normalize (stakerState with stakes = []) stakerState.stakes

    isUnlocked : Stake -> Bool
    isUnlocked stake =
      case stake.requestedUnlockAt of
        None -> False
        Some unlockRequestedAt ->
          unlockRequestedAt `addRelTime` stakingConfig.unlockDelay <= now

    normalize : StakerState -> Stake -> StakerState
    normalize stakerState stake
      | isUnlocked stake =
          stakerState with
            mintingAllowance = stakerState.mintingAllowance + stake.amount
      | now <= stake.stakedAt `addRelTime` stakingConfig.stakingDelay =
          stakerState with
            unconstrainedStake = stakerState.unconstrainedStake + stake.amount
      | otherwise =
          stakerState with
            stakes = stake :: stakerState.stakes
