-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Staking for the SV rewards tranche Splice Amulet.
module Splice.Amulet.SvStaking where

import DA.Action.State (State, runState)
import DA.Map as Map
import DA.Time
import DA.Set as Set

data StakingConfig = StakingConfig with
    stakingDelay : RelTime -- ^ Delay before a stake becomes active.
    unlockDelay : RelTime -- ^ Delay until a stake is fully unlocked.
    minStakeAmount : Decimal -- ^ Minimum amount required to stake, used to avoid dust stakes.
  deriving (Eq, Show)

data StakerConfig = StakerConfig with
    relockRatio : Decimal -- ^ Ratio of unlocked stake that is automatically relocked. Most be in [0.0, 1.0].
  deriving (Eq, Show)

data StakerState = StakerState with
    config :  StakerConfig
    lifetimeRewards : Decimal -- ^ Total lifetime rewards earned by the staker.
    mintingAllowance : Decimal -- ^ Unused minting allowance for SV rewards.
    unconstrainedStake : Decimal -- ^ Amount of stake that is not currently locked or constrained.
    stakes : [Stake] -- ^ Stakes with constraints.
  deriving (Eq, Show)

data Stake = Stake with
    amount : Decimal
    stakedAt : Time
    requestedUnlockAt : Optional Time
  deriving (Eq, Show)

data StakingState = StakingState with
    config : StakingConfig
    stakers : Map Party StakerState
  deriving (Eq, Show)

type SvWeights = Map Party Decimal
type SvMintingAllowance = Map Party Decimal
type StakingWeightSchedule = [(Decimal, Decimal)] -- ^ List of (percentageLocked, percentageEarned) pairs.



data SvMintingContext = SvMintingContext with
    roundClosedAt : Time -- ^ Time when the mining round was closed. Used to determine eligibility of stakes.
    getEarnedRatio : Decimal -> Decimal -- ^ Function to compute earned percentage from locked percentage.
    totalSvMintingAllowance : Decimal
    svWeights : SvWeights
    skipSv : Party -> Bool -- ^ Function to determine whether to ignore a given SV staker; e.g., due to unavailability during the round.

updateMintingAllowances : SvMintingContext -> StakingState -> StakingState
updateMintingAllowances context stakingState =
    stakingState with
      stakers = Map.mapWithKey updateStakerState stakingState.stakers
  where
    now = context.roundClosedAt

    -- determine locked stake per staker
    stakerLockedAmounts : Map Party Decimal
    stakerLockedAmounts = Map.map computeLockedAmount stakingState.stakers

    computeLockedAmount : StakerState -> Decimal
    computeLockedAmount stakerState = sum $ map amount $ filter isLocked stakerState.stakes

    unlockDelay = stakingState.config.unlockDelay

    isStaked : Stake -> Bool
    isStaked stake =
      stake.stakedAt `addRelTime` stakingState.config.stakingDelay <= now &&
      case stake.requestedUnlockAt of
        None -> True
        Some t -> now < t `addRelTime` unlockDelay

    isSvStaker : Party -> Bool
    isSvStaker sv = Map.member sv context.svWeights

    -- determine forward earned and unearned SV weigths per SV staker
    svWeights : Map Party (Decimal, Decimal) -- (earnedWeight, unearnedWeight)
    svWeights = Map.fromList $ do
      (sv, weight) <- Map.toList svWeights
      if context.skipSv sv
        then pure (sv, (0.0, weight))
        else case Map.lookup sv stakingState.stakers of
          None -> pure (sv, (0.0, weight))
          Some stakerState ->
            let lockedAmount = computeLockedAmount stakerState
            let lockedRatio
                  | stakerState.lifetimeRewards == 0.0 = 1.0
                  | otherwise = min 1.0 (lockedAmount / stakerState.lifetimeRewards)
            let earnedRatio = getEarnedRatio lockedRatio
            let earnedWeight = weight * earnedRatio
            let unearnedWeight = weight - earnedWeight
            pure (sv, (earnedWeight, unearnedWeight))

    stakingPoolWeight = sum [ unearnedWeight | (_, (_, unearnedWeight)) <- Map.toList svWeights ]
    svPoolWeight = sum [ earnedWeight | (_, (earnedWeight, _)) <- Map.toList svWeights ]

    stakingPoolMintingAllowance : Decimal
    stakingPoolMintingAllowance = context.totalSvMintingAllowance * stakingPoolWeight / (stakingPoolWeight + svPoolWeight)

    svPoolMintingAllowance : Decimal
    svPoolMintingAllowance = context.totalSvMintingAllowance - stakingPoolMintingAllowance

    totalThirdPartyStake = sum $ do
      (staker, stakerState) <- Map.toList stakingState.stakers
      guard (not (isSvStaker staker))
      stake <- stakerState.stakes
      guard (isStaked stake)
      pure stake.amount

    mintingAllowancePerSvWeight : Decimal
    mintingAllowancePerSvWeight
      | svPoolWeight > 0.0 = svPoolMintingAllowance / svPoolWeight
      | otherwise = 0.0


    updateStakerState : Party -> StakerState -> StakerState
    updateStakerState staker stakerState =
      case Map.lookup staker svWeights of
        Some (earnedWeight, _) ->
          let totalAllowance = earnedWeight * mintingAllowancePerSvWeight
          let relockAmount = totalAllowance * stakerState.config.relockRatio
          let mintAmount = totalAllowance - relockAmount
          in
            StakerState with
              config = stakerState.config
              stakes = stakerState.stakes
              lifetimeRewards = stakerState.lifetimeRewards + totalAllowance
              mintingAllowance = stakerState.mintingAllowance + mintAmount
              unconstrainedStake = stakerState.unconstrainedStake + relockAmount

        None ->
          let totalStake = stakerState.unconstrainedStake + sum [ stake.amount | stake <- stakerState.stakes, isStaked stake ]
          let totalAllowance = stakingPoolMintingAllowance * (totalStake / totalThirdPartyStake)
          let relockAmount = totalAllowance * stakerState.config.relockRatio
          let mintAmount = totalAllowance - relockAmount
          in
            StakerState with
              config = stakerState.config
              stakes = stakerState.stakes
              lifetimeRewards = stakerState.lifetimeRewards + totalAllowance
              mintingAllowance = stakerState.mintingAllowance + mintAmount
              unconstrainedStake = stakerState.unconstrainedStake + relockAmount


-- | Normalize stakes as of the given time so that as many stakes as possible are absorbed
-- into the unconstrained stake or the minting allowance.
normalizeStakesAsOf : Time -> StakingConfig -> StakerState -> StakerState
normalizeStakesAsOf now stakingConfig stakingState =
    newStakingState with
      stakes = reverse newStakingState.stakes
  where
    newStakingState = foldl normalize (stakingState with stakes = []) stakingState.stakes

    normalize : StakingState -> Stake -> StakingState
    normalize stakingState stake
      | isUnlocked stake =
          stakingState with
            mintingAllowance = stakingState.mintingAllowance + stake.amount
      | now <= stake.stakedAt `addRelTime` stakingConfig.stakingDelay =
          stakingState with
            unconstrainedStake = stakingState.unconstrainedStake + stake.amount
      | otherwise =
          stakingState with
            stakes = stake :: stakingState.stakes


