-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Generic code for a two-step transfer of amulet. The first step is to lock
-- the amulet, the second step is to transfer it.

module Splice.Amulet.TwoStepTransfer (
  TwoStepTransfer(..),

  prepareTwoStepTransfer,
  executeTwoStepTransfer,
  abortTwoStepTransfer,

  -- * Shared support code
  holdingToTransferInputs,
) where

import DA.Assert
import DA.Optional (fromOptional, optionalToList)

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1

import Splice.Amulet
import Splice.Amulet.TokenApiUtils
import Splice.AmuletRules
import Splice.Expiry
import Splice.Types
import Splice.Util


data TwoStepTransfer = TwoStepTransfer with
    dso : Party
    sender : Party
    receiver : Party
    amount : Decimal
    lockContext : Text
      -- ^ Context description of the lock. This is used to display the reason for
      -- the lock in wallets.
    transferBefore : Time
    transferBeforeDeadline : Text -- ^ Name of the deadline for the transfer
    provider : Party
      -- ^ Provider that should be marked as the app provider on the second step.
    allowFeaturing : Bool
      -- ^ Whether the second step can be featured.

-- | Converting a set of holding inputs to inputs for an amulet transfer,
-- unlocking any expired LockedAmulet holdings on the fly.
holdingToTransferInputs : ForOwner -> [ContractId Holding] -> Update [TransferInput]
holdingToTransferInputs forOwner inputHoldingCids =
  forA inputHoldingCids $ \holdingCid -> do
    holding <- fetchCheckedInterface @Holding forOwner holdingCid
    case fromInterface holding of
      Some (LockedAmulet {}) -> do
        let lockedAmuletCid : ContractId LockedAmulet = fromInterfaceContractId holdingCid
        -- We assume the lock is expired, and if not then we rely `LockedAmulet_OwnerExpireLockV2` to fail
        result <- exercise lockedAmuletCid LockedAmulet_OwnerExpireLockV2
        pure $ InputAmulet result.amuletCid
      None -> pure $ InputAmulet $ coerceContractId holdingCid

-- | Prepare a two-step transfer of amulet by locking the funds.
prepareTwoStepTransfer : TwoStepTransfer -> Time -> [ContractId Holding] -> ExternalPartyTransferContext -> Update (ContractId LockedAmulet, [ContractId Holding], Metadata)
prepareTwoStepTransfer TwoStepTransfer{..} requestedAt inputHoldingCids paymentContext = do
  require "requestedAt < transferBefore" (requestedAt < transferBefore)
  -- lock the amulet
  transferInputs <- holdingToTransferInputs (ForOwner with dso; owner = sender) inputHoldingCids
  let transfer = Splice.AmuletRules.Transfer with
        sender
        provider = sender -- the sender is serving as its own "app provider"
        outputs =
          [ TransferOutput with
              receiver = sender
              amount = amount
              receiverFeeRatio = 0.0 -- irrelevant as fees are always zero
              lock = Some TimeLock with
                expiresAt = transferBefore
                holders = [dso]
                optContext = Some lockContext
          ]
        inputs = transferInputs
        beneficiaries = None

  result <- executeExternalPartyTransfer dso paymentContext transfer
  let [TransferResultLockedAmulet lockedAmulet] = result.createdAmulets
  pure
    ( lockedAmulet
    , toInterfaceContractId <$> optionalToList result.senderChangeAmulet
    , fromOptional emptyMetadata result.meta
    )

executeTwoStepTransfer
  : TwoStepTransfer -> ContractId LockedAmulet -> ExtraArgs
  -> Update ([ContractId Holding], [ContractId Holding], Metadata)
executeTwoStepTransfer TwoStepTransfer{..} lockedAmuletCid extraArgs = do
  assertWithinDeadline transferBeforeDeadline transferBefore
  (paymentContext, beneficiaries) <-
    if allowFeaturing
      then do
        beneficiaries <- either fail pure $ beneficiariesFromMetadata extraArgs.meta
        context <- paymentFromChoiceContext dso extraArgs.context
        pure (context, beneficiaries)
      else do
        -- ignore beneficiaries in case we are not allowing featuring
        context <- unfeaturedPaymentContextFromChoiceContext dso extraArgs.context
        pure (context, None)
  -- unlock amulet
  unlockResult <- exercise lockedAmuletCid LockedAmulet_UnlockV2
  let amuletCid = unlockResult.amuletCid
  -- execute transfer
  let receiverOutput = TransferOutput with
        receiver = receiver
        amount = amount
        receiverFeeRatio = 0.0  -- all fees are paid by the sender
        lock = None
  let amuletRulesTransfer = Splice.AmuletRules.Transfer with
        sender
        provider
        inputs = [InputAmulet amuletCid]
        outputs = [receiverOutput]
        beneficiaries
  result <- executeExternalPartyTransfer dso paymentContext amuletRulesTransfer
  pure
    ( optionalToList (toInterfaceContractId <$> result.senderChangeAmulet)
    , createdAmuletToHolding <$> result.createdAmulets
    , fromOptional emptyMetadata result.meta
    )

abortTwoStepTransfer : TwoStepTransfer -> ContractId LockedAmulet -> ExtraArgs -> Update [ContractId Holding]
abortTwoStepTransfer TwoStepTransfer{..} lockedAmuletCid extraArgs = do
  expireLockedAmulet <- getFromContextU @Bool extraArgs.context expireLockKey
  if expireLockedAmulet
    then do
      result <- exercise lockedAmuletCid LockedAmulet_UnlockV2
      pure [toInterfaceContractId result.amuletCid]
    else do
      -- scan is telling us to not expire the lock, this is OK if the transfer expired
      assertDeadlineExceeded transferBeforeDeadline transferBefore
      pure []
