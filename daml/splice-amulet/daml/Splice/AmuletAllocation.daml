-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.AmuletAllocation (
  AmuletAllocation(..),
  allocationAmount,
  allocationToTwoStepTransfer,
) where

import DA.Text as Text
import DA.TextMap qualified as TextMap

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV2
import Splice.Api.Token.AllocationV1 qualified as AllocationV1
import Splice.Api.Token.AllocationV2
import Splice.Api.Token.UtilsV2

import Splice.Amulet
import Splice.Amulet.TwoStepTransfer
import Splice.Amulet.TokenApiUtils (amuletInstrumentId)
import qualified DA.Map as Map
import DA.Optional (fromSome)
import DA.Assert ((===))

-- | Amulet allocated in locked form to a trade.
template AmuletAllocation
  with
    lockedAmulet : Optional (ContractId LockedAmulet) 
    -- ^ Locked amulet that holds the funds for the allocation.
    -- Empty if no outgoing legs.
    allocation : AllocationSpecification
    sender : Party
    admin : Party
    expiresAt : Time
  where
    signatory admin, sender
    observer allocation.settlement.executor

    ensure 
      all 
        (\tl -> (
            -- Sender needs to appear as sender or receiver of each leg.
            sender `elem` [tl.sender.owner, tl.receiver.owner]) 
            -- Only one admin Id allowed.
            && tl.instrumentId.admin == admin) 
        allocation.transferLegs

    interface instance Allocation for AmuletAllocation where
      view = AllocationView with
        allocation
        holdingCids = Map.fromList $ optional [] (\la -> [(amuletInstrumentId admin, [toInterfaceContractId la])]) lockedAmulet
        meta = emptyMetadata
        sender = basicAccount sender
        expiresAt = Some expiresAt

      allocation_executeTransferImpl self args =
        default_allocation_executeTransferImpl (toInterface this) self args

      allocation_withdrawImpl _self Allocation_Withdraw{..} = do
        senderHoldingCids <- unlockAmuletAllocation this extraArgs
        pure Allocation_WithdrawResult
          with
            senderHoldingCids
            meta = emptyMetadata

      allocation_cancelImpl _self Allocation_Cancel{..} = do
        senderHoldingCids <- unlockAmuletAllocation this extraArgs
        pure Allocation_CancelResult
          with
            senderHoldingCids
            meta = emptyMetadata

      allocation_getTransferAuthorizationsImpl _self Allocation_GetTransferAuthorizations{..} = do
        TextMap.fromList . concat <$>
          mapA
            (\tl ->
              if tl.sender.owner == sender || (sender `notElem` allocationControllers allocation)
                then do
                  authCid <- create AmuletAllocationTransferAuthorization with
                    authorizer = sender
                    transferLeg = tl
                    settlement = allocation.settlement
                    admin
                    expiresAt
                    extraArgs
                  return [(tl.transferLegId, toInterfaceContractId authCid)]
                else return []
            )
            allocation.transferLegs

    interface instance AllocationV1.Allocation for AmuletAllocation where
      view = allocation_view_v2_to_v1 (view (toInterface @Allocation this))

      AllocationV1.allocation_executeTransferImpl = allocation_v1_executeTransferImpl (toInterface @Allocation this)
      AllocationV1.allocation_withdrawImpl = allocation_v1_withdrawImpl (toInterface @Allocation this)
      AllocationV1.allocation_cancelImpl = allocation_v1_cancelImpl (toInterface @Allocation this)

-- Allocation usage
-------------------

allocationAmount : Party -> AllocationSpecification -> Decimal
allocationAmount sender allocation = sum (map (._2) outputs)
  where
    senderLegs = filter (\tl -> tl.sender.owner == sender) $ allocation.transferLegs
    outputs = map (\tl -> (tl.receiver, tl.amount)) senderLegs

allocationToTwoStepTransfer : Party -> [TransferLeg] -> Party -> Time -> SettlementInfo -> TwoStepTransfer
allocationToTwoStepTransfer sender transferLegs admin expiresAt settlement =
  TwoStepTransfer with
    dso = admin
    sender
    outputs = map (\tl -> (tl.receiver.owner, tl.amount)) filteredLegs
    provider = settlement.executor
    transferBefore = expiresAt
    transferBeforeDeadline = "allocation.expiresAt"
    allowFeaturing = True
    lockContext = Text.implode
      -- We don't show more context to avoid bloating the response here.
      ["allocation for settlement ", settlement.settlementRef.id]
  where
    filteredLegs = filter (\tl -> tl.sender.owner == sender) transferLegs

transferAmuletAllocation : AmuletAllocationTransferAuthorization -> [ContractId Holding] -> Update Allocation_ExecuteTransferResult
transferAmuletAllocation aata holdingCids = do
  let twoStepTransfer = allocationToTwoStepTransfer aata.transferLeg.sender.owner [aata.transferLeg] aata.admin aata.expiresAt aata.settlement
  (senderHoldingCids, receiverHoldingCids, meta) <-
    executeTwoStepTransfer twoStepTransfer holdingCids aata.extraArgs
  pure Allocation_ExecuteTransferResult
    with
      senderHoldingCids
      receiverHoldingCids
      meta

unlockAmuletAllocation : AmuletAllocation -> ExtraArgs -> Update [ContractId Holding]
unlockAmuletAllocation amuletAllocation extraArgs = do
  case amuletAllocation.lockedAmulet of
    None -> return []
    Some la -> do
      let twoStepTransfer = allocationToTwoStepTransfer amuletAllocation.sender amuletAllocation.allocation.transferLegs amuletAllocation.admin amuletAllocation.expiresAt amuletAllocation.allocation.settlement
      abortTwoStepTransfer twoStepTransfer la extraArgs

template AmuletAllocationTransferAuthorization
  with
    settlement : SettlementInfo
    transferLeg : TransferLeg
    extraArgs : ExtraArgs
    expiresAt : Time
    authorizer : Party
    admin : Party
  where
    signatory admin, authorizer, settlement.executor     

    interface instance AllocationTransferAuthorization for AmuletAllocationTransferAuthorization where
      view = AllocationTransferAuthorizationView with 
        settlement
        transferLeg
        authorizer = basicAccount authorizer

      allocationTransferAuthorization_transferImpl _self AllocationTransferAuthorization_Transfer{..} = do
        -- Check this is called on the sender side.
        transferLeg.sender === basicAccount authorizer
        case receiverAuth of
          Some authCid -> do
            -- validate the extra auth
            extraAuth <- fetch (fromInterfaceContractId @AmuletAllocationTransferAuthorization authCid)
            extraAuth === this with
              authorizer = transferLeg.receiver.owner
            exercise (fromInterfaceContractId @AmuletAllocationTransferAuthorization authCid) 
              AmuletAllocationTransferAuthorization_TransferWithExtraAuth with
                extraController = authorizer
                ..
          None -> do
            transferAmuletAllocation this holdingCids

    choice AmuletAllocationTransferAuthorization_TransferWithExtraAuth : Allocation_ExecuteTransferResult
      with
        holdingCids : [ContractId Holding]
        extraController : Party
      controller extraController :: settlement.executor :: fromSome (settlement.controllerOverride) -- should never be None if this is called.
      do
        transferAmuletAllocation this holdingCids