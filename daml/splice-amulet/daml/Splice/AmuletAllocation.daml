-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Splice.AmuletAllocation (
  AmuletAllocation(..),
  allocationAmount,
  allocationToTwoStepTransfer,
) where

import DA.Assert((===), (=/=))
import DA.Text as Text
import DA.TextMap qualified as TextMap
import DA.List ((\\), dedupSort)
import DA.Optional(fromSome)

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV2
import Splice.Api.Token.AllocationV1 qualified as AllocationV1
import Splice.Api.Token.AllocationV2
import Splice.Api.Token.UtilsV2

import Splice.Amulet
import Splice.Amulet.TwoStepTransfer


-- | Amulet allocated in locked form to a trade.
template AmuletAllocation
  with
    lockedAmulet : ContractId LockedAmulet -- ^ Locked amulet that holds the funds for the allocation
    allocation : AllocationSpecification
    sender : Party
    admin : Party
    expiresAt : Time
  where
    signatory admin, sender
    observer allocation.settlement.executor

    ensure 
      all 
        (\(_,tl) -> (
            -- Sender needs to appear as sender or receiver of each leg.
            sender `elem` [tl.sender, tl.receiver]) 
            -- Only one admin Id allowed.
            && tl.instrumentId.admin == admin) 
        (TextMap.toList allocation.transferLegs)

    interface instance Allocation for AmuletAllocation where
      view = AllocationView with
        allocation
        holdingCids = [toInterfaceContractId lockedAmulet]
        meta = emptyMetadata
        senders = [sender]
        requiredReceiverAuth = (defaultAllocationControllers allocation) \\ (sender::allocationControllers allocation)
        expiresAt = Some expiresAt

      allocation_executeTransferImpl self Allocation_ExecuteTransfer{..} = case extraAuth of
        [] ->  transferAmuletAllocation this extraArgs
        ea -> collectAuthAndSettle (fromInterfaceContractId self) extraArgs ea []

      allocation_withdrawImpl _self Allocation_Withdraw{..} = do
        senderHoldingCids <- unlockAmuletAllocation this extraArgs
        pure Allocation_WithdrawResult
          with
            senderHoldingCids
            meta = emptyMetadata

      allocation_cancelImpl _self Allocation_Cancel{..} = do
        senderHoldingCids <- unlockAmuletAllocation this extraArgs
        pure Allocation_CancelResult
          with
            senderHoldingCids
            meta = emptyMetadata

      allocation_executeAuthorizeIncomingImpl _self Allocation_AuthorizeIncoming{..} = do
        cid <- create AmuletAllocationTransferAuthorization with 
          allocation
          receiver = sender
          admin
        return $ toInterfaceContractId cid

    interface instance AllocationV1.Allocation for AmuletAllocation where
      view = allocation_view_v2_to_v1 (view (toInterface @Allocation this))

      AllocationV1.allocation_executeTransferImpl = allocation_v1_executeTransferImpl (toInterface @Allocation this)
      AllocationV1.allocation_withdrawImpl = allocation_v1_withdrawImpl (toInterface @Allocation this)
      AllocationV1.allocation_cancelImpl = allocation_v1_cancelImpl (toInterface @Allocation this)

    choice AmuletAllocation_InternalSettleWithExtraAuth : Allocation_ExecuteTransferResult
      with
        extraArgs : ExtraArgs
        extraControllers : [Party]
      controller extraControllers ++ allocationControllers allocation
      do transferAmuletAllocation this extraArgs 



allocationReceivers : AllocationSpecification -> [Party]
allocationReceivers AllocationSpecification{..} =
  dedupSort $ map ((.receiver) . snd) (TextMap.toList transferLegs)

-- Allocation usage
-------------------

allocationAmount : Party -> AllocationSpecification -> Decimal
allocationAmount sender allocation = sum (map (._2) outputs)
  where
    senderLegs = filter (\tl -> tl.sender == sender) $ map snd (TextMap.toList allocation.transferLegs)
    outputs = map (\tl -> (tl.receiver, tl.amount)) senderLegs

allocationToTwoStepTransfer : Party -> Party -> Time -> AllocationSpecification -> TwoStepTransfer
allocationToTwoStepTransfer sender admin expiresAt allocation =
  TwoStepTransfer with
    dso = admin
    sender = sender
    outputs
    provider = allocation.settlement.executor
    transferBefore = expiresAt
    transferBeforeDeadline = "allocation.expiresAt"
    allowFeaturing = True
    lockContext = Text.implode
      -- We don't show more context to avoid bloating the response here.
      ["allocation for settlement ", allocation.settlement.settlementRef.id]
  where
    senderLegs = filter (\tl -> tl.sender == sender) $ map snd (TextMap.toList allocation.transferLegs)
    outputs = map (\tl -> (tl.receiver, tl.amount)) senderLegs


collectAuthAndSettle : ContractId AmuletAllocation -> ExtraArgs -> [ContractId AllocationTransferAuthorization] -> [Party] -> Update Allocation_ExecuteTransferResult
collectAuthAndSettle allocationCid extraArgs extraAuth extraControllers = do
  case extraAuth of
    eaCid::eas -> exercise (fromInterfaceContractId @AmuletAllocationTransferAuthorization eaCid) AmuletAllocationTransferAuthorization_AuthorizeTransfer with
      extraAuth = eas
      extraControllers
      ..
    [] -> exercise allocationCid AmuletAllocation_InternalSettleWithExtraAuth with
      extraArgs
      extraControllers

transferAmuletAllocation : AmuletAllocation -> ExtraArgs -> Update Allocation_ExecuteTransferResult
transferAmuletAllocation amuletAllocation extraArgs = do
  let twoStepTransfer = allocationToTwoStepTransfer amuletAllocation.sender amuletAllocation.admin amuletAllocation.expiresAt amuletAllocation.allocation
  (senderHoldingCids, receiverHoldingCids, meta) <-
    executeTwoStepTransfer twoStepTransfer amuletAllocation.lockedAmulet extraArgs
  pure Allocation_ExecuteTransferResult
    with
      senderHoldingCids
      receiverHoldingCids
      meta

unlockAmuletAllocation : AmuletAllocation -> ExtraArgs -> Update [ContractId Holding]
unlockAmuletAllocation amuletAllocation extraArgs = do
  let twoStepTransfer = allocationToTwoStepTransfer amuletAllocation.sender amuletAllocation.admin amuletAllocation.expiresAt amuletAllocation.allocation
  abortTwoStepTransfer twoStepTransfer amuletAllocation.lockedAmulet extraArgs

template AmuletAllocationTransferAuthorization
  with
    allocation : AllocationSpecification
    receiver : Party
    admin : Party
  where
    signatory admin, receiver, allocation.settlement.executor     

    interface instance AllocationTransferAuthorization for AmuletAllocationTransferAuthorization where
      view = AllocationTransferAuthorizationView with 
        allocation
        receiver
        admin

    choice AmuletAllocationTransferAuthorization_AuthorizeTransfer : Allocation_ExecuteTransferResult
      with
        allocationCid : ContractId AmuletAllocation 
        extraArgs : ExtraArgs
        extraAuth : [ContractId AllocationTransferAuthorization]
        extraControllers : [Party]
      controller extraControllers ++ allocation.settlement.executor :: fromSome (allocation.settlement.controllerOverride) -- should never be None if this is called.
      do
        -- Validate that the receiver is only a receiver on a matching settlement
        amuletAllocation <- fetch allocationCid
        let allocation' = amuletAllocation.allocation
        allocation === allocation'
        admin === amuletAllocation.admin
        receiver =/= amuletAllocation.sender
        let receivers = allocationReceivers allocation
        assertMsg ("Receiver " <> show receiver <> " not found in receivers " <> show receivers)
          (receiver `elem` receivers)
        -- Transfer with added authority.
        collectAuthAndSettle allocationCid extraArgs extraAuth (receiver::extraControllers)

