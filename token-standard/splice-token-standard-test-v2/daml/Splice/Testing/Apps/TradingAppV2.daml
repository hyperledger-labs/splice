-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | An example of how to build an OTC trading app for multi-leg standard token trades.
--
-- Used as part of the testing infrastructure to test the DvP workflows based on the token standard.
module Splice.Testing.Apps.TradingAppV2 where

import DA.Foldable qualified as F
import DA.Optional (fromSomeNote)
import DA.Set qualified as Set
import DA.TextMap as TextMap
import DA.Map as Map

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.AllocationV2 as Api.Token.AllocationV2
import Splice.Api.Token.AllocationRequestV2
import DA.List (groupOn)
import DA.Foldable (mapA_)
import DA.List.Total (dedup)
import DA.Assert ((===))
import qualified DA.Traversable as Traversable

template OTCTradeAllocationRequest with
    otcTrade : OTCTrade
    otcTradeCid : ContractId OTCTrade
  where
    signatory otcTrade.venue
    observer otcTrade.venue, tradingParties (otcTrade.transferLegs)

    interface instance AllocationRequest for OTCTradeAllocationRequest where
      view = AllocationRequestView with
        settlement = SettlementInfo with
          executor = otcTrade.venue
          requestedAt = otcTrade.createdAt
          settlementRef = makeTradeRef otcTradeCid
          allocateBefore = otcTrade.prepareUntil
          settleBefore = otcTrade.settleBefore
          meta = emptyMetadata
          controllerOverride = Some [] -- We will settle using only executor authority.
        transferLegs = otcTrade.transferLegs
        meta = emptyMetadata

      allocationRequest_RejectImpl _self AllocationRequest_Reject{..} = do
        -- Note: this corresponds to signalling early that assets won't be allocated / that the trade is being rejected.
        require "Actor is a trader" (F.any (\leg -> actor == leg.sender || actor == leg.receiver) otcTrade.transferLegs)
        pure ChoiceExecutionMetadata with meta = emptyMetadata

      allocationRequest_WithdrawImpl _self _extraArgs =
        -- just archiving the trade is enough
        pure ChoiceExecutionMetadata with meta = emptyMetadata

template OTCTrade with
    venue : Party
    transferLegs : TextMap Api.Token.AllocationV2.TransferLeg
    createdAt : Time
    prepareUntil : Time
    settleBefore : Time
  where
    signatory venue
    observer venue, tradingParties transferLegs

    nonconsuming choice OTCTrade_RequestAllocations : [ContractId OTCTradeAllocationRequest]
      with
      controller venue
      do
        now <- getTime
        require "Preparation time has not passed" (now < prepareUntil)
        require "Preparation time before settlement time" (prepareUntil < settleBefore)
        let 
          legsByAdmin =
            map TextMap.fromList $
            groupOn (\(_, tl) -> tl.instrumentId.admin) $
            TextMap.toList transferLegs
        mapA (\transferLegs -> create (OTCTradeAllocationRequest (this with transferLegs) self)) legsByAdmin

    choice OTCTrade_Settle : Map Party (Map Party Allocation_ExecuteTransferResult)
      with
        allocationsWithContext : Map Party (Map Party (ContractId Allocation, ExtraArgs))
        -- ^ Allocations sorted by admin and sender.
        allocationRequests : [ContractId OTCTradeAllocationRequest]
      controller venue
      do
        -- Could be safer by validating the requests match the trade, but venue is the only authorizer
        -- so we can assume the checks happened off-ledger. 
        mapA_ archive allocationRequests
        -- check timing constraints
        now <- getTime
        require "Settlement deadline has not passed" (now < settleBefore)
        -- validate and execute transferLegs
        let settlementInfo = SettlementInfo with
              executor = venue
              requestedAt = createdAt
              settlementRef = makeTradeRef self
              allocateBefore = prepareUntil
              settleBefore
              meta = emptyMetadata
              controllerOverride = Some []
        let expectedAllocations = expectedTradeAllocations settlementInfo transferLegs
        let outerMergedMaps = zipMaps allocationsWithContext expectedAllocations
        exercises <- forMapWithKey outerMergedMaps \admin (optAdminAllocsWithContext,  optExpectedAdminAllocs) -> do
          let adminAllocsWithContext = fromSomeNote ("Allocations are missing for admin " <> show admin) optAdminAllocsWithContext
          let expectedAdminAllocs = fromSomeNote ("Allocation with context provided for unexpected admin " <> show admin) optExpectedAdminAllocs
          let innerMergedMaps = zipMaps adminAllocsWithContext expectedAdminAllocs
          forMapWithKey innerMergedMaps \trader (optAllocWithContext,  optExpectedAlloc) -> do
            let (allocCid, extraArgs) = fromSomeNote ("Allocation is missing for admin " <> show admin <> " and trader " <> show trader) optAllocWithContext
            let expectedAlloc = fromSomeNote ("Allocation with context provided for unexpected admin " <> show admin) optExpectedAlloc
            -- fetch and validate the allocation instruction
            instr <- fetch @Allocation allocCid
            let instrView = view @Allocation instr
            case matchAllocationWithMeta expectedAlloc instrView.allocation of
              Right () -> return ()
              Left mismatch -> abort
                ("Submitted allocation does not match expected allocation." <> "\nMismatch: " <> mismatch)

            -- Fetch extra auths
            let requiredReceiverAuth = (view instr).requiredReceiverAuth
            extraAuth <- forA requiredReceiverAuth
              (\receiver -> do
                debug ("authorizing incoming for " <> show admin <> ", " <> show trader <> ", " <> show receiver)
                (recAllocCid, recExtraArgs) <- case Map.lookup receiver innerMergedMaps of
                  Some (optReceiverAllocWithContext, _) -> 
                    return $ fromSomeNote ("Allocation is missing for admin " <> show admin <> " and trader " <> show receiver) optReceiverAllocWithContext
                  None -> abort ("Extra auth needed for receiver that is not present in any transfer legs: " <> show receiver)
                exercise recAllocCid Allocation_AuthorizeIncoming with extraArgs = recExtraArgs
              )
            -- on first pass don't settle yet as we may still need the extra auth.
            return $ (allocCid, Allocation_ExecuteTransfer with extraArgs; extraAuth)
        -- Exercise on second pass
        Traversable.mapA (Traversable.mapA (uncurry exercise)) exercises

    -- NOTE: this choice is an approximation to what a real app would do.
    -- As it stands, the venue can't cancel allocations that come right after
    -- the first cancellation.  A better approach would be to leave a marker
    -- contract in place until the `settleBefore` time, so that the venue
    -- retains the ability to cancel the allocations that are created.
    choice OTCTrade_Cancel : [Allocation_CancelResult]
      with
        allocationsWithContext : [(ContractId Allocation, ExtraArgs)]
        allocationRequests : [ContractId OTCTradeAllocationRequest]
      controller venue
      do
        mapA_ (\arCid -> do
            ar <- fetch arCid
            -- validate the allocation request matches this trade
            ar.otcTradeCid ===  self
            signatory ar === [venue]
            archive arCid
          )
          allocationRequests
        mapA (\(allocCid, extraArgs) -> do
            alloc <- fetch allocCid
            -- validate the allocation request matches this trade
            (view alloc).allocation.settlement.settlementRef === makeTradeRef self
            (view alloc).allocation.settlement.executor === venue
            exercise allocCid (Allocation_Cancel extraArgs)
          )
          allocationsWithContext            

expectedTradeAllocations
  : SettlementInfo -> TextMap Api.Token.AllocationV2.TransferLeg
  -> Map Party (Map Party AllocationSpecification)
expectedTradeAllocations settlementInfo transferLegs = Map.fromList allocsByAdminAndTrader
  where 
    legsByAdmin =
      map (\tls@((_, tl)::_) -> (tl.instrumentId.admin, TextMap.fromList tls)) $
      groupOn (\(_, tl) -> tl.instrumentId.admin) $
      TextMap.toList transferLegs
    tradersForLegs tls = dedup $ concatMap (\(_, tl) -> [tl.sender, tl.receiver]) (TextMap.toList tls)
    legsForTrader tls trader = 
      TextMap.fromList $ 
      Prelude.filter (\(_, tl) -> tl.sender == trader || tl.receiver == trader) $
      TextMap.toList tls
    allocForTraderAndLegs trader tls = AllocationSpecification with
      settlement = settlementInfo
      transferLegs = legsForTrader tls trader
    allocsByTrader tls = map 
      (\trader -> (trader, allocForTraderAndLegs trader $ legsForTrader tls trader))
      (tradersForLegs tls)
    allocsByAdminAndTrader = map 
      (\(admin, tls) -> (admin, Map.fromList (allocsByTrader tls)))
      legsByAdmin
     


tradingParties : TextMap Api.Token.AllocationV2.TransferLeg -> Set.Set Party
tradingParties = F.foldl (\acc t -> Set.insert t.sender (Set.insert t.receiver acc)) Set.empty

-- | Check whether a required condition is true. If it's not, abort the
-- transaction with a message saying that the requirement was not met.
require : CanAssert m => Text -> Bool -> m ()
require msg invariant =
  assertMsg ("The requirement '" <> msg <> "' was not met.") invariant

makeTradeRef : ContractId OTCTrade -> Api.Token.AllocationV2.Reference
makeTradeRef tradeCid = Api.Token.AllocationV2.Reference with
  id = "OTCTradeProposal" -- set to the name of the template to simplify debugging
  cid = Some (coerceContractId tradeCid)


-- Additional text map utilities
--------------------------------

zipMaps : (Ord k) => Map k a -> Map k b -> Map k (Optional a, Optional b)
zipMaps m1 m2 =
  Map.merge
    (\_ v1 -> Some (Some v1, None))
    (\_ v2 -> Some (None, Some v2))
    (\_ v1 v2 -> Some (Some v1, Some v2))
    m1
    m2

forMapWithKey : (Ord k) => Applicative f => Map k a -> (k -> a -> f b) -> f (Map k b)
forMapWithKey m f =
    Map.fromList <$> mapA f' (Map.toList m)
  where
    f' (k, v) = (k,) <$> f k v


