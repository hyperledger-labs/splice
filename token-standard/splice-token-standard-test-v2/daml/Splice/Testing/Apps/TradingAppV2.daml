-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | An example of how to build an OTC trading app for multi-leg standard token trades.
--
-- Used as part of the testing infrastructure to test the DvP workflows based on the token standard.
module Splice.Testing.Apps.TradingAppV2 where

import DA.Optional (catOptionals, optionalToList)
import DA.Set qualified as Set
import DA.Map qualified as Map

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.AllocationV2 as Api.Token.AllocationV2
import Splice.Api.Token.AllocationRequestV2
import Splice.Api.Token.HoldingV2 (Account, Holding, InstrumentId)
import DA.List (dedupSort, groupOn)
import DA.Foldable (mapA_)
import DA.Assert ((===))
import DA.Time
import DA.Date

maxTime : Time
maxTime = time (date 9999 Dec 31) 23 59 59

template OTCTradeAllocationRequest with
    venue : Party
    otcTradeCid : ContractId OTCTrade
    authorizer : Account
    transferLegs : [TransferLeg]
    createdAt : Time
    settleAt : Time
    settlementDeadline : Optional Time

  where
    signatory venue
    observer accountParties authorizer

    interface instance AllocationRequest for OTCTradeAllocationRequest where
      view = AllocationRequestView with
        settlement = SettlementInfo with
          executor = venue
          requestedAt = createdAt
          settlementRef = makeTradeRef otcTradeCid
          settleAt = settleAt
          meta = emptyMetadata
          controllerOverride = Some [] -- We will settle using only executor authority.
          settlementDeadline = settlementDeadline
        transferLegs = transferLegs
        meta = emptyMetadata

      allocationRequest_RejectImpl _self AllocationRequest_Reject{..} = do
        -- Note: this corresponds to signalling early that assets won't be allocated / that the trade is being rejected.
        require "Actor is is the needed authorizer" 
          (actor == authorizer.owner || Some actor == authorizer.provider)
        pure ChoiceExecutionMetadata with meta = emptyMetadata

      allocationRequest_WithdrawImpl _self _extraArgs =
        -- just archiving the trade is enough
        pure ChoiceExecutionMetadata with meta = emptyMetadata

template OTCTrade with
    venue : Party
    transferLegs : [TransferLeg]
    createdAt : Time
    settleAt : Time
    settlementDeadline : Optional Time
  where
    signatory venue
    observer venue, tradingParties transferLegs

    nonconsuming choice OTCTrade_RequestAllocations : [ContractId OTCTradeAllocationRequest]
      with
        fee : TransferLeg
        -- ^ An extra transfer leg to represent the fee for the executor.
      controller venue
      do
        let
          allLegs = fee::transferLegs
          allTraders = dedupSort $ concatMap (\tl -> [tl.sender, tl.receiver]) transferLegs
          legsByAdmin =
            groupOn (.instrumentId.admin) $
            allLegs
        concat <$> 
          forA legsByAdmin (\legs -> do
            catOptionals <$> forA allTraders (\trader -> do
              let trader_legs = filter (\leg -> trader == leg.sender || trader == leg.receiver) legs
              if null trader_legs
                then return None
                else do
                  Some <$> create OTCTradeAllocationRequest with 
                    otcTradeCid = self
                    authorizer = trader
                    transferLegs = trader_legs
                    ..
              )
          )

    -- Nonconsuming to avoid disclusures inside.
    nonconsuming choice OTCTrade_Settle : (Map.Map (InstrumentId, Account) [ContractId Holding], [Metadata])
      with
        fee : TransferLeg
        holdingCids : Map.Map (InstrumentId, Account) [ContractId Holding]
        allocationsWithContext : Map.Map (Party, Account) (ContractId Allocation, ExtraArgs)
        -- ^ Allocations sorted by admin and sender.
        allocationRequests : [ContractId OTCTradeAllocationRequest]
      controller venue
      do
        archive self
        -- Could be safer by validating the requests match the trade, but venue is the only authorizer
        -- so we can assume the checks happened off-ledger. 
        mapA_ archive allocationRequests
        -- 
        -- We use the default implementation.
        settleAllocations
          (transferLegs ++ [fee])
          holdingCids
          allocationsWithContext

    -- NOTE: this choice is an approximation to what a real app would do.
    -- As it stands, the venue can't cancel allocations that come right after
    -- the first cancellation.  A better approach would be to leave a marker
    -- contract in place until the `settleBefore` time, so that the venue
    -- retains the ability to cancel the allocations that are created.
    choice OTCTrade_Cancel : [Allocation_CancelResult]
      with
        allocationsWithContext : [(ContractId Allocation, ExtraArgs)]
        allocationRequests : [ContractId OTCTradeAllocationRequest]
      controller venue
      do
        mapA_ (\arCid -> do
            ar <- fetch arCid
            -- validate the allocation request matches this trade
            ar.otcTradeCid ===  self
            signatory ar === [venue]
            archive arCid
          )
          allocationRequests
        mapA (\(allocCid, extraArgs) -> do
            alloc <- fetch allocCid
            -- validate the allocation request matches this trade
            (view alloc).allocation.settlement.settlementRef === makeTradeRef self
            (view alloc).allocation.settlement.executor === venue
            exercise allocCid (Allocation_Cancel extraArgs)
          )
          allocationsWithContext            

accountParties : Account -> [Party]
accountParties account = account.owner::optionalToList account.provider

transferLegParties : TransferLeg -> [Party]
transferLegParties tl = accountParties tl.sender ++ accountParties tl.receiver

tradingParties : [Api.Token.AllocationV2.TransferLeg] -> Set.Set Party
tradingParties tls = Set.fromList $ concatMap transferLegParties tls

-- | Check whether a required condition is true. If it's not, abort the
-- transaction with a message saying that the requirement was not met.
require : CanAssert m => Text -> Bool -> m ()
require msg invariant =
  assertMsg ("The requirement '" <> msg <> "' was not met.") invariant

makeTradeRef : ContractId OTCTrade -> Api.Token.AllocationV2.Reference
makeTradeRef tradeCid = Api.Token.AllocationV2.Reference with
  id = "OTCTradeProposal" -- set to the name of the template to simplify debugging
  cid = Some (coerceContractId tradeCid)



