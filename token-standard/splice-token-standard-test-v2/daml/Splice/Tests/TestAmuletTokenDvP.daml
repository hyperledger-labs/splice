-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Daml script tests showing that the token standard can be used to execute
-- DvP settlements of Amulet tokens; and how to do so.
--
-- See this test and the 'Splice.Testing.TradingApp' module for an example of
-- how to integrate with the allocation APIs of the token standard to execute
-- DvP settlements.
--
-- Note also that the delivery part of a DvP settelement can be both another
-- token implementing the standard, as well as the creation of on-ledger state
-- specific to your registry; e.g., a license contract.
module Splice.Tests.TestAmuletTokenDvP where

import Daml.Script

import DA.Action (unless)
import DA.Assert
import DA.Foldable (forA_, foldMap)
import DA.Optional (isSome)
import DA.TextMap as TextMap hiding (filter)
import DA.Map as Map hiding (filter)
import DA.Time
import DA.Traversable qualified as Traversable

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV2
import Splice.Api.Token.AllocationV2 as Api.Token.AllocationV2
import Splice.Api.Token.AllocationRequestV2
import Splice.Api.Token.AllocationInstructionV2

import Splice.Amulet
import Splice.Amulet.TokenApiUtils (burnedMetaKey)

import Splice.Testing.Apps.TradingAppV2 hiding (require)
import Splice.Testing.UtilsV2
import Splice.Testing.Registries.AmuletRegistryV2 qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApiV2 qualified as RegistryApi
import Splice.Testing.TokenStandard.WalletClientV2 qualified as WalletClient

data AllocatedOTCTrade = AllocatedOTCTrade
  with
    alice : Party
    bob : Party
    provider : Party
    providerBeneficiary1 : Party
    providerBeneficiary2 : Party
    providerBeneficiaries : [(Party, Decimal)]
    registry : AmuletRegistry.AmuletRegistry
    otcTradeCid : ContractId OTCTrade
    otcTrade : OTCTrade
    requestCid : ContractId OTCTradeAllocationRequest
    amuletId : InstrumentId
  deriving (Show, Eq)

setupOtcTrade : Script AllocatedOTCTrade
setupOtcTrade  = do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig
  let amuletId = registry.instrumentId

  alice <- allocatePartyExact "alice"
  bob <- allocatePartyExact "bob"

  -- featured app provider
  provider <-  allocatePartyExact "trading-app-provider-party"
  providerBeneficiary1 <- allocatePartyExact "trading-app-investor1"
  providerBeneficiary2 <- allocatePartyExact "trading-app-investor2"
  let providerBeneficiaries =
        [ (provider, 0.8)
        , (providerBeneficiary1, 0.1)
        , (providerBeneficiary2, 0.1)
        ]
  AmuletRegistry.featureApp registry provider

  -- get some funds for alice and bob
  AmuletRegistry.tapLockedAndUnlockedFunds registry alice 1000.0
  AmuletRegistry.tapLockedAndUnlockedFunds registry bob 1000.0

  let mkTransfer sender receiver amount = Api.Token.AllocationV2.TransferLeg with
        sender
        receiver
        amount
        instrumentId = amuletId
        meta = emptyMetadata
  -- Note: here we use Amulet as the single asset, as that is all we have available in this repository.
  -- Given that we are using only the DvP interface, that should though be a fine stand-in for
  -- a DvP across two assets from different registries.
  let aliceLeg = mkTransfer alice bob 100.0
  let bobLeg = mkTransfer bob alice 20.0

  -- venue creates a trade
  now <- getTime
  let settleBefore = now `addRelTime` hours 2
  otcTradeCid <- submit provider $ createCmd OTCTrade with
    venue = provider
    transferLegs = TextMap.fromList [("leg0", aliceLeg), ("leg1", bobLeg)]
    prepareUntil = now `addRelTime` hours 1
    settleBefore
    createdAt = now

  -- venue requests settlement
  [requestCid] <- submit provider $
    exerciseCmd otcTradeCid OTCTrade_RequestAllocations with

  Some otcTrade <- queryContractId provider otcTradeCid

  -- Alice sees the allocation request in her wallet
  [aliceAlloc] <- WalletClient.listRequestedAllocationsForAdmin alice amuletId.admin
  let 
    [(_, tl)] = filter (\(_, tl) -> tl.sender == alice) (TextMap.toList aliceAlloc.transferLegs)
  tl.amount === 100.0

  -- alice accepts allocation request directly via her wallet
  inputHoldingCids <- WalletClient.listHoldingCids alice amuletId
  holdings <- WalletClient.listHoldings alice amuletId
  debug holdings

  now <- getTime

  -- test that using the wrong admin party fails
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = alice
    allocation = aliceAlloc
    inputHoldingCids = map coerceInterfaceContractId inputHoldingCids
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = alice
  submitWithDisclosuresMustFail' alice enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  -- alice accepts allocation request directly via her wallet
  -- TODO(DACH-NY/canton-network-node#18633): test here and for all steps that the expected ledger time bounds are present on the submissions
  debug inputHoldingCids
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = aliceAlloc
    inputHoldingCids = map coerceInterfaceContractId inputHoldingCids
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = alice
  result <- submitWithDisclosures' alice enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  -- check metadata
  expectBurn result.meta

  -- check lock context
  [(_, lockedHolding)] <- WalletClient.listLockedHoldings alice registry.instrumentId
  let expectedLock = Some $ Lock with
        expiresAt = Some settleBefore
        expiresAfter = None
        holders = [registry.dso]
        context = Some "allocation for settlement OTCTradeProposal"
  lockedHolding.lock === expectedLock

  -- Bob sees the allocation request in his wallet as well
  [bobAlloc] <- WalletClient.listRequestedAllocationsForAdmin bob amuletId.admin
  let 
    [(_, tl)] = filter (\(_, tl) -> tl.sender == bob) (TextMap.toList aliceAlloc.transferLegs)
  tl.amount === 20.0

  -- bob accepts allocation request directly via her wallet
  inputHoldingCids <- WalletClient.listHoldingCids bob amuletId
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = bobAlloc
    inputHoldingCids = map coerceInterfaceContractId inputHoldingCids
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = bob
  submitWithDisclosures' bob enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  factoryView <- submitWithDisclosures' alice enrichedChoice.disclosures $ exerciseCmd enrichedChoice.factoryCid AllocationFactory_PublicFetch
    with
      expectedAdmin = registry.dso
      actor = alice
  factoryView === AllocationFactoryView registry.dso emptyMetadata
  pure AllocatedOTCTrade with
    alice
    bob
    provider
    providerBeneficiary1
    providerBeneficiary2
    registry
    providerBeneficiaries
    otcTradeCid
    otcTrade
    requestCid
    amuletId


-- | Test that a DvP settlement of an OTC trade works when using Amulet via the token standard.
testDvP : Script ()
testDvP = script do
  AllocatedOTCTrade{..} <- setupOtcTrade

  -- assume the time given to prepare has passed
  passTime (hours 1)

  -- provider runs automation that completes the settlement
  let otcTradeRef = makeTradeRef otcTradeCid
  allocationsMap <- appBackendListAllocations provider otcTradeRef
  let [(_, amuletAllocations)] = Map.toList allocationsMap
  Map.size amuletAllocations === 2

  let beneficiaryMetadata = AmuletRegistry.beneficiariesToMetadata providerBeneficiaries
  richAllocationsWithContext <- Traversable.forA amuletAllocations $ \(allocCid, _) -> do
    context <- RegistryApi.getAllocation_TransferContext registry allocCid beneficiaryMetadata
    let extraArgs = ExtraArgs with
          context = context.choiceContext
          meta = beneficiaryMetadata
    pure (context.disclosures, (allocCid, extraArgs))
  let disclosures = foldMap fst richAllocationsWithContext

  results <- submitWithDisclosures' provider disclosures $ exerciseCmd otcTradeCid OTCTrade_Settle with
    allocationsWithContext = Map.fromList [(amuletId.admin, fmap snd richAllocationsWithContext)]
    allocationRequests = [requestCid]

  -- check metadata
  forA_ results $ \result -> forA_ result $ \innerResult -> expectBurn innerResult.meta

  -- check that the expected transfers happened
  WalletClient.checkHoldingWithAmountExists alice amuletId 20.0
  WalletClient.checkHoldingWithAmountExists bob amuletId 100.0

  WalletClient.checkBalanceApprox alice amuletId 919.0 -- around 1 $ of fees paid
  WalletClient.checkBalanceApprox bob amuletId 1079.8  -- around 0.2 $ of fees paid

  -- check that the provider got their featured app reward coupons
  coupons <- map snd <$> query @AppRewardCoupon provider
  let couponWithAmount : Decimal -> AppRewardCoupon -> Bool
      couponWithAmount amount coupon =
        coupon.featured && coupon.beneficiary == Some provider && coupon.amount == amount
      checkCouponExists amount =
        unless (any (couponWithAmount amount) coupons) $
          fail $ "Expected coupon with amount " <> show amount <> " not found: " <> show coupons

      extraAppReward = 2.0 -- 1 $ (at 0.5 Amulet per $)
      providerWeight = 0.8
      aliceAmount = providerWeight * (extraAppReward + 1.06) -- 1% fees plus the 0.06 Amulet create fee  (at 0.5 Amulet per $)
      bobAmount = providerWeight * (extraAppReward + 0.26) -- 0.5% fees (at 0.5 Amulet per $)

      checkNumCouponsFor b expectedNumCoupons = do
        let numCoupons = length $ filter (\c -> c.beneficiary == Some b) coupons
        unless (numCoupons == expectedNumCoupons ) $
          fail $ "Expected " <> show expectedNumCoupons <> " coupons for " <> show b <> ", but got " <> show numCoupons

  debug aliceAmount
  checkCouponExists aliceAmount
  checkCouponExists bobAmount

  checkNumCouponsFor providerBeneficiary1 2
  checkNumCouponsFor providerBeneficiary2 2

  -- TODO (DACH-NY/canton-network-node#17541):early abortion of settlement, unwinding of expired settlements, etc.
  pure ()

testDvPCancel : Script ()
testDvPCancel = script do
  AllocatedOTCTrade{..} <- setupOtcTrade
  let otcTradeRef = makeTradeRef otcTradeCid
  allocationsMap <- appBackendListAllocations provider otcTradeRef
  let [(_, amuletAllocations)] = Map.toList allocationsMap
  Map.size amuletAllocations === 2

  [(_, aliceLockedHolding)] <- WalletClient.listLockedHoldings alice registry.instrumentId
  [(bobLockedHoldingCid, _)] <- WalletClient.listLockedHoldings bob registry.instrumentId

  passTime (days 1)

  -- expire the amulet for bob to test both cases where the amulet still exists for alice and where it doesn't for bob
  AmuletRegistry.expireLockAsOwner registry bobLockedHoldingCid

  richAllocationsWithContext <- Traversable.forA amuletAllocations $ \(allocCid, _) -> do
    context <- RegistryApi.getAllocation_CancelContext registry allocCid emptyMetadata
    let extraArgs = ExtraArgs with
          context = context.choiceContext
          meta = emptyMetadata
    pure (context.disclosures, (allocCid, extraArgs))
  let disclosures = foldMap fst richAllocationsWithContext

  _ <- submitWithDisclosures' provider disclosures $ exerciseCmd otcTradeCid OTCTrade_Cancel with
    allocationsWithContext = Map.values $ fmap snd richAllocationsWithContext
    allocationRequests = [requestCid]

  [] <- WalletClient.listLockedHoldings alice registry.instrumentId
  WalletClient.checkHoldingWithAmountExists alice amuletId aliceLockedHolding.amount

  [] <- queryInterface @Allocation alice
  [] <- queryInterface @Allocation bob

  pure ()

testDvPWithdraw : Script ()
testDvPWithdraw = script do
  AllocatedOTCTrade{..} <- setupOtcTrade
  [(aliceAllocationCid, _)] <- queryInterface @Allocation alice
  context <- RegistryApi.getAllocation_WithdrawContext registry aliceAllocationCid emptyMetadata

  [(_, aliceLockedHolding)] <- WalletClient.listLockedHoldings alice registry.instrumentId

  _ <- submitWithDisclosures' alice context.disclosures $ exerciseCmd aliceAllocationCid Allocation_Withdraw with
    extraArgs = ExtraArgs with
      context = context.choiceContext
      meta = emptyMetadata

  [] <- WalletClient.listLockedHoldings alice registry.instrumentId
  WalletClient.checkHoldingWithAmountExists alice amuletId aliceLockedHolding.amount

  [] <- queryInterface @Allocation alice

  passTime (days 1)

  [(bobLockedHoldingCid, _)] <- WalletClient.listLockedHoldings bob registry.instrumentId
  AmuletRegistry.expireLockAsOwner registry bobLockedHoldingCid

  pure ()


-- utilities
------------

-- | List all allocations matching a particular settlement reference, sorted by their admin and trader.
-- This function would be run on the trading app provider's backend as part of an automation loop.
appBackendListAllocations : Party -> Reference -> Script (Map Party (Map Party (ContractId Allocation, AllocationView)))
appBackendListAllocations p ref = do
  allocs <- queryInterface @Allocation p
  let matchingAllocs = do
        (cid, Some fundedAllocation) <- allocs
        guard (fundedAllocation.allocation.settlement.settlementRef == ref)
        let (_, tl)::_ = TextMap.toList fundedAllocation.allocation.transferLegs
            admin = tl.instrumentId.admin
            [sender] = fundedAllocation.senders
        return (admin, Map.fromList [(sender, (cid, fundedAllocation))])
  pure $ Map.fromListWithR Map.union matchingAllocs

expectBurn : Metadata -> Script ()
expectBurn meta =
  unless (isSome $ TextMap.lookup burnedMetaKey meta.values) $
    fail $ "Expected burned meta key to be present in " <> show meta
