-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Daml script tests showing that the token standard can be used to execute
-- DvP settlements of Amulet tokens; and how to do so.
--
-- See this test and the 'Splice.Testing.TradingApp' module for an example of
-- how to integrate with the allocation APIs of the token standard to execute
-- DvP settlements.
--
-- Note also that the delivery part of a DvP settelement can be both another
-- token implementing the standard, as well as the creation of on-ledger state
-- specific to your registry; e.g., a license contract.
module Splice.Tests.TestAmuletTokenDvP where

import Daml.Script

import DA.Action (unless)
import DA.Assert
import DA.Foldable (forA_, foldMap)
import DA.Optional (fromSome, isSome)
import DA.TextMap as TextMap hiding (filter)
import DA.Map as Map hiding (filter)
import DA.Time
import DA.Traversable qualified as Traversable

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV2
import Splice.Api.Token.AllocationV2 as Api.Token.AllocationV2
import Splice.Api.Token.AllocationInstructionV2

import Splice.Amulet
import Splice.Amulet.TokenApiUtils (burnedMetaKey)

import Splice.Testing.Apps.TradingAppV2 hiding (require)
import Splice.Testing.UtilsV2
import Splice.Testing.Registries.AmuletRegistryV2 qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApiV2 qualified as RegistryApi
import Splice.Testing.TokenStandard.WalletClientV2 qualified as WalletClient

data AllocatedOTCTrade = AllocatedOTCTrade
  with
    alice : Party
    bob : Party
    provider : Party
    providerBeneficiary1 : Party
    providerBeneficiary2 : Party
    providerBeneficiaries : [(Party, Decimal)]
    registry : AmuletRegistry.AmuletRegistry
    otcTradeCid : ContractId OTCTrade
    otcTrade : OTCTrade
    requestCids : [ContractId OTCTradeAllocationRequest]
    amuletId : InstrumentId
    feeLeg : TransferLeg
  deriving (Show, Eq)

setupOtcTrade : Script AllocatedOTCTrade
setupOtcTrade  = do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig
  let amuletId = registry.instrumentId

  alice <- allocatePartyExact "alice"
  bob <- allocatePartyExact "bob"

  -- featured app provider
  provider <-  allocatePartyExact "trading-app-provider-party"
  providerBeneficiary1 <- allocatePartyExact "trading-app-investor1"
  providerBeneficiary2 <- allocatePartyExact "trading-app-investor2"
  let providerBeneficiaries =
        [ (provider, 0.8)
        , (providerBeneficiary1, 0.1)
        , (providerBeneficiary2, 0.1)
        ]
  AmuletRegistry.featureApp registry provider

  -- get some funds for alice and bob
  AmuletRegistry.tapLockedAndUnlockedFunds registry alice 1000.0
  AmuletRegistry.tapLockedAndUnlockedFunds registry bob 1000.0

  let 
    mkTransfer id sender receiver amount = 
      Api.Token.AllocationV2.TransferLeg with
        transferLegId = id
        sender = basicAccount sender
        receiver = basicAccount receiver
        amount
        instrumentId = amuletId
        meta = emptyMetadata
  -- Note: here we use Amulet as the single asset, as that is all we have available in this repository.
  -- Given that we are using only the DvP interface, that should though be a fine stand-in for
  -- a DvP across two assets from different registries.
  let aliceLeg = mkTransfer "leg0_a" alice bob 50.0
      aliceLeg2 = mkTransfer "leg0_b" alice bob 50.0
  let bobLeg = mkTransfer "leg1_a" bob alice 10.0
      bobLeg2 = mkTransfer "leg1_b" bob alice 10.0
  let feeLeg = mkTransfer "fee" bob provider 1.0

  -- venue creates a trade
  now <- getTime
  let settleAt = now `addRelTime` hours 1
      deadline = now `addRelTime` hours 2
  otcTradeCid <- submit provider $ createCmd OTCTrade with
    venue = provider
    transferLegs = [aliceLeg, aliceLeg2, bobLeg, bobLeg2]
    settleAt
    createdAt = now
    settlementDeadline = Some deadline

  let
    settlement = SettlementInfo with
      executor = provider
      requestedAt = now
      settlementRef = makeTradeRef otcTradeCid
      settleAt = settleAt
      meta = emptyMetadata
      controllerOverride = Some [] -- We will settle using only executor authority.
      settlementDeadline = Some deadline

  -- venue requests settlement
  requestCids <- submit provider $
    exerciseCmd otcTradeCid OTCTrade_RequestAllocations with
      fee = feeLeg

  Some otcTrade <- queryContractId provider otcTradeCid

  -- Alice sees the allocation request in her wallet
  [aliceAlloc] <- WalletClient.listRequestedAllocationsForAdmin alice amuletId.admin
  aliceAlloc.transferLegs === [aliceLeg, aliceLeg2, bobLeg, bobLeg2]

  -- alice accepts allocation request directly via her wallet
  inputHoldingCids <- WalletClient.listHoldingCids alice amuletId
  now <- getTime

  -- test that using the wrong admin party fails
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = alice
    allocation = aliceAlloc
    inputHoldingCids = map coerceInterfaceContractId inputHoldingCids
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = alice
  submitWithDisclosuresMustFail' alice enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  -- alice accepts allocation request directly via her wallet
  -- TODO(DACH-NY/canton-network-node#18633): test here and for all steps that the expected ledger time bounds are present on the submissions
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = aliceAlloc
    inputHoldingCids = map coerceInterfaceContractId inputHoldingCids
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = alice
  result <- submitWithDisclosures' alice enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  -- check metadata
  expectBurn result.meta

  -- check lock context
  [(_, lockedHolding)] <- WalletClient.listLockedHoldings alice registry.instrumentId  
  let expectedLock = Lock with
        expiresAt = None
        expiresAfter = None
        holders = [registry.dso]
        context = Some "allocation for settlement OTCTradeProposal"
  ((fromSome lockedHolding.lock) with expiresAt = None) === expectedLock
  assertMsg "locks expire should be in the future" 
    (fromSome (fromSome lockedHolding.lock).expiresAt > now)

  -- Bob sees the allocation request in his wallet as well
  [bobAlloc] <- WalletClient.listRequestedAllocationsForAdmin bob amuletId.admin
  bobAlloc.transferLegs === [feeLeg, aliceLeg, aliceLeg2, bobLeg, bobLeg2]

  -- bob accepts allocation request directly via his wallet
  inputHoldingCids <- WalletClient.listHoldingCids bob amuletId
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = bobAlloc
    inputHoldingCids = map coerceInterfaceContractId inputHoldingCids
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = bob
  submitWithDisclosures' bob enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  -- Lastly, the venue creates an allocation for the fee leg.
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = AllocationSpecification with transferLegs = [feeLeg]; settlement
    inputHoldingCids = []
    requestedAt = now
    extraArgs = emptyExtraArgs
    creator = provider
  submitWithDisclosures' provider enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg
    
  pure AllocatedOTCTrade with
    alice
    bob
    provider
    providerBeneficiary1
    providerBeneficiary2
    registry
    providerBeneficiaries
    otcTradeCid
    otcTrade
    requestCids
    amuletId
    feeLeg

-- | Test that a DvP settlement of an OTC trade works when using Amulet via the token standard.
testDvP : Script ()
testDvP = script do
  AllocatedOTCTrade{..} <- setupOtcTrade

  -- assume the time given to prepare has passed
  passTime (hours 1)

  -- provider runs automation that completes the settlement
  let otcTradeRef = makeTradeRef otcTradeCid
  allocationsMap <- appBackendListAllocations provider otcTradeRef
  Map.size allocationsMap === 3

  let beneficiaryMetadata = AmuletRegistry.beneficiariesToMetadata providerBeneficiaries
  richAllocationsWithContext <- Traversable.forA allocationsMap $ \(allocCid, alloc) -> do
    context <- RegistryApi.getAllocation_TransferContext registry allocCid beneficiaryMetadata
    let extraArgs = ExtraArgs with
          context = context.choiceContext
          meta = beneficiaryMetadata
    pure (allocCid, extraArgs, context.disclosures, alloc.holdingCids)
  let 
    disclosures = foldMap ((._3) . snd) (Map.toList richAllocationsWithContext)
    holdingCids = Map.fromList $ 
      concatMap 
        (\((_, authorizer), (_, _, _, holdings_map)) -> 
          map (\(instrId, hs') -> ((instrId, authorizer), hs')) (Map.toList holdings_map)) 
        (Map.toList richAllocationsWithContext)

    allocationsWithContext = Map.fromList $ map (\(k, (cid, ea, _, _)) -> (k, (cid, ea))) (Map.toList richAllocationsWithContext)

  results <- submitWithDisclosures' provider disclosures $ exerciseCmd otcTradeCid OTCTrade_Settle with
    fee = feeLeg
    holdingCids
    allocationsWithContext
    allocationRequests = requestCids

  -- check metadata
  forA_ results._2 $ \meta -> expectBurn meta

  -- check that the expected transfers happened
  -- Alice should have two holdings of 10 as no merging happens after she receives.
  WalletClient.checkHoldingWithAmountExists alice amuletId 10.0
  -- Bob should have a single holding of 100 as his two 50.0s get merged in the fee leg.
  WalletClient.checkHoldingWithAmountExists bob amuletId 101.05

  -- 1.25 burned:
  -- Allocation: 0.13 = 2 * 0.03/0.5 create fee + 0.005/0.5 lock fee
  -- Transfer 1: 1.12 = 3 * 0.03/0.5 create fee + 100 * 0.01 transfer fee
  WalletClient.checkBalanceApprox alice amuletId 918.69 -- around 1 $ of fees paid
  -- 0.58 burned:
  -- Allocation: 0.13 = 2 * 0.03/0.5 create fee + 0.005/0.5 lock fee
  -- Transfer 1: 0.32 = 3 * 0.03/0.5 create fee + 20 * 0.01 transfer fee
  -- Transfer 2: 0.13 = 2 * 0.03/0.5 create fee + 1 * 0.01 transfer fee
  WalletClient.checkBalanceApprox bob amuletId 1078.36  

  -- check that the provider got their featured app reward coupons
  coupons <- map snd <$> query @AppRewardCoupon provider
  let couponWithAmount : Decimal -> AppRewardCoupon -> Bool
      couponWithAmount amount coupon =
        coupon.featured && coupon.beneficiary == Some provider && coupon.amount == amount
      checkCouponExists amount =
        unless (any (couponWithAmount amount) coupons) $
          fail $ "Expected coupon with amount " <> show amount <> " not found: " <> show coupons

      extraAppReward = 2.0 -- 1 $ (at 0.5 Amulet per $)
      providerWeight = 0.8
      aliceAmount = providerWeight * (extraAppReward + 1.12) -- 1% fees plus the 2 * 0.06 Amulet create fee  (at 0.5 Amulet per $)
      bobAmount = providerWeight * (extraAppReward + 0.32) -- 0.5% fees (at 0.5 Amulet per $)

      checkNumCouponsFor b expectedNumCoupons = do
        let numCoupons = length $ filter (\c -> c.beneficiary == Some b) coupons
        unless (numCoupons == expectedNumCoupons ) $
          fail $ "Expected " <> show expectedNumCoupons <> " coupons for " <> show b <> ", but got " <> show numCoupons

  checkCouponExists aliceAmount
  checkCouponExists bobAmount

  -- Thanks to the fee leg, there are now three coupons each.
  checkNumCouponsFor providerBeneficiary1 3
  checkNumCouponsFor providerBeneficiary2 3

  -- TODO (DACH-NY/canton-network-node#17541):early abortion of settlement, unwinding of expired settlements, etc.
  pure ()

testDvPCancel : Script ()
testDvPCancel = script do
  AllocatedOTCTrade{..} <- setupOtcTrade
  let otcTradeRef = makeTradeRef otcTradeCid
  allocationsMap <- appBackendListAllocations provider otcTradeRef
  Map.size allocationsMap === 3

  [(_, aliceLockedHolding)] <- WalletClient.listLockedHoldings alice registry.instrumentId
  [(bobLockedHoldingCid, _)] <- WalletClient.listLockedHoldings bob registry.instrumentId

  passTime (days 1)

  -- expire the amulet for bob to test both cases where the amulet still exists for alice and where it doesn't for bob
  AmuletRegistry.expireLockAsOwner registry bobLockedHoldingCid

  richAllocationsWithContext <- Traversable.forA allocationsMap $ \(allocCid, _) -> do
    context <- RegistryApi.getAllocation_CancelContext registry allocCid emptyMetadata
    let extraArgs = ExtraArgs with
          context = context.choiceContext
          meta = emptyMetadata
    pure (context.disclosures, (allocCid, extraArgs))
  let disclosures = foldMap fst richAllocationsWithContext
  _ <- submitWithDisclosures' provider disclosures $ exerciseCmd otcTradeCid OTCTrade_Cancel with
    allocationsWithContext = Map.values $ fmap snd richAllocationsWithContext
    allocationRequests = requestCids
  [] <- WalletClient.listLockedHoldings alice registry.instrumentId
  WalletClient.checkHoldingWithAmountExists alice amuletId aliceLockedHolding.amount

  [] <- queryInterface @Allocation alice
  [] <- queryInterface @Allocation bob

  pure ()

testDvPWithdraw : Script ()
testDvPWithdraw = script do
  AllocatedOTCTrade{..} <- setupOtcTrade
  [(aliceAllocationCid, _)] <- queryInterface @Allocation alice
  context <- RegistryApi.getAllocation_WithdrawContext registry aliceAllocationCid emptyMetadata

  [(_, aliceLockedHolding)] <- WalletClient.listLockedHoldings alice registry.instrumentId

  _ <- submitWithDisclosures' alice context.disclosures $ exerciseCmd aliceAllocationCid Allocation_Withdraw with
    extraArgs = ExtraArgs with
      context = context.choiceContext
      meta = emptyMetadata

  [] <- WalletClient.listLockedHoldings alice registry.instrumentId
  WalletClient.checkHoldingWithAmountExists alice amuletId aliceLockedHolding.amount

  [] <- queryInterface @Allocation alice

  passTime (days 1)

  [(bobLockedHoldingCid, _)] <- WalletClient.listLockedHoldings bob registry.instrumentId
  AmuletRegistry.expireLockAsOwner registry bobLockedHoldingCid

  pure ()


-- utilities
------------

-- | List all allocations matching a particular settlement reference, sorted by their admin and trader.
-- This function would be run on the trading app provider's backend as part of an automation loop.
appBackendListAllocations : Party -> Reference -> Script (Map(Party, Account) (ContractId Allocation, AllocationView))
appBackendListAllocations p ref = do
  allocs <- queryInterface @Allocation p
  let matchingAllocs = do
        (cid, Some fundedAllocation) <- allocs
        guard (fundedAllocation.allocation.settlement.settlementRef == ref)
        let tl::_ = fundedAllocation.allocation.transferLegs
            admin = tl.instrumentId.admin
            sender = fundedAllocation.sender
        return ((admin, sender), (cid, fundedAllocation))
  pure $ Map.fromList matchingAllocs

expectBurn : Metadata -> Script ()
expectBurn meta =
  unless (isSome $ TextMap.lookup burnedMetaKey meta.values) $
    fail $ "Expected burned meta key to be present in " <> show meta
