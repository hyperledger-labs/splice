-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Daml script functions for initializing and using an amulet registry via the
-- token standard and the amulet specific functions.
module Splice.Testing.Registries.AmuletRegistry
  (
    -- * Setup
    AmuletRegistryConfig(..)
  , defaultAmuletRegistryConfig

  , AmuletRegistry(..)
  , initialize

    -- * Amulet registry specific functions
  , tapFaucet
  , featureApp
  , createTransferPreapproval

  ) where

import DA.Date
import qualified DA.Map as Map
import DA.List.Total
import DA.Time

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.AllocationInstructionV1
import Splice.Api.Token.TransferInstructionV1

import Splice.Amulet
import Splice.Amulet.TokenApiUtils
import Splice.AmuletAllocation
import Splice.AmuletRules
import Splice.ExternalPartyAmuletRules
import Splice.Round

import Splice.Testing.Utils
import Splice.Testing.Registries.AmuletRegistry.Parameters
import Splice.Testing.TokenStandard.RegistryApi

import Daml.Script

-- Registry representation
--------------------------

-- | A reference to a mock amulet registry.
-- Use it via the the token standard functions provided by the "Splice.Testing.RegistryApi" module
-- and type-class; or via the amulet specific functions exported from this module.
data AmuletRegistry = AmuletRegistry with
    dso : Party
    instrumentId : InstrumentId
  deriving (Eq, Ord, Show)

instance RegistryApi AmuletRegistry where
  getTransferFactory = registryApi_getTransferFactory
  getAllocationFactory = registryApi_getAllocationFactory
  getAllocationTransferContext = registryApi_getAllocationTransferContext


-- Registry initialization
--------------------------
data AmuletRegistryConfig = AmuletRegistryConfig
  with
    initialAmuletPrice : Decimal
    demoTime : Time
  deriving (Eq, Show)

-- | Recommended default configuration for setting up the mock amulet registry.
defaultAmuletRegistryConfig : AmuletRegistryConfig
defaultAmuletRegistryConfig = AmuletRegistryConfig with
  initialAmuletPrice = 0.5 -- a non-zero price that still makes it easy to reason about fees and amounts
  demoTime = time (DA.Date.date 2022 Jan 1) 0 0 0

-- | Initialize the mock amulet registry.
initialize : AmuletRegistryConfig -> Script AmuletRegistry
initialize config = do
  -- use a time that is easy to reason about in script outputs
  setTime config.demoTime

  dso <- allocateParty "dso-party"
  let registry = AmuletRegistry with
        dso
        instrumentId = amuletInstrumentId dso

  _ <- submit dso $ createCmd AmuletRules with
    configSchedule = defaultAmuletConfigSchedule
    isDevNet = True
    ..

  _ <- submit dso $ createCmd ExternalPartyAmuletRules with dso

  (amuletRulesCid, _) <- getAmuletRules registry
  submit registry.dso $ exerciseCmd amuletRulesCid AmuletRules_Bootstrap_Rounds with
      amuletPrice = config.initialAmuletPrice
      round0Duration = minutes 10 -- no special setup for normal tests

  -- return the off-ledger reference to the registry for later script steps
  return registry

-- | Tap the faucet on DevNet to get a specified amount of Amulet.
tapFaucet : AmuletRegistry -> Party -> Decimal -> Script (ContractId Holding)
tapFaucet registry user amount = do
  (openRound, _) <- getLatestOpenRound registry
  (amuletRulesCid, _) <- getAmuletRules registry
  amuletRulesD <- queryDisclosure' @AmuletRules registry.dso amuletRulesCid
  openMiningRoundD <- queryDisclosure' @OpenMiningRound registry.dso openRound
  let disclosures = amuletRulesD <> openMiningRoundD
  result <- submitWithDisclosures' user disclosures $ exerciseCmd amuletRulesCid AmuletRules_DevNet_Tap with
    receiver = user
    amount
    openRound
  return $ toInterfaceContractId result.amuletSum.amulet


-- | Simulate that a validator operator created a transfer pre-approval for a party
-- for the purpose of that party being able to receive Amulet from any other party.
createTransferPreapproval : AmuletRegistry -> Party -> Party -> Time -> Script (ContractId TransferPreapproval)
createTransferPreapproval registry receiver provider expiresAt = do
  now <- getTime
  submitMulti [receiver, provider, registry.dso] [] $ createCmd TransferPreapproval with
      receiver
      provider
      dso = registry.dso
      validFrom = now
      lastRenewedAt = now
      expiresAt

-- | Mark a particular registry provider part as featured.
featureApp : AmuletRegistry -> Party -> Script (ContractId FeaturedAppRight)
featureApp registry provider = do
  (amuletRulesCid, _) <- getAmuletRules registry
  result <- submitMulti [provider] [registry.dso] $ exerciseCmd amuletRulesCid AmuletRules_DevNet_FeatureApp with
    provider
  return result.featuredAppRightCid


-- Token standard registry implementation
-----------------------------------------

registryApi_getTransferFactory
  : AmuletRegistry -> TransferFactory_Transfer
  -> Script (EnrichedFactoryChoice TransferFactory TransferFactory_Transfer)
registryApi_getTransferFactory registry arg = do
  (extAmuletRulesCid, extAmuletRulesD) <- getExtAmuletRulesWithDisclosures registry
  transferC <- getAmuletRulesTransferContext registry
  (preapproval, preapprovalC) <- getPreapprovalWithContext registry arg.transfer.receiver
  featuredAppRightC <- getFeaturedAppRightContext registry preapproval.provider
  let fullContext = withExtraDisclosures extAmuletRulesD
        (transferC <> preapprovalC <> featuredAppRightC)
  pure EnrichedFactoryChoice with
    factoryCid = toInterfaceContractId @TransferFactory extAmuletRulesCid
    arg = arg with extraArgs = arg.extraArgs with context = fullContext.choiceContext
    disclosures = fullContext.disclosures

registryApi_getAllocationFactory
  : AmuletRegistry -> AllocationFactory_Allocate
  -> Script (EnrichedFactoryChoice AllocationFactory AllocationFactory_Allocate)
registryApi_getAllocationFactory registry arg = do
  (extAmuletRulesCid, extAmuletRulesD) <- getExtAmuletRulesWithDisclosures registry
  transferC <- getAmuletRulesTransferContext registry
  let fullContext = withExtraDisclosures extAmuletRulesD transferC
  pure EnrichedFactoryChoice with
    factoryCid = toInterfaceContractId @AllocationFactory extAmuletRulesCid
    arg = arg with extraArgs = arg.extraArgs with context = fullContext.choiceContext
    disclosures = fullContext.disclosures

-- TODO(#18152): consider whether to pass in metadata when fetching this choice context, for extensibility
registryApi_getAllocationTransferContext
  : AmuletRegistry -> ContractId Allocation -> Script OpenApiChoiceContext
registryApi_getAllocationTransferContext registry allocCid = do
  transferC <- getAmuletRulesTransferContext registry
  Some amuletAlloc <- queryContractId @AmuletAllocation registry.dso (coerceContractId allocCid)
  featuredAppRightC <- getFeaturedAppRightContext registry amuletAlloc.allocation.settlement.executor
  -- need to disclose the amulet contract, as the executor has no visibility into it
  lockedAmuletD <- queryDisclosure' @LockedAmulet registry.dso amuletAlloc.lockedAmulet
  pure $ withExtraDisclosures lockedAmuletD (transferC <> featuredAppRightC)


-- Internal functions
---------------------

mkAmuletContext : Map.Map Text AnyValue -> ChoiceContext
mkAmuletContext values = ChoiceContext with
  values

getAmuletRules : AmuletRegistry -> Script (ContractId AmuletRules, AmuletRules)
getAmuletRules registry = do
  rules <- query @AmuletRules registry.dso
  case rules of
    [rule] -> return rule
    [] -> failNotInitialized "No AmuletRules found"
    _ -> fail "Multiple AmuletRules found: are you initializing the Amulet registry multiple times?"

-- Primarily used by submitters to decide against which round they should try to transact.
getLatestOpenRound : AmuletRegistry -> Script (ContractId OpenMiningRound, OpenMiningRound)
getLatestOpenRound registry = do
  now <- getTime
  -- only get open rounds
  rounds <- queryFilter @OpenMiningRound registry.dso (\round -> now >= round.opensAt)
  case maximumOn (\(_, r) -> r.round) rounds of
    None -> failNotInitialized "No open open mining round found"
    Some r-> pure r

failNotInitialized : Text -> Script a
failNotInitialized problem =
  fail $ problem <> ": have you called 'initialize' to initialize the Amulet registry?"

getExtAmuletRulesWithDisclosures : AmuletRegistry -> Script (ContractId ExternalPartyAmuletRules, Disclosures')
getExtAmuletRulesWithDisclosures registry = do
  [(extAmuletRulesCid, _)] <- query @ExternalPartyAmuletRules registry.dso
  extAmuletRulesD <- queryDisclosure' registry.dso extAmuletRulesCid
  pure (extAmuletRulesCid, extAmuletRulesD)

getAmuletRulesContext : AmuletRegistry -> Script OpenApiChoiceContext
getAmuletRulesContext registry = do
  (amuletRulesCid, _) <- getAmuletRules registry
  amuletRulesD <- queryDisclosure' @AmuletRules registry.dso amuletRulesCid
  pure OpenApiChoiceContext with
    choiceContext = mkAmuletContext $ Map.fromList
        [(amuletRulesContextKey, AV_ContractId $ coerceContractId amuletRulesCid)]
    disclosures = amuletRulesD

getOpenRoundContext : AmuletRegistry -> Script OpenApiChoiceContext
getOpenRoundContext registry = do
  (openRoundCid, _) <- getLatestOpenRound registry
  openRoundD <- queryDisclosure' @OpenMiningRound registry.dso openRoundCid
  pure OpenApiChoiceContext with
    choiceContext = mkAmuletContext $ Map.fromList
        [(openRoundContextKey, AV_ContractId $ coerceContractId openRoundCid)]
    disclosures = openRoundD

-- | Context required to call an amulet rules transfer choice.
getAmuletRulesTransferContext : AmuletRegistry -> Script OpenApiChoiceContext
getAmuletRulesTransferContext registry = do
  rulesC <- getAmuletRulesContext registry
  roundC <- getOpenRoundContext registry
  pure $ rulesC <> roundC

getPreapprovalWithContext : AmuletRegistry -> Party -> Script (TransferPreapproval, OpenApiChoiceContext)
getPreapprovalWithContext registry receiver = do
  [(preapprovalCid, preapproval)] <- queryFilter @TransferPreapproval receiver (\preapproval -> preapproval.receiver == receiver)
  preapprovalD <- queryDisclosure' @TransferPreapproval registry.dso preapprovalCid
  pure
    ( preapproval
    , OpenApiChoiceContext with
      disclosures = preapprovalD
      choiceContext = mkAmuletContext $
        Map.fromList [(transferPreapprovalContextKey, AV_ContractId (coerceContractId preapprovalCid))]
    )

getFeaturedAppRightContext : AmuletRegistry -> Party -> Script OpenApiChoiceContext
getFeaturedAppRightContext registry provider = do
  appRights <- queryFilter @FeaturedAppRight registry.dso (\appRight -> appRight.provider == provider)
  case appRights of
    [] -> pure OpenApiChoiceContext with disclosures = mempty; choiceContext = mkAmuletContext Map.empty
    (rightCid, _) :: _ -> do
      rightDisc <- queryDisclosure' @FeaturedAppRight registry.dso rightCid
      pure OpenApiChoiceContext with
        disclosures = rightDisc
        choiceContext = mkAmuletContext $
          Map.fromList [ (featuredAppRightContextKey, AV_ContractId (coerceContractId rightCid)) ]
