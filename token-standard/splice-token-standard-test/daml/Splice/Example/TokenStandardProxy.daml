-- | Example module for proxying token standard choices so that featured app markers
-- are created for the provider of the wallet app that the user is using.
--
-- The main reason for the proxy is because external signing does not yet
-- support multiple command submission in a single transaction. However, the proxy contract
-- also has the benefit of ensuring that the right kind of beneficiaries are used by the user.
--
-- Note: when using this module, please change the module name and put it into its own .dar file.
--
-- See Splice.Tests.TestAmuletTokenTransfer for an example of using the proxy.
module Splice.Example.TokenStandardProxy where

import DA.Foldable (forA_)

import Splice.Api.Token.TransferInstructionV1
import Splice.Api.Token.AllocationV1
import Splice.Api.Token.AllocationInstructionV1
import Splice.Api.FeaturedAppRightV1

-- | Generic argument to the proxy choices.
data ProxyArg arg = ProxyArg with
    user : Party -- ^ The user that is interacting with the token standard workflow.
    cid : ContractId ()  -- ^ Contract on which the user is exercising the choice.
    choiceArg : arg -- ^ The argument to the choice that the user is exercising.
    featuredAppRightCid : ContractId FeaturedAppRight -- ^ The featured app right contract of the provider.
  deriving (Show, Eq)

-- | Generic result of the proxy choices.
data ProxyResult r = ProxyResult with
    markerResult : FeaturedAppRight_CreateActivityMarkerResult
    choiceResult : r

-- | A proxy to attribute the activity of a user interacting with token standard workflows
-- to the provider of the wallet app that the user is using.
--
-- The intended usage is for the wallet app provider to
-- 1. create a `TokenStandardProxy` contract with the `provider` set to the app provider's party
-- 2. setup their wallet frontend such that users call the proxy's choices instead of the original token standard choices.
--
-- Note that the weights are specified on the proxy contract, so that they are under the providers
-- control. If they were specified on the choices, then the user could in principle change them,
-- and grant themselves a higher reward than intended.
template TokenStandardProxy with
    provider : Party -- ^ The app provider whose featured app right should be triggered
    providerWeight : Decimal -- ^ Reward weight for the provider
    userWeight : Decimal -- ^ Reward weight for the user, set to 0.0 if the user should not receive a reward
    extraBeneficiaries : [AppRewardBeneficiary] -- ^ Extra beneficiaries to list
    optAllowList : Optional [Party] -- ^ An optional allow list of parties that can use the proxy
  where
    ensure validProxy this
    signatory provider

    -- all choices with a single user actor are proxied below

    nonconsuming choice TokenStandardProxy_TransferFactory_Transfer
      : ProxyResult TransferInstructionResult
      with
        proxyArg : ProxyArg TransferFactory_Transfer
      controller proxyArg.user
      do
        exerciseProxyChoice @TransferFactory this proxyArg $ \_ -> do
          pure proxyArg.choiceArg.transfer.sender

    nonconsuming choice TokenStandardProxy_TransferInstruction_Accept
      : ProxyResult TransferInstructionResult
      with
        proxyArg : ProxyArg TransferInstruction_Accept
      controller proxyArg.user
      do
        exerciseProxyChoice @TransferInstruction this proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice TokenStandardProxy_TransferInstruction_Reject
      : ProxyResult TransferInstructionResult
      with
        proxyArg : ProxyArg TransferInstruction_Reject
      controller proxyArg.user
      do
        exerciseProxyChoice @TransferInstruction this proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice TokenStandardProxy_TransferInstruction_Withdraw
      : ProxyResult TransferInstructionResult
      with
        proxyArg : ProxyArg TransferInstruction_Withdraw
      controller proxyArg.user
      do
        exerciseProxyChoice @TransferInstruction this proxyArg $ \cid -> do
          instr <- fetch cid
          pure (view instr).transfer.receiver

    nonconsuming choice TokenStandardProxy_AllocationFactory_Allocate
      : ProxyResult AllocationInstructionResult
      with
        proxyArg : ProxyArg AllocationFactory_Allocate
      controller proxyArg.user
      do
        exerciseProxyChoice @AllocationFactory this proxyArg $ \_ -> do
          pure proxyArg.choiceArg.allocation.transferLeg.sender

    nonconsuming choice TokenStandardProxy_Allocation_Withdraw
      : ProxyResult Allocation_WithdrawResult
      with
        proxyArg : ProxyArg Allocation_Withdraw
      controller proxyArg.user
      do
        exerciseProxyChoice @Allocation this proxyArg $ \cid -> do
          allocation <- fetch cid
          pure (view allocation).allocation.transferLeg.sender


-- Utilities
-------------

-- | Shared code to execute the proxied choice.
exerciseProxyChoice
  : forall t ch r. HasExercise t ch r =>
  TokenStandardProxy -> ProxyArg ch -> (ContractId t -> Update Party) -> Update (ProxyResult r)
exerciseProxyChoice proxy proxyArg getExpectedUser = do
  let ProxyArg{..} = proxyArg
  let cid' : ContractId t = coerceContractId cid
  appRight <- fetch featuredAppRightCid
  expectedUser <- getExpectedUser cid'
  -- validate the user and provider
  require "User matches expected user" (expectedUser == user)
  forA_ proxy.optAllowList $ \allowList ->
    require "User is in the allow list" (user `elem` allowList)
  require "App right matches expected provider" ((view appRight).provider == proxy.provider)
  -- create marker
  markerResult <- exercise featuredAppRightCid FeaturedAppRight_CreateActivityMarker with
    beneficiaries = proxyBeneficiaries proxy user
  -- exercise proxied choice
  choiceResult <- exercise cid' choiceArg
  pure ProxyResult with markerResult; choiceResult

-- | Get the list of beneficiaries for the featured app marker.
proxyBeneficiaries : TokenStandardProxy -> Party -> [AppRewardBeneficiary]
proxyBeneficiaries TokenStandardProxy{..} user =
  filter (\b -> b.weight > 0.0) [AppRewardBeneficiary provider providerWeight, AppRewardBeneficiary user userWeight]
    ++ extraBeneficiaries

validProxy : TokenStandardProxy -> Bool
validProxy TokenStandardProxy{..} =
    validWeight userWeight &&
    validWeight providerWeight  &&
    all (\b -> validWeight b.weight) extraBeneficiaries
  where
    validWeight : Decimal -> Bool
    validWeight w = 0.0 <= w && w <= 1.0


-- | Check whether a required condition is true. If it's not, abort the
-- transaction with a message saying that the requirement was not met.
require : CanAssert m => Text -> Bool -> m ()
require msg invariant =
  assertMsg ("The requirement '" <> msg <> "' was not met.") invariant
