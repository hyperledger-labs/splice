-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | Example script for testing the DvP support of the splice token DvP standard.
module Splice.Scripts.TestAmuletTokenDvP where

import Daml.Script

import DA.Assert
import DA.Foldable (foldMap)
import DA.List (sortOn)
import DA.Optional (mapOptional)
import DA.Time

import Splice.Util
import Splice.Scripts.Util
import Splice.Amulet

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1 as Api.Token.HoldingV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationInstructionV1

import Splice.Scripts.TokenTestUtils

import TradingApp hiding (require)
import Util.Disclosure

testDvP : Script ()
testDvP = script do
  DefaultAppWithUsers{..} <- setupDefaultAppWithUsers

  -- get some funds for alice and bob
  tap app alice 1000.0
  tap app bob 1000.0

  -- setup trading venue
  agreementCid <- submitMulti [alice.primaryParty, provider1.primaryParty] [] $ createCmd TradingAgreement with
    venue = provider1.primaryParty
    user = alice.primaryParty

  let amuletId = InstrumentId app.dso "Amulet"
  let mkTransfer sender receiver amount = Api.Token.AllocationV1.TransferLeg with
        sender
        receiver
        amount
        instrumentId = amuletId
        meta = emptyMetadata
  let aliceLeg = mkTransfer alice.primaryParty bob.primaryParty 100.0
  -- TODO (#17541):use another asset instead of Amulet for Bob, once we have a second asset available in our example
  let bobLeg = mkTransfer bob.primaryParty alice.primaryParty 20.0

  -- alice proposes trade with bob
  proposalCid <- submit alice.primaryParty $ exerciseCmd agreementCid TradingAgreement_ProposeTrade with
    transferLegs = [aliceLeg, bobLeg]

  -- bob accepts
  proposalCid <- submit bob.primaryParty $ exerciseCmd proposalCid OTCTradeProposal_Accept with
    approver = bob.primaryParty

  -- provider initiates settlement
  now <- getTime

  -- query OpenAPI endpoint to get the instruction factory of the asset to allocate
  settlementCid <- submit provider1.primaryParty $
    exerciseCmd proposalCid OTCTradeProposal_InitiateSettlement with
      prepareUntil = now `addRelTime` hours 1
      settleBefore = now `addRelTime` hours 2


  -- Alice sees the allocation request in her wallet
  [aliceAlloc] <- getRequestedAllocations alice.primaryParty
  aliceAlloc.transferLeg.amount === 100.0

  -- build choice context that would be provided over the off-ledger API
  (factoryCid, extraArgs, disclosures) <- getAmuletAllocationFactory_AllocateContext app alice

  amulets <- queryFilter @Amulet alice.primaryParty (\amulet -> amulet.owner == alice.primaryParty)
  -- alice tries to accept with wrong admin party which fails
  submitWithDisclosuresMustFail' alice.primaryParty disclosures $ exerciseCmd factoryCid AllocationFactory_Allocate with
    expectedAdmin = alice.primaryParty
    allocation = aliceAlloc
    inputHoldings = map (toInterfaceContractId . fst) amulets
    extraArgs

  -- alice accepts allocation request directly via her wallet
  submitWithDisclosures' alice.primaryParty disclosures $ exerciseCmd factoryCid AllocationFactory_Allocate with
    expectedAdmin = app.dso
    allocation = aliceAlloc
    inputHoldings = map (toInterfaceContractId . fst) amulets
    extraArgs

  -- Bob sees the allocation request in his wallet as well
  [bobAlloc] <- getRequestedAllocations bob.primaryParty
  bobAlloc.transferLeg.amount === 20.0

  -- build choice context that would be provided over the off-ledger API
  (factoryCid, extraArgs, disclosures) <- getAmuletAllocationFactory_AllocateContext app alice

  amulets <- queryFilter @Amulet bob.primaryParty (\amulet -> amulet.owner == bob.primaryParty)

  -- bob accepts allocation request using their wallet
  submitWithDisclosures' bob.primaryParty disclosures $ exerciseCmd factoryCid AllocationFactory_Allocate with
    expectedAdmin = app.dso
    allocation = bobAlloc
    inputHoldings = map (toInterfaceContractId . fst) amulets
    extraArgs

  -- assume the time given to prepare has passed
  passTime (hours 1)

  -- provider completes settlement
  allocations0 <- queryInterface @Allocation provider1.primaryParty
  let allocations =
        sortOn (\(_, alloc) -> (alloc.transferLegId)) $
        mapOptional (\(x, y) -> (,) x <$> y) allocations0

  -- and... *drumroll*... settle!
  contexts <- forA allocations $ \(allocCid, _) ->
     getAmuletAllocation_ExecuteTransferContext app provider1 allocCid
  let disclosures = foldMap fst contexts
  submitWithDisclosures' provider1.primaryParty disclosures $ exerciseCmd settlementCid OTCTrade_Settle with
    allocationInstructions = map fst allocations
    extraArgss = map snd contexts

  -- TODO (#17541):early abortion of settlement, unwinding of expired settlements, etc.
  let ensureAmuletExists amount owner = do
        amulets <- queryFilter @Amulet owner (\amulet -> amulet.owner == owner)
        require ("Amulet of amount " <> show amount <> " exists")
          (any (\(_, amulet) -> amulet.amount.initialAmount == amount) amulets)

  -- check that they received the correct amount of Amulets
  ensureAmuletExists 20.0 alice.primaryParty
  ensureAmuletExists 100.0 bob.primaryParty

  pure ()

getRequestedAllocations : Party -> Script [AllocationView]
getRequestedAllocations p = do
  reqs <- queryInterface @AllocationRequest p
  trace reqs $ pure ()
  let allocs = do
        (_reqCid, Some req) <- reqs
        (tfId, tf) <- zip [0..length req.transferLegs] req.transferLegs
        guard (p == tf.sender)
        pure AllocationView with
          settlement = req.settlement
          transferLegId = tfId
          transferLeg = tf
  pure allocs
