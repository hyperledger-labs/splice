-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | This module defines the `Allocation` interface and supporting types.
--
-- Contracts implementing the `Allocation` interface represent a reservation of
-- assets to transfer them as part of an atomic on-ledger settlement requested
-- by an app.
module Splice.Api.Token.AllocationV2 where

import DA.List (dedup, dedupSort)
import DA.TextMap as TextMap

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV2 (Holding, InstrumentId, Account)
import qualified DA.Foldable as F
import DA.Assert ((===))
import DA.Optional (isSome, fromOptional, optionalToList)
import DA.Map as Map (insert, toList, lookup, fromList, Map)
import DA.Action (foldlA)

-- | A generic type to refer to data defined within an app.

-- The interpretation of such a reference is app specific, but SHOULD be unambiguous within the context of the app.
data Reference = Reference with
    id : Text
      -- ^ The key that identifies the data. Can be set to the empty string if the contract-id is provided and is sufficient.
    cid : Optional AnyContractId
      -- ^ Optional contract-id to use for referring to contracts.
      --
      -- This field is there for technical reasons, as contract-ids cannot be converted to text from within Daml,
      -- which is due to their full textual representation being only known after transactions have been prepared.
  deriving (Show, Eq)

-- | The minimal set of information about a settlement that an app would like to execute.
data SettlementInfo = SettlementInfo
  with
    executor : Party
      -- ^ The party that is responsible for executing the settlement.
    settlementRef : Reference
      -- ^ Reference to the settlement that app would like to execute.
    requestedAt : Time
      -- ^ When the settlement was requested. Provided for display and debugging purposes,
      -- but SHOULD be in the past.
    settleAt : Time
      -- ^ The earliest settlement time. Allocations should be made before this time. Settlement
      -- happens at any point after this time.
    meta : Metadata
      -- ^ Additional metadata about the settlement, used for extensibility.
    controllerOverride : Optional [Party]
      -- ^ Additional party signatures in addition to executor that need to authorize
      -- choices on the Allocation. Defaults to senders and receivers across all 
      -- transferLegs.
    settlementDeadline : Optional Time
      -- ^ The latest point at which settlement will occur. This allows registries
      -- to set appropriate locks and expiries.
  deriving (Show, Eq)

-- | A specification of a transfer of holdings between two parties for the
-- purpose of a settlement, which often requires the atomic execution of multiple legs.
data TransferLeg = TransferLeg with
    transferLegId : Text
      -- ^ an identifier for the transferLeg.
    sender : Account
      -- ^ The sender of the transfer.
    receiver : Account
      -- ^ The receiver of the transfer.
    amount : Decimal
      -- ^ The amount to transfer.
    instrumentId : InstrumentId
      -- ^ The instrument identifier.
    meta : Metadata
      -- ^ Additional metadata about the transfer leg, used for extensibility.
  deriving (Eq, Ord, Show)

-- | The specification of an allocation of assets to a specific leg of a settlement.
--
-- In contrast to an `AllocationView` this just specifies what should be allocated,
-- but not the holdings that are backing the allocation.
data AllocationSpecification = AllocationSpecification with
    settlement : SettlementInfo
      -- ^ The settlement for whose execution the assets are being allocated.
    transferLegs: [TransferLeg]
     -- ^ the transfers that this allocation satisfies
  deriving (Show, Eq)

-- | View of a funded allocation of assets to a specific leg of a settlement.
-- To be standards compliant, an allocation must have a non-zero number of
-- transfer legs, all with an instrumentId with the same adminId.
data AllocationView = AllocationView with
    allocation : AllocationSpecification
      -- ^ The settlement for whose execution the assets are being allocated.
    holdingCids : Map InstrumentId [ContractId Holding]
      -- ^ The holdings that are backing this allocation.
      --
      -- Provided so that that wallets can correlate the allocation with the
      -- holdings.
      --
      -- MAY be empty for registries that do not represent their holdings on-ledger.
    meta : Metadata
      -- ^ Additional metadata specific to the allocation, used for extensibility.
    sender : Account
      -- ^ The sender of this allocation
    expiresAt : Optional Time
    -- ^ A time at which this allocation expires. SHOULD be as close as the
    -- registry can make it to the settlementInfo's settlementDeadline.
  deriving (Show, Eq)

-- | View of a delegated authority from the signer to the executor to settle given transfer legs.
-- authorizers are always the signatories so not made available in the viewtype.
data AllocationTransferAuthorizationView = AllocationTransferAuthorizationView with
  settlement : SettlementInfo
  transferLeg : TransferLeg
  authorizer : Account
  -- ^ the settlement to which this authorization applies. 



-- Allocation
------------------------

-- | Convenience function to refer to the union of sender, receiver, and
-- executor of the settlement, which jointly control the execution of the
-- allocation.
defaultAllocationControllers : AllocationSpecification -> [Party]
defaultAllocationControllers AllocationSpecification{..} =
  dedup $ settlement.executor :: concatMap (\leg -> [leg.sender.owner, leg.receiver.owner]) transferLegs

-- | Convenience function read out the overridden allocation controllers.
allocationControllers : AllocationSpecification -> [Party]
allocationControllers alloc@AllocationSpecification{..} =
  optional
    (defaultAllocationControllers alloc)
    (\override -> dedup $ settlement.executor :: override)
    settlement.controllerOverride

-- | Convenience to get the allocation admin
allocationAdmin : AllocationSpecification -> Party
allocationAdmin AllocationSpecification{..} = admin
  where
    admins = dedupSort $ map (.instrumentId.admin) (transferLegs)
    admin = case admins of
      [a] -> a
      _ -> error "Allocations must involve instruments from exactly one admin"

-- | A contract representing an allocation of some amount of asset holdings to
-- a specific leg of a settlement.
interface Allocation where
  viewtype AllocationView

  allocation_executeTransferImpl : ContractId Allocation -> Allocation_ExecuteTransfer -> Update Allocation_ExecuteTransferResult
  allocation_cancelImpl : ContractId Allocation -> Allocation_Cancel -> Update Allocation_CancelResult
  allocation_withdrawImpl : ContractId Allocation -> Allocation_Withdraw -> Update Allocation_WithdrawResult
  allocation_getTransferAuthorizationsImpl : ContractId Allocation -> Allocation_GetTransferAuthorizations -> Update(TextMap (ContractId AllocationTransferAuthorization))

  choice Allocation_GetTransferAuthorizations : TextMap (ContractId AllocationTransferAuthorization)
  -- ^ Transfer the authority from this Allocation to AllocationTransferAuthorizations which
  -- can then be used in conjunctionw ith other AllocationTransferAuthorizations to execute
  -- transfers. The return type is a map from transfer leg Id to authorization. Registries
  -- may choose to omit authorizations that are not needed.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller allocationControllers (view this).allocation
    do allocation_getTransferAuthorizationsImpl this self arg

  choice Allocation_ExecuteTransfer : Allocation_ExecuteTransferResult
    -- ^ Execute the transfer of the allocated assets. Intended to be used to execute the settlement.
    -- This choice SHOULD succeed provided the `settlement.settleBefore` deadline has not yet passed.
    -- This function exists for backwards compatibility and is less general then going via the
    -- settlement flow enabled by Allocation_GetTransferAuthorizations. In particular, it is only
    -- guaranteed to work if none of the transfer legs require receiver authorization, and if the
    -- provided holdingCids cover all the transferLegs.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller allocationControllers (view this).allocation
    do allocation_executeTransferImpl this self arg

  choice Allocation_Cancel : Allocation_CancelResult
    -- ^ Cancel the allocation. Requires authorization from sender, receiver, and
    -- executor.
    --
    -- Typically this authorization is granted by sender and receiver to the
    -- executor as part of the contract coordinating the settlement, so that
    -- that the executor can release the allocated assets early in case the
    -- settlement is aborted or it has definitely failed.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller allocationControllers (view this).allocation
    do allocation_cancelImpl this self arg

  choice Allocation_Withdraw : Allocation_WithdrawResult
    -- ^ Withdraw the allocated assets. Used by the sender to withdraw the assets before settlement
    -- was completed. This SHOULD not fail settlement if the sender has still time to allocate the
    -- assets again; i.e., the `settlement.allocateBefore` deadline has not yet passed.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller (view this).sender.owner::(optionalToList (view this).sender.provider)
    do allocation_withdrawImpl this self arg

-- AllocationTransferAuthorization
----------------------------------

-- | A contract representing a delegated authority from the signatories to the executor to settle 
-- given transfer legs.
interface AllocationTransferAuthorization where
  viewtype AllocationTransferAuthorizationView

  allocationTransferAuthorization_transferImpl : ContractId AllocationTransferAuthorization -> AllocationTransferAuthorization_Transfer -> Update Allocation_ExecuteTransferResult

  choice AllocationTransferAuthorization_Transfer : Allocation_ExecuteTransferResult
  -- ^ Execute the transfer of the allocated assets. Intended to be used to execute the settlement.
  -- This choice SHOULD succeed provided the `settlement.settleBefore` deadline has not yet passed.
    with
      receiverAuth : Optional (ContractId AllocationTransferAuthorization)
        -- ^ A receiver authorization if needed
      holdingCids : [ContractId Holding]
        -- ^ The holdingCids to use for the settlement
      extraObservers : [Party]
        -- ^ Extra observers to optimize views
    observer extraObservers
    controller allocationControllers (AllocationSpecification (view this).settlement [(view this).transferLeg])
    do allocationTransferAuthorization_transferImpl this self arg

-- Result types
---------------

-- | The result of the `Allocation_ExecuteTransfer` choice.
data Allocation_ExecuteTransferResult = Allocation_ExecuteTransferResult
  with
    senderHoldingCids : [ContractId Holding]
      -- ^ The holdings that were created for the sender. Can be used to return
      -- "change" to the sender if required.
    receiverHoldingCids : [ContractId Holding]
      -- ^ The holdings that were created for the receiver.
    meta : Metadata
      -- ^ Additional metadata specific to the transfer instruction, used for extensibility.
  deriving (Show, Eq)

-- | The result of the `Allocation_Cancel` choice.
data Allocation_CancelResult = Allocation_CancelResult
  with
    senderHoldingCids : [ContractId Holding]
      -- ^ The holdings that were released back to the sender.
    meta : Metadata
      -- ^ Additional metadata specific to the allocation, used for extensibility.
  deriving (Show, Eq)

-- | The result of the `Allocation_Withdraw` choice.
data Allocation_WithdrawResult = Allocation_WithdrawResult
  with
    senderHoldingCids : [ContractId Holding]
      -- ^ The holdings that were released back to the sender.
    meta : Metadata
      -- ^ Additional metadata specific to the allocation, used for extensibility.
  deriving (Show, Eq)


-- Utility for matching with metadata
-------------------------------------

-- If an app has an expected allocation and receives a allocation, it needs
-- to check whether they match. The received may have extra metadata so a simple
-- equality check is insufficient. This function checks that the received
-- has only _additional_ metadata.

matchMeta : Metadata -> Metadata -> Either Text ()
matchMeta expected received = do
  F.forA_ (TextMap.toList expected.values) (\(k, v) -> do
      case TextMap.lookup k received.values of
        None -> abort ("Entry missing in received metadata: " <> k)
        Some w
          | w == v -> return ()
          | otherwise -> abort ("Matadata entry " <> k <> "doesn't match.\nExpected: " <> v <> "\nReceived: " <> w)
    )

matchLegs : [TransferLeg] -> [TransferLeg] -> Either Text ()
matchLegs expected received = do
  assertMsg 
    ("Expected " <> show (length expected) <> " transfer legs. Received " <> show (length received))
    (length expected == length received)
  F.forA_ (zip expected received) (\(e, r) -> do
      assertMsg
        ("Expected transfer leg Id " <> r.transferLegId <> ", but got " <> e.transferLegId)
        (e.transferLegId == r.transferLegId)
      let
        baseExpected = e with meta = emptyMetadata 
        baseReceived = r with meta = emptyMetadata
      baseExpected === baseReceived
      matchMeta e.meta r.meta
    )

matchAllocationWithMeta : AllocationSpecification -> AllocationSpecification -> Either Text ()
matchAllocationWithMeta expected received = do
  let
    baseExpected = expected with
      transferLegs = []
      settlement = expected.settlement with
        meta = emptyMetadata
    baseReceived = received with
      transferLegs = []
      settlement = received.settlement with
        meta = emptyMetadata
  baseExpected === baseReceived
  matchMeta expected.settlement.meta received.settlement.meta
  matchLegs expected.transferLegs received.transferLegs

-- Utility for settling allocations using the recommended algorithm
--------------------------------------------------------------------
-- TODO: Move away from interfaces to make easier to upgrade?

settleAllocations : 
  [TransferLeg] ->
  Map (InstrumentId, Account) [ContractId Holding] ->
  Map (Party, Account) (ContractId Allocation, ExtraArgs) ->
  Update ((Map (InstrumentId, Account) [ContractId Holding]), [Metadata])
settleAllocations 
  transferLegs 
  -- ^ transferLegs specifies he execution order of transfer legs.
  -- The boolean indicates whether receiver auth is needed.
  holdings
  -- ^ holdings are all input holdings, sorted by instrumentId. Typically these
  -- match the instrumentIds on the allocations.
  allocationsWithContext 
  -- ^ these are the allocations to be used, grouped by admin and account.
  = do
    -- Start by sorting all transferauthorizations into a map.
    -- authsByLeg : Map (TransferLeg, Account) (ContractId AllocationTransferAuthorization)
    authsByLeg <- Map.fromList . concat <$>
      mapA (\((_, account), (aCid, extraArgs)) -> do
        auths <- exercise aCid Allocation_GetTransferAuthorizations with extraArgs
        return (map (\(tlId, authCid) -> ((tlId, account), authCid)) (TextMap.toList auths)) 
        ) 
        (Map.toList allocationsWithContext)
    settleAuthorizations transferLegs holdings authsByLeg

settleAuthorizations :
  [TransferLeg] ->
  Map (InstrumentId, Account) [ContractId Holding] ->
  Map (Text, Account) (ContractId AllocationTransferAuthorization) ->
  Update ((Map (InstrumentId, Account) [ContractId Holding]), [Metadata])
settleAuthorizations   
  transferLegs 
  -- ^ transferLegs specifies he execution order of transfer legs.
  -- The boolean indicates whether receiver auth is needed.
  holdings
  -- ^ holdings are all input holdings, sorted by instrumentId. Typically these
  -- match the instrumentIds on the allocations.
  authsByLeg
  -- ^ The needed AllocationTransferAuthorizations soted by leg and authorizer.
 = foldlA (\(hs, ms) tl -> do
    -- Get a receiver authorization as needed
    let auth_r = Map.lookup (tl.transferLegId, tl.receiver) authsByLeg
    -- Get input holdings
    let h = fromOptional [] (Map.lookup (tl.instrumentId, tl.sender) hs)

    res <- case Map.lookup (tl.transferLegId, tl.sender) authsByLeg of
      None -> abort ("No sender authorization found for transferLeg " <> show tl)
      Some auth_s -> 
        exercise auth_s AllocationTransferAuthorization_Transfer with
          receiverAuth = auth_r
          holdingCids = h
          extraObservers = if isSome auth_r then tl.receiver.owner::(optionalToList tl.receiver.provider) else []
    -- Update the holdings maps
    let 
      hs' =
        Map.insert (tl.instrumentId, tl.sender) res.senderHoldingCids $
        Map.insert (tl.instrumentId, tl.receiver) 
          (res.receiverHoldingCids ++ fromOptional [] (Map.lookup (tl.instrumentId, tl.receiver) hs)) $
        hs
      
    return (hs', res.meta::ms)
  )
  (holdings, [])
  transferLegs


default_allocation_executeTransferImpl : Allocation -> ContractId Allocation -> Allocation_ExecuteTransfer -> Update Allocation_ExecuteTransferResult
default_allocation_executeTransferImpl this self args = do
  let
    holdings = 
      Map.fromList $
        map
          (\(instrumentId, hs) -> ((instrumentId, (view this).sender), hs))
          (Map.toList (view this).holdingCids)
  
    allocationsWithContext = (Map.fromList [((allocationAdmin (view this).allocation, (view this).sender), (self, args.extraArgs))])
  
  authsByLeg <- Map.fromList . concat <$>
    mapA (\((_, account), (_, extraArgs)) -> do
      auths <- allocation_getTransferAuthorizationsImpl this self (Allocation_GetTransferAuthorizations with extraArgs)
      return (map (\(tlId, authCid) -> ((tlId, account), authCid)) (TextMap.toList auths)) 
      ) 
      (Map.toList allocationsWithContext)

  (hs, ms) <- settleAuthorizations
    (view this).allocation.transferLegs
    holdings
    authsByLeg

  let
    (receiverHoldingCids, senderHoldingCids) = foldl
      (\(r, s) ((_, account), h) -> 
        if account == (view this).sender
          then (r, s ++ h)
          else (r ++ h, s)
      )
      ([], [])
      (Map.toList hs)

    meta = case ms of
      [meta] -> meta
      _ -> Metadata with 
        values = TextMap.fromList $ 
          concatMap (\(tl, m) -> map (\(k, v) -> (tl.transferLegId <> "/" <> k, v)) (TextMap.toList m.values)) (zip (view this).allocation.transferLegs ms)

  return Allocation_ExecuteTransferResult with
    receiverHoldingCids
    senderHoldingCids
    meta
