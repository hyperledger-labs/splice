-- Copyright (c) 2024 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- | This module defines the `Allocation` interface and supporting types.
--
-- Contracts implementing the `Allocation` interface represent a reservation of
-- assets to transfer them as part of an atomic on-ledger settlement requested
-- by an app.
module Splice.Api.Token.AllocationV2 where

import DA.List (dedup, dedupSort)
import DA.TextMap as TextMap

import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV2 (Holding, InstrumentId, Account)
import qualified DA.Foldable as F
import DA.Assert ((===))
import DA.Optional (optionalToList)

-- | A generic type to refer to data defined within an app.

-- The interpretation of such a reference is app specific, but SHOULD be unambiguous within the context of the app.
data Reference = Reference with
    id : Text
      -- ^ The key that identifies the data. Can be set to the empty string if the contract-id is provided and is sufficient.
    cid : Optional AnyContractId
      -- ^ Optional contract-id to use for referring to contracts.
      --
      -- This field is there for technical reasons, as contract-ids cannot be converted to text from within Daml,
      -- which is due to their full textual representation being only known after transactions have been prepared.
  deriving (Show, Eq)

-- | The minimal set of information about a settlement that an app would like to execute.
data SettlementInfo = SettlementInfo
  with
    executor : Party
      -- ^ The party that is responsible for executing the settlement.
    settlementRef : Reference
      -- ^ Reference to the settlement that app would like to execute.
    requestedAt : Time
      -- ^ When the settlement was requested. Provided for display and debugging purposes,
      -- but SHOULD be in the past.
    settleAt : Time
      -- ^ The earliest settlement time. Allocations should be made before this time. Settlement
      -- happens at any point after this time.
    meta : Metadata
      -- ^ Additional metadata about the settlement, used for extensibility.
    controllerOverride : Optional [Party]
      -- ^ Additional party signatures in addition to executor that need to authorize
      -- choices on the Allocation. Defaults to senders and receivers across all 
      -- transferLegs.
    settlementDeadline : Optional Time
      -- ^ The latest point at which settlement will occur. This allows registries
      -- to set appropriate locks and expiries.
  deriving (Show, Eq)

-- | A specification of a transfer of holdings between two parties for the
-- purpose of a settlement, which often requires the atomic execution of multiple legs.
data TransferLeg = TransferLeg with
    sender : Account
      -- ^ The sender of the transfer.
    receiver : Account
      -- ^ The receiver of the transfer.
    amount : Decimal
      -- ^ The amount to transfer.
    instrumentId : InstrumentId
      -- ^ The instrument identifier.
    meta : Metadata
      -- ^ Additional metadata about the transfer leg, used for extensibility.
  deriving (Eq, Ord, Show)

-- | The specification of an allocation of assets to a specific leg of a settlement.
--
-- In contrast to an `AllocationView` this just specifies what should be allocated,
-- but not the holdings that are backing the allocation.
data AllocationSpecification = AllocationSpecification with
    settlement : SettlementInfo
      -- ^ The settlement for whose execution the assets are being allocated.
    transferLegs: TextMap TransferLeg
     -- ^ the transfers that this allocation satisfies
  deriving (Show, Eq)

-- | View of a funded allocation of assets to a specific leg of a settlement.
-- To be standards compliant, an allocation must have a non-zero number of
-- transfer legs, all with an instrumentId with the same adminId.
data AllocationView = AllocationView with
    allocation : AllocationSpecification
      -- ^ The settlement for whose execution the assets are being allocated.
    holdingCids : [ContractId Holding]
      -- ^ The holdings that are backing this allocation.
      --
      -- Provided so that that wallets can correlate the allocation with the
      -- holdings.
      --
      -- MAY be empty for registries that do not represent their holdings on-ledger.
    meta : Metadata
      -- ^ Additional metadata specific to the allocation, used for extensibility.
    senders : [Account]
      -- ^ The senders of this allocation, who could also authorize incoming transfers
      -- through Allocation_AuthorizeIncoming
    requiredReceiverAuth : [Account]
      -- ^ The extra account authorization this allocation needs for settlement on top of
      -- the controllers specified via allocation.settlement.controllerOverride
    expiresAt : Optional Time
    -- ^ A time at which this allocation expires. SHOULD be as close as the
    -- registry can make it to the settlementInfo's settlementDeadline.
  deriving (Show, Eq)

-- | View of a delegated authority from the signer to the execurot to settle given transfer legs.
-- authorizers are always the signatories so not made available in the viewtype.
data AllocationTransferAuthorizationView = AllocationTransferAuthorizationView with
  allocation : AllocationSpecification
  receiver : Account
  admin : Party
  -- ^ the settlement to which this authorization applies. 



-- Allocation
------------------------

-- | Convenience function to refer to the union of sender, receiver, and
-- executor of the settlement, which jointly control the execution of the
-- allocation.
defaultAllocationControllers : AllocationSpecification -> [Party]
defaultAllocationControllers AllocationSpecification{..} =
  dedup $ settlement.executor :: concatMap (\leg -> [leg._2.sender.owner, leg._2.receiver.owner]) (toList transferLegs)

-- | Convenience function read out the overridden allocation controllers.
allocationControllers : AllocationSpecification -> [Party]
allocationControllers alloc@AllocationSpecification{..} =
  optional
    (defaultAllocationControllers alloc)
    (\override -> dedup $ settlement.executor :: override)
    settlement.controllerOverride

-- | Convenience to get the allocation admin
allocationAdmin : AllocationSpecification -> Party
allocationAdmin AllocationSpecification{..} = admin
  where
    admins = dedupSort $ map (._2.instrumentId.admin) (toList transferLegs)
    admin = case admins of
      [a] -> a
      _ -> error "Allocations must involve instruments from exactly one admin"

-- | A contract representing an allocation of some amount of asset holdings to
-- a specific leg of a settlement.
interface Allocation where
  viewtype AllocationView

  allocation_executeTransferImpl : ContractId Allocation -> Allocation_ExecuteTransfer -> Update Allocation_ExecuteTransferResult
  allocation_cancelImpl : ContractId Allocation -> Allocation_Cancel -> Update Allocation_CancelResult
  allocation_withdrawImpl : ContractId Allocation -> Allocation_Withdraw -> Update Allocation_WithdrawResult
  allocation_executeAuthorizeIncomingImpl : ContractId Allocation -> Allocation_AuthorizeIncoming -> Update (ContractId AllocationTransferAuthorization)

  nonconsuming choice Allocation_AuthorizeIncoming : ContractId AllocationTransferAuthorization
  -- ^ Transfer the authority from this Allocation to a AllocationTransferAuthorization which
  -- can then be used in another allocation's Allocation_ExecuteTransfer to authorize incoming
  -- transfers.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller allocationControllers (view this).allocation
    do allocation_executeAuthorizeIncomingImpl this self arg

  -- NOTE: This used to be consuming. Implementations now must archive self.
  nonconsuming choice Allocation_ExecuteTransfer : Allocation_ExecuteTransferResult
    -- ^ Execute the transfer of the allocated assets. Intended to be used to execute the settlement.
    -- This choice SHOULD succeed provided the `settlement.settleBefore` deadline has not yet passed.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
      extraAuth : [ContractId AllocationTransferAuthorization]
        -- ^ Contract encapsulating extra authority needed to exercise the choice 
    controller allocationControllers (view this).allocation
    do allocation_executeTransferImpl this self arg

  choice Allocation_Cancel : Allocation_CancelResult
    -- ^ Cancel the allocation. Requires authorization from sender, receiver, and
    -- executor.
    --
    -- Typically this authorization is granted by sender and receiver to the
    -- executor as part of the contract coordinating the settlement, so that
    -- that the executor can release the allocated assets early in case the
    -- settlement is aborted or it has definitely failed.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller allocationControllers (view this).allocation
    do allocation_cancelImpl this self arg

  choice Allocation_Withdraw : Allocation_WithdrawResult
    -- ^ Withdraw the allocated assets. Used by the sender to withdraw the assets before settlement
    -- was completed. This SHOULD not fail settlement if the sender has still time to allocate the
    -- assets again; i.e., the `settlement.allocateBefore` deadline has not yet passed.
    with
      extraArgs : ExtraArgs
        -- ^ Additional context required in order to exercise the choice.
    controller concatMap (\acc -> acc.owner :: optionalToList acc.provider) (view this).senders
    do allocation_withdrawImpl this self arg

-- AllocationTransferAuthorization
----------------------------------

-- | A contract representing a delegated authority from the signatories to the execuror to settle 
-- given transfer legs.
interface AllocationTransferAuthorization where
  viewtype AllocationTransferAuthorizationView

-- Result types
---------------

-- | The result of the `Allocation_ExecuteTransfer` choice.
data Allocation_ExecuteTransferResult = Allocation_ExecuteTransferResult
  with
    senderHoldingCids : [ContractId Holding]
      -- ^ The holdings that were created for the sender. Can be used to return
      -- "change" to the sender if required.
    receiverHoldingCids : [ContractId Holding]
      -- ^ The holdings that were created for the receiver.
    meta : Metadata
      -- ^ Additional metadata specific to the transfer instruction, used for extensibility.
  deriving (Show, Eq)

-- | The result of the `Allocation_Cancel` choice.
data Allocation_CancelResult = Allocation_CancelResult
  with
    senderHoldingCids : [ContractId Holding]
      -- ^ The holdings that were released back to the sender.
    meta : Metadata
      -- ^ Additional metadata specific to the allocation, used for extensibility.
  deriving (Show, Eq)

-- | The result of the `Allocation_Withdraw` choice.
data Allocation_WithdrawResult = Allocation_WithdrawResult
  with
    senderHoldingCids : [ContractId Holding]
      -- ^ The holdings that were released back to the sender.
    meta : Metadata
      -- ^ Additional metadata specific to the allocation, used for extensibility.
  deriving (Show, Eq)


-- Utility for matching with metadata
-------------------------------------

-- If an app has an expected allocation and receives a allocation, it needs
-- to check whether they match. The received may have extra metadata so a simple
-- equality check is insufficient. This function checks that the received
-- has only _additional_ metadata.

matchMeta : Metadata -> Metadata -> Either Text ()
matchMeta expected received = do
  F.forA_ (TextMap.toList expected.values) (\(k, v) -> do
      case TextMap.lookup k received.values of
        None -> abort ("Entry missing in received metadata: " <> k)
        Some w
          | w == v -> return ()
          | otherwise -> abort ("Matadata entry " <> k <> "doesn't match.\nExpected: " <> v <> "\nReceived: " <> w)
    )

matchLegs : TextMap TransferLeg -> TextMap TransferLeg -> Either Text ()
matchLegs expected received = do
  assertMsg 
    ("Expected " <> show (TextMap.size expected) <> " transfer legs. Received " <> show (TextMap.size received))
    (TextMap.size expected == TextMap.size received)
  F.forA_ (TextMap.toList expected) (\(tlId, tl_e) -> do
      tl_r <- case TextMap.lookup tlId received of
        None -> abort ("Did not receive expected transfer leg with Id " <> tlId)
        Some tl -> Right tl
      let
        baseExpected = tl_e with meta = emptyMetadata 
        baseReceived = tl_r with meta = emptyMetadata
      baseExpected === baseReceived
      matchMeta tl_e.meta tl_r.meta
    )

matchAllocationWithMeta : AllocationSpecification -> AllocationSpecification -> Either Text ()
matchAllocationWithMeta expected received = do
  let
    baseExpected = expected with
      transferLegs = TextMap.empty
      settlement = expected.settlement with
        meta = emptyMetadata
    baseReceived = received with
      transferLegs = TextMap.empty
      settlement = received.settlement with
        meta = emptyMetadata
  baseExpected === baseReceived
  matchMeta expected.settlement.meta received.settlement.meta
  matchLegs expected.transferLegs received.transferLegs

